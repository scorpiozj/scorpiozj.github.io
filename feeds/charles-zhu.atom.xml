<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>To be Independent</title><link href="http://icocoa.tk/" rel="alternate"></link><link href="http://icocoa.tk/feeds/charles-zhu.atom.xml" rel="self"></link><id>http://icocoa.tk/</id><updated>2015-08-31T11:20:00+08:00</updated><entry><title>My super title</title><link href="http://icocoa.tk/my-super-post.html" rel="alternate"></link><updated>2015-08-31T11:20:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-08-31:my-super-post.html</id><summary type="html">&lt;h2&gt;Localization 之 复数(Plural)变化&lt;/h2&gt;
&lt;p&gt;处理本地化文本中，需要处理不同语言的复数情况，在iOS7中引入了&lt;code&gt;stringsdict&lt;/code&gt;来处理这种情况。&lt;code&gt;stringsdict&lt;/code&gt;本质上是一个&lt;code&gt;plist&lt;/code&gt;文件，先看一个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;"1.0"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;Remove&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSStringLocalizedFormatKey&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;%#@variable_0@&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;variable_0&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSStringFormatSpecTypeKey&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;NSStringPluralRuleType&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSStringFormatValueTypeKey&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;d&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;zero&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove NO file&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;one&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove the file&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;two&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove %d files&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;few&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove %d files&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;many&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove %d files&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;other&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;remove %d files&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;Remove&lt;/code&gt;是用于&lt;code&gt;NSLocalizedString&lt;/code&gt;的输入参数，它的值是一个 &lt;code&gt;Dictionary&lt;/code&gt;。该&lt;code&gt;Dictionary&lt;/code&gt; 包含2个或多个key：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSStringLocalizedFormatKey: 用于声明变量，变量都以%#@开始，以@结束&lt;/li&gt;
&lt;li&gt;变量: 以NSStringLocalizedFormatKey中定义的变量名为key&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来说明变量作为key时的value值：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;NSStringFormatSpecTypeKey: 值必须为 NSStringPluralRuleType&lt;/li&gt;
&lt;li&gt;NSStringFormatValueTypeKey: 声明变量的类型，如%d, %lu等&lt;/li&gt;
&lt;li&gt;zero: 变量为0时的文字说明&lt;/li&gt;
&lt;li&gt;one: 变量为1时的文字说明&lt;/li&gt;
&lt;li&gt;few,many: 有些语言可以设置 &lt;/li&gt;
&lt;li&gt;other: 该值必须有，包含所有没有列举的情形&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;注意：&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;other是必须的&lt;/li&gt;
&lt;li&gt;英文系统中只需要 one, other&lt;/li&gt;
&lt;li&gt;&lt;code&gt;stringsdict&lt;/code&gt; 文件本地化后，需要清理缓存，并有可能需要删除后方能&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;官方文档：&lt;a href="https://developer.apple.com/library/ios/documentation/MacOSX/Conceptual/BPInternational/StringsdictFileFormat/StringsdictFileFormat.html"&gt;StringsdictFileFormat&lt;/a&gt;&lt;/p&gt;</summary><category term="Localization"></category><category term="stringsdict"></category></entry><entry><title>Autolayout: UITableViewCell中UILabel的水平布局</title><link href="http://icocoa.tk/autolayout-uitableviewcellzhong-uilabelde-shui-ping-bu-ju.html" rel="alternate"></link><updated>2015-08-01T17:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-08-01:autolayout-uitableviewcellzhong-uilabelde-shui-ping-bu-ju.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: UITableVIewCell中两列UILabel的布局总结&lt;/p&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;一眨眼，六月底新入职现在公司已一月有余，期间工作节奏比之前一家增加许多，像是回到若干年前昼夜奋战几周完成一个app的状态。唯一不同的是，现在更需注重效率，复用原有的经验。&lt;/p&gt;
&lt;h3&gt;UITableViewCell中水平分布的两列UILabel&lt;/h3&gt;
&lt;p&gt;比如，在最近的项目中遇到UITableViewCell中水平分布两个Label，每个 label 都有可能有多行。根据不同的情况，两个lable的文字需要上/中/下对齐，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="top" src="./imgs/20150801/Top.png"/&gt;&lt;br/&gt;
上对齐  &lt;br/&gt;
&lt;img alt="center" src="./imgs/20150801/Center.png"/&gt;&lt;br/&gt;
中对齐&lt;br/&gt;
&lt;img alt="bottom" src="./imgs/20150801/Bottom.png"/&gt; &lt;br/&gt;
下对齐  &lt;/p&gt;
&lt;p&gt;由于是单兵作战——iOS端就我一个人，所以大多数界面布局在SB中进行，可是当具有上述布局的页面多了后，通过代码来实现反而会高效。鉴于此，封装了一个Cell类以支持三种布局。具体的实现代码和使用方法见：&lt;a href="https://github.com/scorpiozj/ZZHorizontalLabelsCell"&gt;ZZHorizontalLabelsCell&lt;/a&gt;，不多做解释了。有不懂的，可以留言。&lt;/p&gt;
&lt;h3&gt;布局的SB实现&lt;/h3&gt;
&lt;p&gt;为了方便使用SB布局的情况，这里也把三种布局下lable的约束说明：&lt;/p&gt;
&lt;h4&gt;上对齐&lt;/h4&gt;
&lt;p&gt;&lt;img alt="left" src="./imgs/20150801/TopLeft.png"/&gt;&lt;br/&gt;
Left&lt;br/&gt;
&lt;img alt="right" src="./imgs/20150801/TopRight.png"/&gt;&lt;br/&gt;
Right 
其中，右边Label的bottom的约束优先级设为 749.&lt;/p&gt;
&lt;h4&gt;中对齐&lt;/h4&gt;
&lt;p&gt;&lt;img alt="left" src="./imgs/20150801/CenterLeft.png"/&gt;&lt;br/&gt;
Left&lt;br/&gt;
&lt;img alt="right" src="./imgs/20150801/CenterRight.png"/&gt;&lt;br/&gt;
Right&lt;/p&gt;
&lt;h4&gt;下对齐&lt;/h4&gt;
&lt;p&gt;&lt;img alt="left" src="./imgs/20150801/BottomLeft.png"/&gt;&lt;br/&gt;
Left&lt;br/&gt;
&lt;img alt="right" src="./imgs/20150801/BottomRight.png"/&gt;&lt;br/&gt;
Right&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;之所以要单独谈这一个问题，是因为其囊括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Autolayout下，UITableViewCell的高度自适应&lt;/li&gt;
&lt;li&gt;Autolayout的概念理解，尤其是hugging/compression resistance的理解&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;而代码和SB的两种实现都遵循相同的布局法则，这里分开来说明也是为了“兼容”纯代码和SB布局。&lt;/p&gt;</summary><category term="iOS"></category><category term="autolayout"></category><category term="UITableViewCell"></category><category term="UILabel"></category></entry><entry><title>6月工作总结</title><link href="http://icocoa.tk/6yue-gong-zuo-zong-jie.html" rel="alternate"></link><updated>2015-06-17T17:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-06-17:6yue-gong-zuo-zong-jie.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 近期工作总结&lt;/p&gt;
&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;因为一些原因，下了100%的决心：换工作。换工作倒也不难，只是找一份匹配度高的工作，的确很难，尤其是在所处的二线城市。个中滋味，——如鱼饮水，通过这些经历，对自己的发展和定位，有了一个较为明晰的看法。&lt;br/&gt;
最近在整理工作内容准备交接，倒是找出了一些工作中遇到的记录，准备整理出来，晒晒自己的一些经历。&lt;/p&gt;
&lt;h3&gt;一些纪录&lt;/h3&gt;
&lt;p&gt;工作中遇到的问题，往往会由问题A牵涉到问题Z。下次再遇到或许没那么快想起该怎么做，所以记在记事本还是个不错的&lt;/p&gt;
&lt;h4&gt;project.pbxproj的git冲突合并&lt;/h4&gt;
&lt;p&gt;开发过程中，当前功能未开发完版本有更新时：
    git stash //保存当前的工作内容，并将工作区置于上一次提交的HEAD
    git pull origin master//获取更新
    git stash pop //恢复当前工作内容&lt;/p&gt;
&lt;p&gt;以上过程中git会进行自动合并，但有时候需要人工合并。比如 project.pbxproj有冲突的时候。这时打开相应的冲突文件，通过"&amp;lt;&amp;lt;&amp;lt;"找到冲突区域进行修改。然后执行命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git commit file_path -i -m "fix merge confilic"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;另外，找到个处理 &lt;code&gt;project.pbxproj&lt;/code&gt; 的&lt;a href="https://github.com/truebit/xUnique"&gt;脚本&lt;/a&gt;，没有使用，有兴趣可以一试。&lt;/p&gt;
&lt;h4&gt;git 查看某个commit的详细内容&lt;/h4&gt;
&lt;p&gt;通过 &lt;code&gt;git log&lt;/code&gt; 可以查看提交历史，当需要查看某个commit受影响的文件以及文件的修改时：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git commit commit_id -p
git commit commit_id --stat
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;"commi_id"通过 &lt;code&gt;git log&lt;/code&gt; 获得，是一个hash字符串，在实际运用的时候，取前几位(4位)即可。&lt;/p&gt;
&lt;h4&gt;iOS code signing is required for product type 'Unit Test Bundle' in SDK 'iOS 8.2'&lt;/h4&gt;
&lt;p&gt;最近遇到的问题，当你对 test target做相应设置时，还是会报错。这时需要做的是，在工程的 "Build Settings"中选择正确的账号证书和provision。&lt;/p&gt;
&lt;h4&gt;iOS Crash: 'Auto Layout still required after executing -layoutSubviews.'&lt;/h4&gt;
&lt;p&gt;完整的crash log：&lt;/p&gt;
&lt;blockquote&gt;
&lt;blockquote&gt;
&lt;p&gt;&lt;strong&gt;&lt;em&gt; Assertion failure in -[UITableView layoutSublayersOfLayer:], /SourceCache/UIKit/UIKit-2935.137/UIView.m:8794
2015-xx-xx xx:xx:xx.xxx xx[xxxx:60b] &lt;/em&gt;&lt;/strong&gt; Terminating app due to uncaught exception 'NSInternalInconsistencyException',
 reason: 'Auto Layout still required after executing -layoutSubviews. UITableView's implementation of -layoutSubviews needs to call super.'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;/blockquote&gt;
&lt;p&gt;该crash是 显示一个 UITableView 的时候出现。我的情况是 使用UITableView(没有继承)，所以应该不会直接操作 &lt;code&gt;layoutSubviews&lt;/code&gt;。而且该crash只在iOS7上出现，iOS8＋上则没有。注意到断言出错的方法是 &lt;code&gt;-[UITableView layoutSublayersOfLayer:]&lt;/code&gt;， 出错的异常却是 &lt;code&gt;layoutSubviews&lt;/code&gt;，考虑使用API有误：少传参数，或者调用顺序出错之类。 google后，发现有位同仁遇到类似的&lt;a href="http://www.cnblogs.com/xyzaijing/p/4104157.html"&gt;问题&lt;/a&gt;。 细细想来，还是没有思路。经过排查，发现是在 UITableView 上添加了 subview 导致的。具体原因不详。&lt;br/&gt;
此外，github上有一则&lt;a href="http://stackoverflow.com/questions/19837097/why-am-i-getting-a-auto-layout-still-required-after-executing-layoutsubviews"&gt;讨论&lt;/a&gt;，也可以看看。&lt;/p&gt;
&lt;h4&gt;strip&lt;/h4&gt;
&lt;p&gt;在CentOS为类NAS设备开发固件程序的时候，对程序大小有要求。我们在makefile文件中添加 &lt;code&gt;-s&lt;/code&gt; 参数，用于减小程序的体积。该参数意即使用strip命令，通过除去绑定程序和符号调试程序使用的信息，减少扩展公共对象文件格式（XCOFF）的对象文件的大小。&lt;/p&gt;
&lt;h4&gt;CentOS上创建静态库和动态库&lt;/h4&gt;
&lt;p&gt;假设文件 &lt;code&gt;test.c&lt;/code&gt;&lt;br/&gt;
创建并使用静态库：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gcc -c test.c
ar rcs libtest.a test.o
//use the libxxx.a
gcc -o main main.c -L. -ltest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;创建并使用动态库：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gcc -shared -fPIC -o libtest.so test.o
//use the libxxx.so
gcc -o main main.c -L. -ltest
LD_LIBRARY_PATH=. ./main
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;注意库的命名，使用库时参数 &lt;code&gt;-L&lt;/code&gt; &lt;code&gt;-l&lt;/code&gt; 的涵义。&lt;br/&gt;
ar有丰富的内涵，也需要对程序从编译，链接，生成可执行程序有较深的了解。&lt;/p&gt;
&lt;h4&gt;otool&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;ldd&lt;/code&gt; 可以查看链接库的各种信息，在Mac OS X平台上由&lt;code&gt;otool&lt;/code&gt;替代。&lt;br/&gt;
&lt;code&gt;size&lt;/code&gt; 可以查看可执行文件/库等的各个段的size信息。  &lt;/p&gt;</summary><category term="iOS"></category><category term="git"></category></entry><entry><title>Autolayout中Hugging和Compression使用注意</title><link href="http://icocoa.tk/autolayoutzhong-hugginghe-compressionshi-yong-zhu-yi.html" rel="alternate"></link><updated>2015-06-01T15:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-06-01:autolayoutzhong-hugginghe-compressionshi-yong-zhu-yi.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: autolayout概念加深&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;本文主要侧重&lt;code&gt;Autolayout&lt;/code&gt;使用过程中，通过代码和SB添加含有&lt;code&gt;intrinsicSize&lt;/code&gt;属性控件约束的一些细节。  &lt;/p&gt;
&lt;h2&gt;Hugging和Compression 属性&lt;/h2&gt;
&lt;p&gt;有很多关于这两个概念的文章，比如stackoverflow上&lt;a href="http://stackoverflow.com/a/16281229/371974"&gt;Cocoa Autolayout: content hugging vs content compression resistance priority&lt;/a&gt;。我觉得很形象的说明了设置了有什么用，但是还欠缺什么时候使用，即和｀intrinsicSize`的关系。先来看下文档上的说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;- contentCompressionResistancePriorityForAxis:
Returns the priority with which a view resists being made smaller than its intrinsic size.

- contentHuggingPriorityForAxis:
Returns the priority with which a view resists being made larger than its intrinsic size.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这么一看，就很明了：对于有 intrinsicSize 属性的控件(如UILabel，UIButton等)，如果当前的frame比显示的content范围大，那么设置的Hugging属性起作用，否则设置的Compression属性起作用。对于相应的数值，越大表明优先级越高，意味着当前的属性占优。简单的说，对于需要Hugging的情形，hugging属性的值越大(优先级越高)，那么表明控件需要紧凑的显示。&lt;br/&gt;
Hugging和Compression属性值有默认值：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;对于纯代码添加的控件，Hugging默认250.0f，Compression默认 750.0f&lt;/li&gt;
&lt;li&gt;通过SB添加，Hugging默认251.0f，Compression默认750.0f&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为什么会有不一样的值？那么先看一下 UILayoutPriority的取值：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriority&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriorityRequired&lt;/span&gt; &lt;span class="n"&gt;NS_AVAILABLE_IOS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="n"&gt;_0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;1000&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// A required constraint.  Do not exceed this.&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriority&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriorityDefaultHigh&lt;/span&gt; &lt;span class="n"&gt;NS_AVAILABLE_IOS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="n"&gt;_0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;750&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// This is the priority level with which a button resists compressing its content.&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriority&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriorityDefaultLow&lt;/span&gt; &lt;span class="n"&gt;NS_AVAILABLE_IOS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="n"&gt;_0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;250&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="c1"&gt;// This is the priority level at which a button hugs its contents horizontally.&lt;/span&gt;

&lt;span class="k"&gt;static&lt;/span&gt; &lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriority&lt;/span&gt; &lt;span class="n"&gt;UILayoutPriorityFittingSizeLevel&lt;/span&gt; &lt;span class="n"&gt;NS_AVAILABLE_IOS&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;6&lt;/span&gt;&lt;span class="n"&gt;_0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;50&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;// When you send -[UIView systemLayoutSizeFittingSize:], the size fitting most closely to the target size (the argument) is computed.  UILayoutPriorityFittingSizeLevel is the priority level with which the view wants to conform to the target size in that computation.  It's quite low.  It is generally not appropriate to make a constraint at exactly this priority.  You want to be higher or lower.&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由此可见，在设计的时候，iOS的开发人员考虑到类似UILabel的控件首要的是显示所有的内容。&lt;/p&gt;
&lt;h2&gt;编程实现&lt;/h2&gt;
&lt;p&gt;通过一段代码，加载一个button：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;UIButton&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIButton&lt;/span&gt; &lt;span class="nl"&gt;buttonWithType&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIButtonTypeRoundedRect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;translatesAutoresizingMaskIntoConstraints&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backgroundColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;redColor&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="nl"&gt;setTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"a long long title"&lt;/span&gt; &lt;span class="nl"&gt;forState&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIControlStateNormal&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;


&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;addSubview&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="bp"&gt;NSLayoutConstraint&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSLayoutConstraint&lt;/span&gt; &lt;span class="nl"&gt;constraintWithItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeLeading&lt;/span&gt; &lt;span class="nl"&gt;relatedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutRelationEqual&lt;/span&gt; &lt;span class="nl"&gt;toItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeLeading&lt;/span&gt; &lt;span class="nl"&gt;multiplier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt; &lt;span class="nl"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;addConstraint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;constraint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSLayoutConstraint&lt;/span&gt; &lt;span class="nl"&gt;constraintWithItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;button&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeTop&lt;/span&gt; &lt;span class="nl"&gt;relatedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutRelationEqual&lt;/span&gt; &lt;span class="nl"&gt;toItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeTop&lt;/span&gt; &lt;span class="nl"&gt;multiplier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;1.0f&lt;/span&gt; &lt;span class="nl"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;100.0f&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;addConstraint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;constraint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSLayoutConstraint&lt;/span&gt; &lt;span class="nl"&gt;constraintWithItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;button1&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeWidth&lt;/span&gt; &lt;span class="nl"&gt;relatedBy&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutRelationEqual&lt;/span&gt; &lt;span class="nl"&gt;toItem&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;attribute&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSLayoutAttributeWidth&lt;/span&gt; &lt;span class="nl"&gt;multiplier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;constant&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;50.0f&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;addConstraint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;constraint&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如上添加的constraint，使得button的frame不足以显示标题内容，注意上述constraint默认的优先级都是UILayoutPriorityRequired。因此我们可以通过修改最后一个宽度的constraint：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;constraint.priority = UILayoutPriorityDefaultHigh - 1;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对于用SB添加的控件，也可以用类似的方法修改。至于为什么，SB中添加的如UILable的控件，当给其添加某个约束后，SB中Hugging属性的值是251呢？这是为了默认可以显示全内容。此时，你可以在sb中手动把空间尺寸变小，再把控件的某个属性的constriant(width或tailing)的优先级设置为low。这时，你也可以在SB中发现相应的约束由蓝色实线变成了蓝色虚线。当然，如果compression约束起作用的情况下，约束也是蓝色虚线。 &lt;/p&gt;
&lt;h2&gt;与其它控件一起使用&lt;/h2&gt;
&lt;p&gt;如上单个控件可以正常使用，如果设置一个相邻的控件，会有什么需要注意的吗？答案是NO，什么都不需要操心，仍旧按之前的方法添加约束，这极大的简化了工作量。&lt;br/&gt;
另外，这里需要说明的是，需要更新控件上文字的时候，为了有一个较好的动画效果，需要： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;[label.superView layoutIfNeeded];
&lt;/pre&gt;&lt;/div&gt;</summary><category term="iOS"></category><category term="Autolayout"></category></entry><entry><title>仿手机QQ消息小红点动画2</title><link href="http://icocoa.tk/fang-shou-ji-qqxiao-xi-xiao-hong-dian-dong-hua-2.html" rel="alternate"></link><updated>2015-05-25T11:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-05-25:fang-shou-ji-qqxiao-xi-xiao-hong-dian-dong-hua-2.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 动画学习&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://iloveanan.com/fang-shou-ji-qqxiao-xi-xiao-hong-dian-dong-hua-1.html"&gt;上一篇&lt;/a&gt;把动画的实现步骤大致理清，需要确认小尾巴的绘制区域，关键就是确定4个顶点的位置。大家可以根据需要，选择不同的计算方式。&lt;br/&gt;
今天，要实现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;文字的添加&lt;/li&gt;
&lt;li&gt;尾巴拉长用弧形代替直线&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面是现在的效果图：&lt;br/&gt;
&lt;img alt="QQ2_1.gif" src="./imgs/20150525/QQ2_1.gif"/&gt;&lt;/p&gt;
&lt;h2&gt;文字添加&lt;/h2&gt;
&lt;p&gt;为了简单，这里对文字的颜色字体等属性不提供接口，而只是在内部设置固定的值；提供一个类方法生成对象。如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;instancetype&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;zzspringViewWithText&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;text&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这个方法里面需要做：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;根据text内容，确定文字绘制的图形区域&lt;/li&gt;
&lt;li&gt;根据文字的绘制区域，确定view对象的bounds&lt;/li&gt;
&lt;li&gt;可能的情况下，限制文字的长度（QQ上消息数最多显示99+）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;在&lt;code&gt;drawRect&lt;/code&gt;中，需要做的事：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绘制带圆角的view&lt;/li&gt;
&lt;li&gt;绘制文字&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如下所示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//draw corner round rectangle&lt;/span&gt;
&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;p_drawRoundedRectWithContext:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CGContextRef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;context&lt;/span&gt; &lt;span class="nf"&gt;withRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSaveGState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMaxY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;puffer&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMaxY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="mf"&gt;0.10&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;maxX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMaxX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;puffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;maxY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMaxY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;puffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;minX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMinX&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;puffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;minY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetMinY&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;puffer&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="n"&gt;CGContextBeginPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetFillColorWithColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;redColor&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="bp"&gt;CGColor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddArc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxX&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minY&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddArc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxX&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxY&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddArc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minX&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;maxY&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddArc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minX&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minY&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGContextFillPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGContextRestoreGState&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nf"&gt;p_drawTextWithContext:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CGContextRef&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;context&lt;/span&gt; 
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSDictionary&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fontAttr&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@{&lt;/span&gt;
                                   &lt;span class="nl"&gt;NSFontAttributeName&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;fontText&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;
                                   &lt;span class="nl"&gt;NSForegroundColorAttributeName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;whiteColor&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                   &lt;span class="l"&gt;}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CGSizeEqualToSize&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;bgTextSize&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;CGSizeZero&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;bgTextSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;badgeText&lt;/span&gt; &lt;span class="nl"&gt;sizeWithAttributes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fontAttr&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;textPoint&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;((&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bgTextSize&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;bgTextSize&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="mi"&gt;1&lt;/span&gt; &lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;badgeText&lt;/span&gt; &lt;span class="nl"&gt;drawAtPoint&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;textPoint&lt;/span&gt; &lt;span class="nl"&gt;withAttributes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fontAttr&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;bgTextSize&lt;/code&gt;是之前计算过的文字的size。&lt;/p&gt;
&lt;h2&gt;弧线&lt;/h2&gt;
&lt;p&gt;绘制曲线，这里使用&lt;code&gt;CGContextAddQuadCurveToPoint&lt;/code&gt;，这里的控制点&lt;code&gt;controlPoint&lt;/code&gt;取自两圆心之间的某点(见&lt;a href="http://iloveanan.com/imgs/20150517/Drag.png"&gt;图&lt;/a&gt;)，这里我取了圆心长度的黄金分割点处作为控制点。从实际的运行情况下，可能弧度不是太明显，需要后期再调配参数。&lt;br/&gt;
这里还要纠正一下，上一篇计算切点时的方法有误：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;三角函数忘记开根号&lt;/li&gt;
&lt;li&gt;求切点的公式算错了&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;这里需要说明的是，因为添加了文字，在这里确定P1圆上2个顶点位置的时候，要注意不要覆盖到文字区域，否则移动的时候，文字会被覆盖。&lt;br/&gt;
另外，我发现QQ中，拖拽弹回的动画中，小红点上会出现很多纵横交错的白线(bug吗)，估计是用于计算连接点用的。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;本身这个动画没有什么技术难度(意思是涉及到的框架内容不实特别复杂)，复杂得是一些关键数值的确定：主要就是拖拽时尾巴的绘制区域的确定。把这一部分解决了，动画也就没有实现的难度了。当然，如果要封装成一个库来调用，还需要再精进：接口的设计，可配置的参数（颜色，字体，阴影等），这些就留给大伙自定义吧 。&lt;/p&gt;</summary><category term="quartzcore"></category></entry><entry><title>仿手机QQ消息小红点动画1</title><link href="http://icocoa.tk/fang-shou-ji-qqxiao-xi-xiao-hong-dian-dong-hua-1.html" rel="alternate"></link><updated>2015-05-17T13:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-05-17:fang-shou-ji-qqxiao-xi-xiao-hong-dian-dong-hua-1.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 动画学习&lt;/p&gt;
&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;偶然发现iPhone QQ 显示消息条数的小红点可以响应动作事件，也有人问我这样的动画该怎么做，这里就把实现的思路简单的描述一下。在实现的过程中，同样发现该功能并没有看到的那么简单，要做一个完备的动画效果需要有一定的功底。因此，本篇会先侧重于实现思路，并不会实现一个一模一样的效果。&lt;br/&gt;
下面是iPhone QQ小红点的动作交互效果：&lt;br/&gt;
&lt;img alt="iPhoneQQ" src="./imgs/20150517/QQSpring.gif"/&gt;&lt;/p&gt;
&lt;h2&gt;分析&lt;/h2&gt;
&lt;p&gt;首先我们分析拖拽时候的表现：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原先的小红点顺着手指移动，并与原来所处位置通过一个小尾巴(即移动的轨迹)连接&lt;/li&gt;
&lt;li&gt;与原先位置在一定范围内时，小尾巴出现；超过一定范围时，小尾巴不出现&lt;/li&gt;
&lt;li&gt;释放手指，小红点回到原先位置，并有弹簧动画效果&lt;/li&gt;
&lt;li&gt;释放手指时离原先位置超过一定范围则不返回原点，而是有消失的泡沫动画&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;抛开细节，抓住要点，我归纳了几个要点：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;小原点随手指移动&lt;/li&gt;
&lt;li&gt;小尾巴分情况出现&lt;/li&gt;
&lt;li&gt;手指释放后，小红点弹回原先位置&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;除此之外，红点上的文字，消失等情形的处理不是主要问题，我们先缓一缓。&lt;/p&gt;
&lt;h2&gt;实现&lt;/h2&gt;
&lt;h3&gt;红点的移动&lt;/h3&gt;
&lt;p&gt;首先实现一个圆形的view，并且可以随手指移动。在一定移动范围内，手指离开后，view返回原处并带有弹簧效果；超出范围，view则停留在手指离开处。&lt;br/&gt;
我们通过drawRect:来画一个圆；设置一个CGPoint的对象来记录开始触摸时的位置；接着就是实现相关的touchEvent:。因为都是很基本的内容，直接上代码。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//头文件&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;ZZSpringView&lt;/span&gt; : &lt;span class="bp"&gt;UIView&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;instancetype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithSquareLength:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CGFloat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;length&lt;/span&gt; &lt;span class="nf"&gt;originPoint:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;oPoint&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;span class="c1"&gt;//类文件&lt;/span&gt;
&lt;span class="k"&gt;const&lt;/span&gt; &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;kOffset&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mf"&gt;100.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//拖拽的范围限制&lt;/span&gt;
&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;ZZSpringView&lt;/span&gt; &lt;span class="p"&gt;()&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;

&lt;span class="k"&gt;@implementation&lt;/span&gt; &lt;span class="nc"&gt;ZZSpringView&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;instancetype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithFrame:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;frame&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;initWithFrame&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;            
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backgroundColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;clearColor&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;instancetype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;initWithSquareLength:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;CGFloat&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;length&lt;/span&gt; &lt;span class="nf"&gt;originPoint:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;oPoint&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;initWithFrame&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;CGRectMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;oPoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;oPoint&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;)])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;// Only override drawRect: if you perform custom drawing.&lt;/span&gt;
&lt;span class="c1"&gt;// An empty implementation adversely affects performance during animation.&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Drawing code&lt;/span&gt;
    &lt;span class="n"&gt;CGContextRef&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UIGraphicsGetCurrentContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetAllowsAntialiasing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetShouldAntialias&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGContextAddEllipseInRect&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetFillColorWithColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;redColor&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="bp"&gt;CGColor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextFillPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;_isDistanceEnough:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;kOffset&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;kOffset&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="c1"&gt;//touch event&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;touchesBegan:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;touches&lt;/span&gt; &lt;span class="nf"&gt;withEvent:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;UITouch&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touches&lt;/span&gt; &lt;span class="n"&gt;anyObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="nl"&gt;locationInView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="nl"&gt;animateWithDuration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;.3&lt;/span&gt; &lt;span class="nl"&gt;animations&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;touchesCancelled:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;touches&lt;/span&gt; &lt;span class="nf"&gt;withEvent:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;touchesMoved:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;touches&lt;/span&gt; &lt;span class="nf"&gt;withEvent:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="bp"&gt;UITouch&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touches&lt;/span&gt; &lt;span class="n"&gt;anyObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="nl"&gt;locationInView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
 &lt;span class="p"&gt;}&lt;/span&gt;

 &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nl"&gt;touchesEnded&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;touches&lt;/span&gt; &lt;span class="nl"&gt;withEvent&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;UITouch&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touches&lt;/span&gt; &lt;span class="n"&gt;anyObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="nl"&gt;locationInView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;_isDistanceEnough&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//may be destory self animation&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="nl"&gt;animateWithDuration&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;1.0&lt;/span&gt;
                              &lt;span class="nl"&gt;delay&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt;
             &lt;span class="nl"&gt;usingSpringWithDamping&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;0.1&lt;/span&gt;
              &lt;span class="nl"&gt;initialSpringVelocity&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;.0&lt;/span&gt;
                            &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt;
                         &lt;span class="nl"&gt;animations&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
                         &lt;span class="nl"&gt;completion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt; &lt;span class="n"&gt;finished&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="p"&gt;}];&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在touchBegin事件中，因为点击小红点的位置与中心会有偏移，通过UIView animation做一个平滑的过度。而在touchEnd事件中，返回弹簧震荡的效果是使用UIView的Spring animation。&lt;/p&gt;
&lt;h3&gt;添加小尾巴(轨迹)&lt;/h3&gt;
&lt;p&gt;我画了一张简化的模拟拖拽过程的图：&lt;br/&gt;
&lt;img alt="Drag" src="./imgs/20150517/Drag.png"/&gt;&lt;/p&gt;
&lt;p&gt;虚线圆是view原来的位置，P0是其圆点；实线圆是移动的位置，P1是圆点。设置两圆的切线（红色），把封闭的部分都填充为同一个颜色的话，就能大致模拟出相似的效果。这里隐含了几个前提：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;实际的轨迹是带有弧度的曲线，这里使用了切线来代替（红色的切线）&lt;/li&gt;
&lt;li&gt;拖拽的时候，原先位置的圆形view会随拖拽距离变小，这里设置为一个固定大小的圆（半径为原来的一半）&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;鉴于此，我们需要求出的是两对切点的位置，使之成为一个封闭图形进行填充。同时，虚线位置的小圆也进行填充。这样，就基本完成类似的功能。&lt;br/&gt;
首先我们需要扩展当前context的范围，为了简便，通过添加尾巴的子view来实线，这样可以利用原先的红点view。现在我们已知P0，P1，以及各自的半径，然后求外围矩形的位置和长度。因为可以按任意方向拖拽，按当前的计算方式，需要分四种情况讨论。按笛卡尔坐标系的划分，图例是第一象限的情形。同理还有二三四的可能。为了迅速验证方案的可行性，这里只对第一象限进行讨论和模拟。&lt;br/&gt;
定义新view：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;typedef&lt;/span&gt; &lt;span class="k"&gt;enum&lt;/span&gt; &lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSUInteger&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;ZZLineDirection1&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;//northease&lt;/span&gt;
    &lt;span class="n"&gt;ZZLineDirection2&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;//northwest&lt;/span&gt;
    &lt;span class="n"&gt;ZZLineDirection3&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="c1"&gt;//southwest&lt;/span&gt;
    &lt;span class="n"&gt;ZZLineDirection4&lt;/span&gt;&lt;span class="c1"&gt;//southeast&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

&lt;span class="k"&gt;@interface&lt;/span&gt; &lt;span class="nc"&gt;ZZSpringTailView&lt;/span&gt; : &lt;span class="bp"&gt;UIView&lt;/span&gt;
&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nonatomic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection&lt;/span&gt; &lt;span class="n"&gt;lineDirection&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nonatomic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//centerradius&lt;/span&gt;
&lt;span class="k"&gt;@property&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;nonatomic&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;assign&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="k"&gt;@end&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;ZZLineDirection代表的是某象限，radius是P0的半径，moveRadius为P1半径。
我们在touchMove事件中添加一个view，在此之前，我们会在ZZSpringView中添加一个ZZSpringTailView实例，用于内部访问。touchMove的实现更新为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;touchesMoved:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;touches&lt;/span&gt; &lt;span class="nf"&gt;withEvent:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="bp"&gt;UITouch&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt;  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touches&lt;/span&gt; &lt;span class="n"&gt;anyObject&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;touch&lt;/span&gt; &lt;span class="nl"&gt;locationInView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;_isDistanceEnough&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//beyond the offset, hide the view&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;hidden&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;else&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//redraw the view&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;center&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;!&lt;/span&gt;&lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;ZZSpringTailView&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
            &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;addSubview&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;widthHalf&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mf"&gt;2.0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;minX&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//= MIN(pointMove.x, pointOriginCenter.x);&lt;/span&gt;
        &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;minY&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//= MIN(pointMove.y, pointOriginCenter.y);&lt;/span&gt;
        &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;widthHalf&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;


        &lt;span class="c1"&gt;//the width: the distance betweent two points and the origin size's width/2&lt;/span&gt;
        &lt;span class="bp"&gt;CGRect&lt;/span&gt; &lt;span class="n"&gt;frameInSuper&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;minX&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;minY&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fabsf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;widthHalf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;fabsf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;  &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;widthHalf&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

        &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;radius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;moveRadius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"direnction1"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineDirection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection1&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"direnction2"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineDirection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"direnction3"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineDirection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointMove&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"direnction4"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;lineDirection&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZZLineDirection4&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;frameInSuper&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;origin&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;pointOriginCenter&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;radius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="n"&gt;tailView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;convertRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;frameInSuper&lt;/span&gt; &lt;span class="nl"&gt;fromView&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;superview&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;tailView&lt;/span&gt; &lt;span class="n"&gt;setNeedsDisplay&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里的实现是把tailview添加到springview之上，通常情况下，clipToBouds默认是NO的，因此这种添加超出父view bound 的子view方案是可行的。需要注意的是，上述的两个point是在spring view的父view内的，因此，在最后确定tailView frame的时候需要转换到springView的坐标系。&lt;br/&gt;
接下来就是tailView的drawRect实现。这里主要需要做2件事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;绘制P0为圆心的圆&lt;/li&gt;
&lt;li&gt;绘制2对切点构成的封闭图形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;drawRect的部分实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;drawRect:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGRect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;rect&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="n"&gt;CGContextRef&lt;/span&gt; &lt;span class="n"&gt;context&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UIGraphicsGetCurrentContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetAllowsAntialiasing&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetShouldAntialias&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;true&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGContextSetStrokeColorWithColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;greenColor&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="bp"&gt;CGColor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetFillColorWithColor&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIColor&lt;/span&gt; &lt;span class="n"&gt;redColor&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="bp"&gt;CGColor&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextSetLineWidth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;pointStart&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//center&lt;/span&gt;

    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;movePoint1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;movePoint2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//移动圆的2个切点&lt;/span&gt;
    &lt;span class="bp"&gt;CGPoint&lt;/span&gt; &lt;span class="n"&gt;centerPoint1&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;centerPoint2&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//原有圆的2个切点&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;_moveRadius&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;&lt;span class="c1"&gt;//移动圆 弧的半径&lt;/span&gt;

    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;sinval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;csinval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;CGFloat&lt;/span&gt; &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;switch&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;_lineDirection&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ZZLineDirection1&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="n"&gt;pointStart&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;width&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;pointEnd&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;height&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;distance&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetHeight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CGRectGetHeight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;CGRectGetWidth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CGRectGetWidth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;sinval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetHeight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CGRectGetHeight&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
            &lt;span class="n"&gt;csinval&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGRectGetWidth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;CGRectGetWidth&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;rect&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;/&lt;/span&gt;&lt;span class="n"&gt;distance&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;



            &lt;span class="n"&gt;movePoint2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointStart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sinval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointStart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;csinval&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;movePoint1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointStart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sinval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointStart&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;moveRadius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;csinval&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

            &lt;span class="n"&gt;centerPoint2&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;sinval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;csinval&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="n"&gt;centerPoint1&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;CGPointMake&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;sinval&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;csinval&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ZZLineDirection2&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ZZLineDirection3&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;
        &lt;span class="k"&gt;case&lt;/span&gt; &lt;span class="nl"&gt;ZZLineDirection4&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;
        &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;break&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="n"&gt;CGContextMoveToPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;movePoint1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;movePoint1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddLineToPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;movePoint2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;movePoint2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddLineToPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;centerPoint1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;centerPoint1&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextAddLineToPoint&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;centerPoint2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;centerPoint2&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextClosePath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;CGContextFillPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextStrokePath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;


    &lt;span class="n"&gt;CGContextAddArc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;pointEnd&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;y&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;_radius&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;M_PI&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;CGContextFillPath&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;context&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;计算过程就不详细描述了，初中数学的知识就够了。接着运行下，看看效果。  &lt;/p&gt;
&lt;p&gt;&lt;img alt="SpringDemo3" src="./imgs/20150517/QQSpring3.gif"/&gt;&lt;/p&gt;
&lt;p&gt;从运行效果看，还是差强人意的。这显示了方案的可行性。&lt;br/&gt;
那么相应二三四象限的情况也能做类似的处理，这里就不贴代码了。  &lt;/p&gt;
&lt;p&gt;由于时间的关系，暂时研究到此，下一篇会把功能逐步完善。主要会包含添加文字的情形等内容，敬请期待。&lt;br/&gt;
如果有更好的实现方式，也请大家赐教！&lt;/p&gt;</summary><category term="quartzcore"></category></entry><entry><title>随感</title><link href="http://icocoa.tk/sui-gan.html" rel="alternate"></link><updated>2015-05-11T12:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-05-11:sui-gan.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu  &lt;/p&gt;
&lt;p&gt;书桌上放着本 &amp;lt;&amp;lt;守望灯塔&amp;gt;&amp;gt;，看了快一半。买的时候，看书名以为是个励志型的故事，看了以后才知道不是，——大概和爱情，和人生有关。额，可是有什么又是和人生无关的呢。那好吧，我还是说我没看懂的好。&lt;br/&gt;
买了两盒迷你果园，一盒葫芦，一盒黄瓜，不需要额外的土，不需要施肥，只需要浇水，晒太阳，就能结果。种子同一天放进去的，水每天都浇，阳光每天都晒。就这样过了四五天，葫芦先发芽了，而且一发芽，叶子就显得很大。过了一个星期，长出来的叶子，就能分辨出是葫芦娃头上戴的样子了。而那黄瓜呢，不知怎么的，一个星期后才发芽。破土而出后，小小的叶子，就像一个早产儿。而且，三四天过去了，和最初破土而出时相比，就大了一点。&lt;br/&gt;
和葫芦的生长比，黄瓜差很多。可是，我不会认为黄瓜没有葫芦好，因为两者没有可比性。葫芦应该和葫芦去比，黄瓜要和黄瓜比。中国的葫芦可以和美国的葫芦比，美国的黄瓜也不能和中国的葫芦相比。  &lt;/p&gt;
&lt;p&gt;人过了而立，不知不觉就会有压力。看多了听多了他人的风云灿烂，总免不了暗自相比。尤其是90，00开始踏上舞台的时候，内心的压迫与紧张莫名的突出。只好自我安慰自我阿q的说，总有一天，你的同龄人中会出现主席。难道不是么？&lt;/p&gt;
&lt;p&gt;不知道内心的压抑，是怎么如入夜弥漫的黑暗般弥漫开来的。如果，黑暗中有座灯塔，那么，至少不会窒息在黑暗里。更重要的是，不会迷失。我想，我是不会沉沦在黑夜里的。因为，我的灯塔，就在那里。&lt;/p&gt;
&lt;p&gt;——最近所思所感，写出来晒晒，顿时心里舒服多了。&lt;/p&gt;</summary><category term=""></category></entry><entry><title>WWDC2014-419 Notes</title><link href="http://icocoa.tk/wwdc2014-419-notes.html" rel="alternate"></link><updated>2015-05-04T13:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-05-04:wwdc2014-419-notes.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: notes for 419&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;主要从原理上剖析，教你如何检查程序性能瓶颈所在。涉及到的系统框架如下：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="Framework" src="./imgs/20150504/Framework.png"/&gt; &lt;/p&gt;
&lt;h2&gt;Core animation pipeline&lt;/h2&gt;
&lt;p&gt;Core animation为iOS动画提供了很多便利，调用以及之后发生的事情如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="pipeline" src="./imgs/20150504/pipeLine.png"/&gt; &lt;/p&gt;
&lt;p&gt;在App中调用CA，CA会encode显示的view，交由CA内的一个渲染服务器。
渲染服务器收到指令后，会先decode view，在下一帧刷新的时候去绘制，然后交由GPU去渲染。
CPU渲染结束后，会在下一次帧刷新的时候，显示到屏幕。&lt;br/&gt;
由于除了App以外的部分都是iOS系统完成的，因此我们将注意力放在App的相关部分。 &lt;/p&gt;
&lt;h3&gt;Commit Transation&lt;/h3&gt;
&lt;p&gt;this part affect application developers the most， 包含4步：
&lt;img alt="commitTransaction4Phase" src="./imgs/20150504/commitTransaction4Phase.png"/&gt; &lt;/p&gt;
&lt;p&gt;4 phases&lt;/p&gt;
&lt;h4&gt;layout:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;layoutSubviews overrides are invoked&lt;/li&gt;
&lt;li&gt;View creation, addSubview:&lt;/li&gt;
&lt;li&gt;Populate content, database lookups &lt;/li&gt;
&lt;li&gt;Usually CPU bound or I/O bound
注：database指的是需要本地化的UI控件&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Display:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Draw contents via drawRect: if it is overridden &lt;/li&gt;
&lt;li&gt;String drawing&lt;/li&gt;
&lt;li&gt;Usually CPU or memory bound&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Prepare:&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Image decoding &lt;/li&gt;
&lt;li&gt;Image conversion&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;注：要使用推荐的png，如果是gpu不支持的格式就需要进行此部分消耗，也是cpu bounds&lt;/p&gt;
&lt;h4&gt;Commit&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;Package up layers and send to render server &lt;/li&gt;
&lt;li&gt;Recursive&lt;/li&gt;
&lt;li&gt;Expensive if layer tree is complex&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Rendering Conceptes&lt;/h3&gt;
&lt;p&gt;介绍渲染的基本概念，涉及gpu概念较多，不太明白。&lt;/p&gt;
&lt;h4&gt;Tile based rendering&lt;/h4&gt;
&lt;p&gt;页面划分成小格，每个小格细分成2个三角形，三角形再细分成更小的三角形...(离散化)，这样gpu就可以单独处理每一个tile。这样在hue系统下，可以决定哪些像素可见，并呈现何种形状(what pixel shade to run).
all GPU&lt;/p&gt;
&lt;h4&gt;Render passes&lt;/h4&gt;
&lt;ul&gt;
&lt;li&gt;command buffer: render server generate with OpenGL command and submitted to GPU  &lt;/li&gt;
&lt;li&gt;Tiler: real tiling work, output is written in Parameter Buffer   &lt;/li&gt;
&lt;li&gt;Parameter Buffer: all geometry is processed or buffer is full, and then will go to next phase  &lt;/li&gt;
&lt;li&gt;Render: output is written in render buffer&lt;/li&gt;
&lt;li&gt;render buffer&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;&lt;img alt="renderingPass" src="./imgs/20150504/renderingPass.png"/&gt; &lt;/p&gt;
&lt;h4&gt;Example masking&lt;/h4&gt;
&lt;p&gt;a masking example to show how render processing&lt;br/&gt;
&lt;img alt="masking" src="./imgs/20150504/masking.png"/&gt; &lt;/p&gt;
&lt;p&gt;这样基本上可以了解gpu的渲染过程。  &lt;/p&gt;
&lt;h2&gt;UIBlurEffect&lt;/h2&gt;
&lt;h3&gt;UIVisualEffectView with UIBlurEffect&lt;/h3&gt;
&lt;p&gt;UIBlurEffect style会影响渲染过程
渲染的过程：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="BlurRenderPass" src="./imgs/20150504/BlurRenderPass.png"/&gt; &lt;/p&gt;
&lt;p&gt;Performance considerations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIBlurEffect adds multiple offscreen passes depending on style  &lt;/li&gt;
&lt;li&gt;Only dirty regions are redrawn  &lt;/li&gt;
&lt;li&gt;Effect is very costly:
   --&amp;gt;UI can easily be GPU bound  &lt;br/&gt;
   --&amp;gt;Keep bounds of view as small as possible&lt;br/&gt;
   --&amp;gt;Make sure to budget for effect&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;UIVibrancyEffect&lt;/h2&gt;
&lt;p&gt;&lt;img alt="VibranceRenderPass" src="./imgs/20150504/VibranceRenderPass.png"/&gt;&lt;br/&gt;
注：先做blur effect &lt;br/&gt;
Performance considerations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;UIVibrancyEffect adds two offscreen passes   &lt;/li&gt;
&lt;li&gt;UIVibrancyEffect uses expensive compositing filter for content   &lt;/li&gt;
&lt;li&gt;Use UIVibrancyEffect on small regions   &lt;/li&gt;
&lt;li&gt;Only dirty regions are redrawn&lt;/li&gt;
&lt;li&gt;UIVibrancyEffect is very costly on &lt;strong&gt;all&lt;/strong&gt; devices&lt;br/&gt;
   --&amp;gt;UI can easily be GPU bound&lt;br/&gt;
   --&amp;gt;Keep bounds of view as small as possible&lt;br/&gt;
   --&amp;gt;Make sure to budget for effects&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Rasterization&lt;/h3&gt;
&lt;p&gt;Performance considerations:  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Use to composite to image once with GPU&lt;/li&gt;
&lt;li&gt;Enable with shouldRasterize property on CALayer&lt;/li&gt;
&lt;li&gt;Extra offscreen passes when updating content&lt;/li&gt;
&lt;li&gt;Do not overuse, cache size is limited to 2.5x of screen size&lt;/li&gt;
&lt;li&gt;Rasterized images evicted from cache if unused for more than 100ms&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;typical use case&lt;/p&gt;
&lt;h3&gt;Group Opacity&lt;/h3&gt;
&lt;p&gt;Performance considerations:&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Disable with allowsGroupOpacity property on CALayer&lt;/li&gt;
&lt;li&gt;Will introduce offscreen passes:
    If layer is not opaque (opacity != 1.0)
    And if layer has nontrivial content (child layers or background image)&lt;/li&gt;
&lt;li&gt;Sub view hierarchy needs to be composited before being blended Always turn it off if not needed
注： offscreen 非常消耗gpu&lt;/li&gt;
&lt;/ul&gt;
&lt;h1&gt;Tools&lt;/h1&gt;
&lt;p&gt;&lt;img alt="Tools" src="./imgs/20150504/Tools.png"/&gt;&lt;br/&gt;
检测性能工具&lt;/p&gt;
&lt;h2&gt;Performance Investigation Mindset&lt;/h2&gt;
&lt;p&gt;&lt;img alt="PerformanceInvestigationMindset" src="./imgs/20150504/PerformanceInvestigationMindset.png"/&gt;&lt;/p&gt;
&lt;p&gt;使用Instruments中core animation模版，查看当前的layer
注：补充debug option说明：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;strong&gt;Color Blended Layers&lt;/strong&gt;: Shows blended view layers. Multiple view layers that are drawn on top of each other with blending enabled are highlighted in red. Reducing the amount of red in your app when this option is selected can dramatically improve your apps performance. Blended view layers are often the cause for slow table scrolling.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Hits Green and Misses Red&lt;/strong&gt;: Marks views in green or red. A view that is able to use a cached rasterization is marked in green.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Copied Images&lt;/strong&gt;: Shows images that are copied by Core Animation in blue.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Immediately&lt;/strong&gt;: When selected, removes the 10 ms delay when performing color-flush operations.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Misaligned Images&lt;/strong&gt;: Places a magenta overlay over images where the source pixels are not aligned to the destination pixels.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color Offscreen-Rendered Yellow&lt;/strong&gt;: Places a yellow overlay over content that is rendered offscreen.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Color OpenGL Fast Path Blue&lt;/strong&gt;: Places a blue overlay over content that is detached from the compositor.&lt;/li&gt;
&lt;li&gt;&lt;strong&gt;Flash Updated Regions&lt;/strong&gt;: Colors regions on your iOS device in yellow when that region is updated by the graphics processor.&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;iPhone Simulator-&amp;gt;Debug，可以看到color xxx layer&lt;/p&gt;
&lt;h2&gt;Case Studies&lt;/h2&gt;
&lt;p&gt;几个常见问题&lt;/p&gt;
&lt;h3&gt;Fictitious Photo Applications&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;shadow creating ： cell的阴影创建&lt;/p&gt;
&lt;p&gt;//wrong
CALayer *imageViewLayer = cell.imageView.layer;
imageViewLayer.shadowColor = [UIColor blackColor].CGColor;
imageViewLayer.shadowOpacity = 1.0;
imageViewLayer.shadowRadius = 2.0;
imageViewLayer.shadowOffset = CGSizeMake(1.0, 1.0);
//right
imageViewLayer.shadowPath = CGPathCreateWithRect(imageRect, NULL);&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;round thumbnail: never use layer to create if there are many cells&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;solution:&lt;br/&gt;
&lt;img alt="roundThumbnail" src="./imgs/20150504/roundThumbnail.png"/&gt;&lt;/p&gt;
&lt;h2&gt;Summary&lt;/h2&gt;
&lt;p&gt;(copy from ppt)
Offscreen passes are expensive  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use Core Animation instrument to find them &lt;/li&gt;
&lt;li&gt;Know what you can do to avoid them&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Measure performance across different devices  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Use OpenGL ES Driver instrument for GPU time  &lt;/li&gt;
&lt;li&gt;Use Time Profiler instrument for CPU time&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Know your view hierarchy and any hidden costs&lt;/p&gt;
&lt;p&gt;1。 This is especially true for table cells and scrolling&lt;/p&gt;
&lt;p&gt;Tools&lt;/p&gt;
&lt;p&gt;&lt;img alt="toolMindset" src="./imgs/20150504/toolMindset.png"/&gt;&lt;/p&gt;
&lt;p&gt;注：要实现流畅度好的app，offscreen render越少越好。利用本篇的方法，可以迅速的定位症结，从而提升app性能。&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="UIScrollView"></category></entry><entry><title>WWDC2014-235 Notes</title><link href="http://icocoa.tk/wwdc2014-235-notes.html" rel="alternate"></link><updated>2015-04-20T22:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-04-20:wwdc2014-235-notes.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: notes for 223&lt;/p&gt;
&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;&lt;code&gt;UIScrollView&lt;/code&gt; 是比较重要的控件，每年的WWDC都会有专门的lecture来讲解scroll的新特性或者处理难点。WWDC2014也不例外，主题是 &lt;code&gt;advanced_scrollviews_and_touch_handling_techniques&lt;/code&gt;，主要包括：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;Hit testing&lt;/li&gt;
&lt;li&gt;gesture recoginizers&lt;/li&gt;
&lt;li&gt;touch delivery&lt;/li&gt;
&lt;li&gt;ransparent overlayers&lt;/li&gt;
&lt;li&gt;dragging while scrolling&lt;/li&gt;
&lt;li&gt;highlighting objects&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面会按着视频中的demo，一步一步讲解。&lt;/p&gt;
&lt;h3&gt;transparent overlayers&lt;/h3&gt;
&lt;p&gt;demo: 仿照搜索页面，添加下拉手势，手势触发出现一Scroll View， 该scroll view 部分遮挡原先的 view&lt;br/&gt;
存在的问题：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原先的view可以点击，添加了 scroll view后在scroll view没有出现的时候也不能点击 (因为demo中scroll view是一直添加在原先页面上， 通过contentOffset来移动内容，即 transparent overlayer)&lt;/li&gt;
&lt;li&gt;scroll view 禁止 useraction后，下拉手势无法响应&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;解决之道：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;scroll view 禁止 useraction&lt;/li&gt;
&lt;li&gt;“转交”scroll的pan手势：&lt;code&gt;[superView addGestureRecognizer:scrollView.panGestureRecognizer]&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;5.0开始，scroll有了一些手势属性，利用它们可以简化很多实现。  &lt;/p&gt;
&lt;p&gt;问题进化： 上述方法简单粗暴，因为scroll view上如果需要能接受点击操作呢(这种情况多见)？&lt;/p&gt;
&lt;h3&gt;histTest:withEvent:&lt;/h3&gt;
&lt;p&gt;该函数的作用就是检测 view或者哪个view的subview接收event，一般的处理流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;check point in our bounds&lt;/li&gt;
&lt;li&gt;return self&lt;/li&gt;
&lt;li&gt;check subview(in reverse order) whether to got the hit or not&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;需要注意的是在处理subview时的顺序，因为通常总是最上面的view最先接受event。&lt;br/&gt;
下图是demo中的view 架构：&lt;br/&gt;
&lt;img alt="hitTest" src="./imgs/20150421/hitTest.png"/&gt;&lt;br/&gt;
从下往上依次是： 父view(黄色，viewcontroller的view)， scrollview(透明色)，containerview(绿色)。&lt;br/&gt;
图上的处理流程是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;viewcontroller接收到event&lt;/li&gt;
&lt;li&gt;view检测subview，即scrollview&lt;/li&gt;
&lt;li&gt;scrollview检测subview，即containerview；如果点击位置在最左边的话，最后检测到的就是scrollview&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，在这个demo中，只有当view 是containerview时，才需要返回：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;hitTest:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;CGPoint&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;point&lt;/span&gt; &lt;span class="nf"&gt;withEvent:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIEvent&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;event&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;hitView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="nl"&gt;hitTest&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;point&lt;/span&gt; &lt;span class="nl"&gt;withEvent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;event&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;hitView&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;hitView&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在自定义的scroll view中重载 &lt;code&gt;histTest:withEvent:&lt;/code&gt;，当 &lt;code&gt;hitView&lt;/code&gt;是scroll本身的时候，我们不需要响应event，所以返回 nil，以便通知父view继续寻找下一个子view。&lt;br/&gt;
要注意的是，该方法会忽略透明色的view以及禁止useraction的view，因此这里需要开启scroll view的useraction。&lt;/p&gt;
&lt;p&gt;接下来实现 点view（dot view）可以接受long press gesture&lt;/p&gt;
&lt;h2&gt;LongPressGesture&lt;/h2&gt;
&lt;p&gt;添加LongPressGesture 是为了让 点view 可以随手势移动。直接给 点view添加guesture会有bug，因为默认的gesture在被确认的时候会cancel接下来的手势响应，因此需要设置手势的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;longPress.cancelsTouchesInView = NO;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;补充下该属性的说明： &lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;default is YES. causes touchesCancelled:withEvent: to be sent to the view for all touches recognized as part of this gesture immediately before the action method is called  &lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;LongPress响应的处理，直接上图了：&lt;/p&gt;
&lt;p&gt;&lt;img alt="longPressGesture" src="./imgs/20150421/longPressGesture.png"/&gt; &lt;br/&gt;
&lt;img alt="longPressGestureStart" src="./imgs/20150421/longPressGestureStart.png"/&gt; &lt;br/&gt;
&lt;img alt="longPressGestureEnd" src="./imgs/20150421/longPressGestureEnd.png"/&gt; &lt;/p&gt;
&lt;p&gt;说明：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;convertPoint:fromView: 适用于坐标在不同view下的切换，这里dot view有可能是从scroll view上的container中转移到 父view&lt;/li&gt;
&lt;li&gt;手势点击的时候，可能在 点view的边缘处，因此在grab中的animation中通过动画将点击位置转移到中心&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来： 点击多个 点view同时支持下拉scroll view
当前不支持点击 点view同时支持下拉是因为 点view的longPress和scroll view的pan相冲突了。解决方法很简单，就是实现LongPress的一个delegate，：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;- (BOOL)gestureRecognizer:(UIGestureRecognizer *)gestureRecognizer shouldRecognizeSimultaneouslyWithGestureRecognizer:(UIGestureRecognizer *)otherGestureRecognizer
{
    return YES;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时的问题是：当longPress 点view，并向下移动时，会触发scroll的下拉，原因在于上述的delegate方法实现的过去粗暴。&lt;/p&gt;
&lt;h3&gt;Dragging while scrolling&lt;/h3&gt;
&lt;p&gt;解决上面问题的方法就是在longPress开始的时候：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;scroll.panGestureRecognizer.enabled = NO;
scroll.panGestureRecognizer.enabled = YES;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题发生的原因在于LongPress和Pan是同一个接受者，因此我们在LongPress开始的时候先禁掉Pan的响应，这样当前的手势只会被LongPress处理。紧接着，我们要恢复pan的识别，以避免错过下一次正常手势响应。 &lt;/p&gt;
&lt;p&gt;新问题：当下拉的手势经过 点view时，点view会高亮一下。&lt;br/&gt;
原因在于pan手势经过点view的时候会触发touchBegan:，当系统识别出来是pan向点view发出cancelTouch:的时候已晚矣。&lt;/p&gt;
&lt;h3&gt;highlighting objects&lt;/h3&gt;
&lt;p&gt;先看&lt;code&gt;UITableView&lt;/code&gt;怎么解决类似问题，当手指点中cell快速滑动时，cell并不会有选中的状态；而当手指点击cell不滑动的时候，cell会呈选中状态。之所以会这样，是因为UIscrollView有默认值为YES的delaysContentTouches的属性。为了更好的理解这种特性，我们需要知道背后都有些什么，发生了些什么。&lt;br/&gt;
首先UIscrollView除了 panGestureRecognizer 和 pinchGestureRecognizer， 还有 touchDelayGestureRecognizer，touchDelay的作用就在于：屏蔽event，使其他任何view或gesture都无法响应event。&lt;br/&gt;
以点击uitableview cell然后滑动为例，页面上cell会呈选中状态，然后整个tableview滑动，同时选中的cell状态恢复。这其中发生的事情包括：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="longPress" src="./imgs/20150421/longPress.png"/&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;手指点击cell，delay gesture启动，内部释放一个timer&lt;/li&gt;
&lt;li&gt;手指不动保持一定时间后，timer到点了，delay gesture失效，这时view和gesture可以正常接收event，因此cell接受到touchBegan，开始高亮选中&lt;/li&gt;
&lt;li&gt;手指滑动时，pan手势接管，cell接受cancel信息，恢复原状态&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;如果直接滚动cell：&lt;/p&gt;
&lt;p&gt;&lt;img alt="touch" src="./imgs/20150421/touch.png"/&gt; &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;第一步同上&lt;/li&gt;
&lt;li&gt;手指滑动，pan手势接收，这时会重置delay gesture；因为pan先接收了，view不会受到touch事件&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;因此，解决点view高亮的方法也有了思路：给view添加一个类似scroll view的delay gesture。结合上面2图，我们大致可以了解delay gesture的流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;设置 delaysContentTouches 为YES&lt;/li&gt;
&lt;li&gt;在touchesBegan中启动timer，在touchesEnded和touchesCancelled中置失败&lt;/li&gt;
&lt;li&gt;timer到点后置状态失败&lt;/li&gt;
&lt;li&gt;实现一个重置timer的方法&lt;/li&gt;
&lt;li&gt;初始化的时候，注意target为nil&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;新问题：点击小物体&lt;/p&gt;
&lt;h3&gt;Touching Small Objects&lt;/h3&gt;
&lt;p&gt;还是使用&lt;code&gt;hitTest:withEvent:&lt;/code&gt;，重载 &lt;code&gt;- (BOOL)pointInside:(CGPoint)point withEvent:(UIEvent *)event&lt;/code&gt;(因为&lt;code&gt;hitTest:withEvent:&lt;/code&gt;默认调用 &lt;code&gt;pointInside:withEvent:&lt;/code&gt;)，如图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="smallObject" src="./imgs/20150421/smallObject.png"/&gt;&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;需要牢记的：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;touch event中：&lt;code&gt;hitTest:withEvent:&lt;/code&gt;是最底层的，控制响应对象&lt;/li&gt;
&lt;li&gt;&lt;code&gt;touchesBegan:&lt;/code&gt;和 gesture 是较高级别的对touch event的响应&lt;/li&gt;
&lt;li&gt;UIScrollView的默认 gesture&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;最近看过的WWDC视频，过段时间回顾，发现还是受益良多。由此想来还是要把之前看的几期的笔记整理出来，这样方能加深印象。&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="UIScrollView"></category></entry><entry><title>Note: More Swift and Foundation Frameworks</title><link href="http://icocoa.tk/note-more-swift-and-foundation-frameworks.html" rel="alternate"></link><updated>2015-04-13T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-04-13:note-more-swift-and-foundation-frameworks.html</id><summary type="html">&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;Note of More Swift and Foundation Frameworks, not detail described.&lt;br/&gt;
Lesson4的要点记录，有些没有展开，侧重于“点”。看完后觉得需要注意的地方：基本数据类型如Optional/Array/Dictionary等的特点；class与struct的异同；class中的属性和方法；常见数据类型的常用方法(Array/String有很多新增的方法，功能比对应的ObjC强大)&lt;/p&gt;
&lt;h2&gt;Optional&lt;/h2&gt;
&lt;p _="
" case="case" none_="None
" some_t_="Some(T)
"&gt;an optional is an enum
enum Optional&lt;t&gt;&lt;/t&gt;&lt;/p&gt;
&lt;p&gt;! 相当于一个switch
简单的说，就是语法糖&lt;/p&gt;
&lt;h2&gt;Array&lt;/h2&gt;
&lt;p&gt;declare
immutable&lt;br/&gt;
enumerating&lt;/p&gt;
&lt;h2&gt;Dictionary&lt;/h2&gt;
&lt;p&gt;like above
enumerating using tuple&lt;/p&gt;
&lt;h2&gt;Range&lt;/h2&gt;
&lt;p&gt;it's new
Array's range :&lt;code&gt;Range&amp;lt;Int&amp;gt;&lt;/code&gt;&lt;br/&gt;
String's : &lt;code&gt;Range&amp;lt;String.Index&amp;gt;&lt;/code&gt;&lt;br/&gt;
... / ..&amp;lt; (close/open)
enumerating 
for i in [start...end]{}&lt;/p&gt;
&lt;h2&gt;Other class&lt;/h2&gt;
&lt;h3&gt;NSObject&lt;/h3&gt;
&lt;p&gt;advanced features require subclass from NSObject&lt;/p&gt;
&lt;h3&gt;NSNumber&lt;/h3&gt;
&lt;p&gt;inherited from NSObject
--bridged--&lt;/p&gt;
&lt;h3&gt;NSDate&lt;/h3&gt;
&lt;h3&gt;NSData&lt;/h3&gt;
&lt;h2&gt;Data structure in swift&lt;/h2&gt;
&lt;p&gt;这个重要
class/struct/enum : 3 fundamental building blocks of data structure&lt;br/&gt;
Similariries:&lt;br/&gt;
1. declaration
2. oproperty and functions
3. initializer
Differences:&lt;br/&gt;
1. Inheritance
2. Introspection and casting
3. value type vs. Reference type&lt;/p&gt;
&lt;h3&gt;Value VS. References&lt;/h3&gt;
&lt;h4&gt;Value&lt;/h4&gt;
&lt;p&gt;copied &amp;amp;&amp;amp; immutable &amp;amp;&amp;amp; mutating&lt;/p&gt;
&lt;h4&gt;Reference&lt;/h4&gt;
&lt;p&gt;heap &amp;amp;&amp;amp; reference counted&lt;/p&gt;
&lt;h4&gt;Choose&lt;/h4&gt;
&lt;h3&gt;Methods&lt;/h3&gt;
&lt;p&gt;override &amp;amp;&amp;amp;final(can be class)
types and instances can have methods/properties:  (like class and instance methods)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;static func abc(d: Double) -&amp;gt; Double
class func abc(d: Double) -&amp;gt; Double
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Parameters Names
&lt;em&gt; internal: local var used in method
&lt;/em&gt; external: caller used to call method&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;func foo (external internal :Int)
{
    let local = internal
}
fun bar ()
{
    let result = foo(external :123)
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;But we seldomly write like above.&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;_ : means not use an external name, default&lt;/p&gt;
&lt;p _="=" foo_123_="foo(123)
" let="let" result="result"&gt;func foo (&lt;em&gt; internal :Int)//&lt;/em&gt; can be omitted
{
    let local = internal
}
fun bar ()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;&lt;code&gt;#&lt;/code&gt;: force the 1st parameter's external name to be the internal one&lt;/p&gt;
&lt;p :123_=":123)
" _="=" foo_internal="foo(internal" let="let" result="result"&gt;func foo (#internal :Int)
{
    let local = internal
}
fun bar ()&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;not 1st parameter: external is the internal by default; but can be changed&lt;/p&gt;
&lt;p 5.5_="5.5)
" _="=" foo_123_="foo(123," let="let" result="result"&gt;//1
func foo (first :Int, second: Doube)
{
    let local = internal
}
fun bar ()
{
    let result = foo(123, second: 5.5)
}
//2
func foo (first :Int, external2nd second: Doube)
{
    let local = internal
}
fun bar ()
{
    let result = foo(123, external2nd: 5.5)
}
//3 also can be ommited, not recommended to to do
func foo (first :Int, _ second: Doube)
{
    let local = internal
}
fun bar ()&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;使用默认的即可，其他的需要知道这种语法，遇到的时候能认识就行&lt;/p&gt;
&lt;h2&gt;Property&lt;/h2&gt;
&lt;h3&gt;observer&lt;/h3&gt;
&lt;p&gt;类似KVO&lt;br/&gt;
willset didset&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var someProperty: Int = 42 {
    willSet { newValue}
    didSet { oldValue}
}
override var inheriteProperty
{
    willSet { newValue }
    didSet { oldValue}
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;Lazy Initialization&lt;/h3&gt;
&lt;p&gt;like dynamic, when in use to access, the var is initialized&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;lazy var brain = ...
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;can't use &lt;code&gt;let&lt;/code&gt; together&lt;br/&gt;
may have dependence problems (dependency conundrums)&lt;/p&gt;
&lt;h3&gt;Initialization&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;when is init method needed: usually not &lt;/li&gt;
&lt;li&gt;&lt;code&gt;free&lt;/code&gt; init : base class have defaults/struct automaticalled created &lt;/li&gt;
&lt;li&gt;what can to do in init: set any property's value even those have defaults; constant value;self.init();super.init()&lt;/li&gt;
&lt;li&gt;what required in init:   all properties must have values;   convenience and designated(not convience); desigated can only call a init of its superclass;   must init own property before call super.init;   must call super.init before assign the inherited value;  convenience can only call a designated init in its own and may call desiganated init directly; must call init before set property;
all in all: init is requred before any setting&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;Inhering init&lt;/h4&gt;
&lt;h4&gt;Required init&lt;/h4&gt;
&lt;h4&gt;Failable init&lt;/h4&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;init?()
{
    // may return nil
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;Createing Objects&lt;/h4&gt;
&lt;h2&gt;Any Object&lt;/h2&gt;
&lt;p&gt;Special type: a protocol&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var viewController : AnyObject
var items :[AnyObject]
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;like &lt;code&gt;id&lt;/code&gt;, Not common use in swift and convert it before using&lt;br/&gt;
&lt;strong&gt;Casting&lt;/strong&gt;: as/ as ?&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;//1
if let viewController = someController as? CalViewController {}// as? returns an optional
//2
if someController is CalViewController {...}
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Functions&lt;/h2&gt;
&lt;h3&gt;some Array&lt;t&gt; Methods&lt;/t&gt;&lt;/h3&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+= [T]
first -&amp;gt; T
last -&amp;gt; T
append
slice
insert
remove Index/Range
sort
filter
map 
reduce
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;String&lt;/h2&gt;
&lt;h3&gt;String.Index&lt;/h3&gt;
&lt;p&gt;is &lt;strong&gt;NOT&lt;/strong&gt; Int&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;//1
var s = "hello"
let index = advance(s.startIndex, 2)// a String.Index to 3rd glyph, "l"
s.splice("abc",index)// s= "heabcllo"
//2
let num = "56.25"
if let decimalRange = num.rangeOfString(".")
{
    let wholeNumberPart = num[num.startIndex..&amp;lt;decimalRange.startindex]
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Other methods
Notice : NO &lt;code&gt;toDouble&lt;/code&gt;&lt;/p&gt;
&lt;h2&gt;Type Conversion&lt;/h2&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;//1
let d: Double = 37.5
let f: Float = 37.5
let x = Int(d)
let cd = Double(x)
//2: notice here
let a = Array("abc")// a = ["a","b","c"]
let s = String("a","b","c"]) //s = "abc"
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;Assertions&lt;/h2&gt;
&lt;h3&gt;Debugging Aid&lt;/h3&gt;
&lt;h2&gt;Other Functions&lt;/h2&gt;
&lt;h3&gt;Bridging&lt;/h3&gt;</summary><category term="swift"></category><category term="iOS"></category></entry><entry><title>swift学习之struct ——前三课总结</title><link href="http://icocoa.tk/swiftxue-xi-zhi-struct-qian-san-ke-zong-jie.html" rel="alternate"></link><updated>2015-04-05T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-04-05:swiftxue-xi-zhi-struct-qian-san-ke-zong-jie.html</id><summary type="html">&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;During the course, a lot of swift details are touched from Lesson 1 to 3 and the classical MVC is practised in Lesson 3.&lt;br/&gt;
本篇侧重swift的强类型特性以及struct的特点。&lt;/p&gt;
&lt;h2&gt;Strong type language&lt;/h2&gt;
&lt;p&gt;Swift is smart enough to know the type and you can ommit the type in decalaring, function parameters and son on. For example, instance declaring:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var userIsInTheMiddleOfTypingANumber: Bool = false
var userIsInTheMiddleOfTypingANumber = false
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Because in swift class, all the instances need an intialization and swift can infer the instance type from its value. &lt;br/&gt;
Below is the example for &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Dictionary&lt;/code&gt; declaring:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;testStack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt; &lt;span class="c1"&gt;// perferred style&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;testStack&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Array&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;

&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;testDic&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nl"&gt;String&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;Int&lt;/span&gt;&lt;span class="p"&gt;]()&lt;/span&gt; &lt;span class="c1"&gt;// perferred style&lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;testDic&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;Dictionary&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;String&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;Int&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;class &amp;amp;&amp;amp; struct&lt;/h2&gt;
&lt;p&gt;In swift, many data structures are &lt;code&gt;struct&lt;/code&gt;, like &lt;code&gt;Int&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Dictionary&lt;/code&gt;, etc. It's much different from that in &lt;code&gt;Obj-C&lt;/code&gt; since &lt;code&gt;Array&lt;/code&gt; and &lt;code&gt;Dictionary&lt;/code&gt; and so on are &lt;code&gt;class&lt;/code&gt;. &lt;br/&gt;
However, in swift, &lt;code&gt;struct&lt;/code&gt; is much like &lt;code&gt;class&lt;/code&gt;, and  it can have &lt;code&gt;func&lt;/code&gt; and &lt;code&gt;computed property&lt;/code&gt; just like &lt;code&gt;class&lt;/code&gt; does. The differences are : &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;only &lt;code&gt;class&lt;/code&gt; can have inherition&lt;/li&gt;
&lt;li&gt;&lt;code&gt;struct&lt;/code&gt; is passed by value as parameters while &lt;code&gt;class&lt;/code&gt; is passed by reference&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;Here we talk a little more about &lt;code&gt;struct&lt;/code&gt; passed by value. &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;func testFunc(operand: [Int])
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In &lt;code&gt;testFunc&lt;/code&gt;, there will be a copy of &lt;code&gt;operand&lt;/code&gt; and this copy is immutable. Why? The reason is that ther is always a hidden &lt;code&gt;let&lt;/code&gt; before every func's parameter. As a result, if we want to do something on the Array, we need make it mutable, like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;func testFunc(operand: [Int])
{
    var localOperand = operand //1
    let op = localOperand.removeLast() //2
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In Line 1, there is a local copy of &lt;code&gt;operand&lt;/code&gt; and  &lt;code&gt;localOperand&lt;/code&gt; is mutable. Although there is a copy, swift may not do the really copy of &lt;code&gt;operand&lt;/code&gt; in implementation and swift may still make a reference of that array. In this way, it can be much effency. &lt;br/&gt;
In Line 2, we make changes on &lt;code&gt;localOperand&lt;/code&gt;, and at this time swift &lt;strong&gt;still&lt;/strong&gt; not do a copy. It can only remember the change and reuse the unchanged one. It is really amasing when I first learn it and it indicates swift is a smart enough language.  &lt;/p&gt;
&lt;p&gt;All in all, swift is really a smart language and is valuable to learn!&lt;/p&gt;</summary><category term="swift"></category><category term="iOS"></category></entry><entry><title>Xcode6中批量添加矢量图</title><link href="http://icocoa.tk/xcode6zhong-pi-liang-tian-jia-shi-liang-tu.html" rel="alternate"></link><updated>2015-03-23T11:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-03-23:xcode6zhong-pi-liang-tian-jia-shi-liang-tu.html</id><summary type="html">&lt;h3&gt;1. Xcode6添加矢量图的问题&lt;/h3&gt;
&lt;p&gt;Xcode6中支持添加矢量图，然后在编译期Xcode6自动生成@2x和@3x的图片，可是添加的过程有些繁琐。&lt;br/&gt;
首先，直接把矢量图拖到 &lt;code&gt;xcassets&lt;/code&gt;文件中是不行的，添加的步骤：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在 &lt;code&gt;xcassets&lt;/code&gt; 中 &lt;code&gt;New Image Set&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;选中生成的asset，在右侧的 &lt;code&gt;Image Set&lt;/code&gt;中将属性修改为 &lt;code&gt;Vectors&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;将矢量图拖进来，再修改asset文件名称&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见，需要批量添加矢量图的时候，会非常繁琐。&lt;/p&gt;
&lt;h3&gt;2. 解决之道&lt;/h3&gt;
&lt;p&gt;每一个图片都对应一个带后缀 &lt;code&gt;imageset&lt;/code&gt;的文件夹，内有 &lt;code&gt;Contents.json&lt;/code&gt;文件，对于普通的png而言，它的内容一般是：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{
  "images" : [
    {
      "idiom" : "universal",
      "scale" : "1x",
      "filename" : "ButtonFillBlue.png"
    },
    {
      "idiom" : "universal",
      "scale" : "2x"
    },
    {
      "idiom" : "universal",
      "scale" : "3x"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而如果是以矢量图的方式添加的，json文件内容变为：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;{
  "images" : [
    {
      "idiom" : "universal",
      "filename" : "ButtonFillBlue.pdf"
    }
  ],
  "info" : {
    "version" : 1,
    "author" : "xcode"
  }
}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;两相对比，很容易看出区别，那么接下来使用脚本工具进行处理即可。&lt;/p&gt;
&lt;h3&gt;3. 处理脚本&lt;/h3&gt;
&lt;p&gt;对shell脚本知之皮毛的我低估了写的难度，在此记录下脚本的实现过程和遇到的问题。先上脚本内容：&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;
&lt;span class="nv"&gt;xcassetPath&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="nv"&gt;$1&lt;/span&gt;
&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$xcassetPath&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; imageAsset in &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$xcassetPath&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/*&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
    &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$imageAsset&lt;/span&gt;
    &lt;span class="k"&gt;for&lt;/span&gt; file in &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/*.json&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;do&lt;/span&gt;
        cat &lt;span class="nv"&gt;$file&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; tr -d &lt;span class="s1"&gt;'\n'&lt;/span&gt; &amp;gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp
        &lt;span class="c"&gt;# sed 'N;N;s/\n//g'  $file &amp;gt; "$imageAsset"/temp&lt;/span&gt;
        sed &lt;span class="s1"&gt;'s/ //g'&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp &amp;gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp1
        sed &lt;span class="s1"&gt;'s/,{.*}]/]/g'&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp1 &amp;gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp2
        sed &lt;span class="s1"&gt;'s/,\"scale\":\"1x\",/,/g'&lt;/span&gt; &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp2 &amp;gt; &lt;span class="nv"&gt;$file&lt;/span&gt;

        rm -f &lt;span class="s2"&gt;"&lt;/span&gt;&lt;span class="nv"&gt;$imageAsset&lt;/span&gt;&lt;span class="s2"&gt;"&lt;/span&gt;/temp*
    &lt;span class="k"&gt;done&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;该脚本需要指定 &lt;code&gt;xcassets&lt;/code&gt; 对应的路径，然后遍历该文件夹下的内容，依次找到 json 文件，进行字符处理。遇到的难点:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;去除换行符：sed通常逐行处理，也可以合并多行后处理，但没有成功。此处使用tr&lt;/li&gt;
&lt;li&gt;替换空格&lt;/li&gt;
&lt;li&gt;替换含有2x，3x的dictionary&lt;/li&gt;
&lt;li&gt;替换1x dictionary中的 &lt;code&gt;scale&lt;/code&gt; 字段&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;用到了很多临时文件，我也很无奈，虽然有更好的实现方式，可是不会啊～先凑合着用吧。&lt;br/&gt;
最后说一下使用方法：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;将矢量文件拖入Xcode6的&lt;code&gt;xcassets&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;运行脚本并将&lt;code&gt;xcassets&lt;/code&gt;的路径作为输入参数&lt;/li&gt;
&lt;/ol&gt;</summary><category term="iOS"></category></entry><entry><title>RBStoryboardLink 的简介</title><link href="http://icocoa.tk/rbstoryboardlink-de-jian-jie.html" rel="alternate"></link><updated>2015-03-13T17:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-03-13:rbstoryboardlink-de-jian-jie.html</id><summary type="html">&lt;h3&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;今天简单介绍一下&lt;a href="https://github.com/rob-brown/RBStoryboardLink"&gt;RBStoryboardLink&lt;/a&gt;，这是一个方便在某个storyboard(下面我要用SB代之)中调用其他 SB 中的viewcontroller的项目  &lt;/p&gt;
&lt;h3&gt;2. RBStoryboardLink&lt;/h3&gt;
&lt;h4&gt;2.1 为什么要使用&lt;/h4&gt;
&lt;p&gt;当Apple越来越重视的SB时候，设计师们也愈发喜欢 SB 。如果你有一位喜欢使用SB的设计师，那么恭喜你，你可以少做很多开发准备了。然而，从项目的组织结构来考虑，不管是设计师或是开发人员，都不会使用单一SB(项目简单的除外)。我们往往会使用模块化的方式来分解，比如tab结构的app，每一个tab就可以视为一个模块。而sb文件中页面的跳转不能离开当前的sb文件，这时涉及到模块间页面跳转的情形，在sb中就无能为力了。通常的做法，就需要在代码中实现：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;//生成一个sb对象
//获取此sb对象中的某一个scene
//push/present该scene
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而 RBStoryboardLink 就可以让你不依赖于代码，直接在sb文件中进行简单的“连接”即可。&lt;br/&gt;
详细的使用方法见&lt;a href="https://github.com/rob-brown/RBStoryboardLink#how-to-use"&gt;How to Use&lt;/a&gt;(这里不做搬运苦力活了)。&lt;/p&gt;
&lt;h4&gt;2.2 内部实现&lt;/h4&gt;
&lt;p&gt;内部的实现说起来不复杂，但是有很多细节需要注意。&lt;br/&gt;
使用方法中，需要在当前的sb文件中新建一个scene A，然后把该scene连接到其他sb文件中的scene B中。这在代码中就依赖于: 首先通过在SB中给 A 添加的&lt;code&gt;User Defined Runtime Attributes&lt;/code&gt;中的属性将其他的SB文件以及相应的scene的identifier(如果有)获取到，然后生成sb对象和scene；接下来就通过&lt;code&gt;addChildViewController&lt;/code&gt;，把B作为子类加到A上去，这样的话A就相当于母板的功能。此外，还需要把A的一些属性转移到B，比如是&lt;code&gt;UINavigationItem&lt;/code&gt;和&lt;code&gt;UIBarButtonItem&lt;/code&gt; 的属性。这样，B就获得了pop到A的前一页面的能力。更多需要设置的细节，请阅读源码，相信会有不少的收获。&lt;/p&gt;
&lt;h3&gt;3 其余收获&lt;/h3&gt;
&lt;p&gt;主要指的是 &lt;code&gt;User Defined Runtime Attributes&lt;/code&gt;，这个在cocoa开发的时候经常会用到，在iOS上也有不少geek的用法。这里不做讨论，只是做个记录，提醒自己不要忘记了。大家google下，就能发现很多。  &lt;/p&gt;</summary><category term="storyboard"></category></entry><entry><title>Appium的使用</title><link href="http://icocoa.tk/appiumde-shi-yong.html" rel="alternate"></link><updated>2015-03-08T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-03-08:appiumde-shi-yong.html</id><summary type="html">&lt;h3&gt;1. Intro&lt;/h3&gt;
&lt;p&gt;本周业余时间，主要在研究如何使用Appium，内容包括Appium是什么，架构，安装，使用以及测试用例的写法。  &lt;/p&gt;
&lt;h3&gt;2. Appium简介&lt;/h3&gt;
&lt;p&gt;Appium的&lt;a href="http://appium.io/introduction.html"&gt;Introduction&lt;/a&gt;页面介绍了Appium，采用经典的CS架构，利用 WebDriver 封装调用各平台的测试框架(现在支持iOS，Android，FirefoxOS)，因此在使用的时候需要先启动服务器再在客户端进行测试。&lt;br/&gt;
对技术细节及背后的实现感兴趣的，可以深入看源码。现在，我们的目标是运行Appium并成功进行测试。&lt;/p&gt;
&lt;h3&gt;3. Tutorial&lt;/h3&gt;
&lt;p&gt;为了上手，可以看&lt;a href="http://appium.io/slate/en/master/#README.md"&gt;GetStarted&lt;/a&gt;或者&lt;a href="http://appium.io/slate/en/tutorial/ios.html"&gt;iOS Tutorial&lt;/a&gt;。因为我只侧重iOS，因此下面把tutorial中涉及到的内容摘录出来。  &lt;/p&gt;
&lt;h4&gt;3.1 Environment(环境配置)&lt;/h4&gt;
&lt;p&gt;Install the latest stable release of Ruby.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;\curl -sSL https://get.rvm.io | bash -s stable

source /Users/xxxx/.rvm/scripts/rvm
rvm install ruby
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Make sure RVM is using the correct Ruby by default&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rvm list
rvm install ruby-2.1.1
rvm --default use 2.1.1
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;If you have an old ruby/rvm, you can upgrade with&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;rvm get head
rvm autolibs homebrew
rvm install ruby
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Update RubyGems and Bundler.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gem update --system
gem install --no-rdoc --no-ri bundler
gem update
gem cleanup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install appium_console gem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gem uninstall -aIx appium_lib
gem uninstall -aIx appium_console
gem install --no-rdoc --no-ri appium_console
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install flaky gem.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;gem uninstall -aIx flaky
gem install --no-rdoc --no-ri flaky
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install brew(if installed, ignore)
    ruby -e "$(curl -fsSL https://raw.github.com/Homebrew/homebrew/go/install)"&lt;/p&gt;
&lt;p&gt;Install nodejs using brew.(if installed, ignore)&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;brew update
brew upgrade node
brew install node
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此处&lt;strong&gt;注意&lt;/strong&gt;：如果以前已经安装过node的，可能使用了&lt;code&gt;sudo&lt;/code&gt;权限，这里会对Appium的启用有影响，需要安装Appium的方式安装node。
check versions:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;node --version
npm --version
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Install grunt.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;npm install -g grunt grunt-cli
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Run the version command from the appium folder. If you’re not in that folder, the grunt version will not display.&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grunt --version
grunt-cli v0.1.13
grunt v0.4.2
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;install ant &amp;amp;&amp;amp; maven&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;brew install ant

brew install maven
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 Appium&amp;amp;&amp;amp;Authorize (安装与授权)&lt;/h4&gt;
&lt;p&gt;此处操作是在源码中进行的
get appium&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git clone git://github.com/appium/appium.git
cd appium; ./reset.sh --ios//只做iOS测试
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Authorize:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;sudo node bin/authorize-ios.js
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Start &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;node .
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;除了命令行启动的方式，Appium也提供了App启动方式，官网下载后直接安装。打开后，可以根据点击需要的测试平台填入相应App的信息，启动即可。Appium的app还内置了inspector，可以连接app的时候查看各个页面元素，也提供了多种语言获取元素，方便测试用例的撰写。&lt;/p&gt;
&lt;h4&gt;3.3 Install client library&lt;/h4&gt;
&lt;p&gt;https://github.com/appium/sample-code/tree/master/sample-code/examples/python
因为用python写用例，需要安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;pip install Appium-Python-Client
pip install pytest
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;py.test ios_simple.py
py.test -n2 --boxed ios_simple.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中的python文件需要遵循一定的写法。&lt;br/&gt;
使用其他语言的可以在&lt;a href="https://github.com/appium/sample-code/tree/master/sample-code/examples"&gt;这里&lt;/a&gt;查看，目前支持的语言还是挺多的。&lt;/p&gt;
&lt;h3&gt;4. sample(demo实战)&lt;/h3&gt;
&lt;p&gt;进入源码的&lt;code&gt;sample-code&lt;/code&gt;文件夹，其中&lt;code&gt;apps&lt;/code&gt;中是待测程序，&lt;code&gt;examples&lt;/code&gt;中是不同语言版本的测试用例。其中&lt;code&gt;/example/python/ios_simple.py&lt;/code&gt;是征对&lt;code&gt;/apps/TestApp&lt;/code&gt;的测试用例，我们如下进行测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;//启动Appium
//启动方式1
appium
//启动方式2
cd /Appium/source/path
node .
//运行测试用例，需要新开terminal
py.test ios_simple.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;稍等一会，会启动iOS模拟器，然后运行用例，测试结果会在terminal中显示。&lt;br/&gt;
在运行过程中，该用例可能需要修改32和49行的部分代码：将&lt;code&gt;elements()&lt;/code&gt;替换成&lt;code&gt;.elements()&lt;/code&gt;。&lt;br/&gt;
从&lt;code&gt;ios_simple.py&lt;/code&gt;中大致可以明白测试用例的写法，比如&lt;code&gt;setUp&lt;/code&gt;负责建立测试环境如：app路径，测试平台等，&lt;code&gt;tearDown&lt;/code&gt;是告诉appium退出。&lt;br/&gt;
另外，详细的测试语法还要继续学习。&lt;/p&gt;
&lt;h4&gt;4.1 真机测试&lt;/h4&gt;
&lt;p&gt;首先安装：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;brew install --HEAD ideviceinstaller
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;详见&lt;a href="https://discuss.appium.io/t/ideviceinstaller-could-not-initialize-ideviceinstaller/3000/2"&gt;这里&lt;/a&gt;。&lt;/p&gt;
&lt;p&gt;然后就可以启动appium：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;appium -U "udid" --app "bundle-id"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;启动成功后，新开terminal，启动测试脚本：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;py.test ios_test.py
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，测试脚本中&lt;code&gt;desired_capabilities&lt;/code&gt;需要更新：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;desired_capabilities={
            'app': app,
            'platformName': 'iOS',
            'platformVersion': '8.1',
            'deviceName': 'iPhone 6',
            'udid':'df41e04b1ea7dbfa0a7df54d49fc9f8c228ab20b',
            'bundleid':'io.appium.TestApp',
        }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;官方也有&lt;a href="http://appium.io/slate/en/master/?python#deploying-an-ios-app-to-a-real-device"&gt;Deploying an iOS app to a real device&lt;/a&gt;的教程，步骤包括生产签过名的app，使用&lt;code&gt;fruitstrap&lt;/code&gt;部署app到真机，然后再启动appium。&lt;br/&gt;
使用py.test客户端启动测试的过程中，就包含了部署的部分，当然待测试的app需要先安装到真机。  &lt;/p&gt;
&lt;h3&gt;5 展望&lt;/h3&gt;
&lt;p&gt;这个自动化测试的平台搭建成功后，还是很兴奋的。下一步就是学习case怎么写，虽然一开始会感觉负担比较重，但是会节省以后的空间。
另外，还发现一个论坛&lt;a href="http://testerhome.com/"&gt;testerhome&lt;/a&gt;--测试员的家，看英文累的可以参考这里。&lt;/p&gt;</summary><category term="测试"></category><category term="appium"></category></entry><entry><title>Optional of swift</title><link href="http://icocoa.tk/optional-of-swift.html" rel="alternate"></link><updated>2015-02-28T17:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-02-28:optional-of-swift.html</id><summary type="html">&lt;h3&gt;Intro&lt;/h3&gt;
&lt;p&gt;This is a category of study&amp;amp;&amp;amp;notes of swift, program and so on during the study of [Developing iOS8 Apps with Swift] on the &lt;strong&gt;iTunes U&lt;/strong&gt;.&lt;br/&gt;
此系列为学习stanford课程：Developing iOS8 Apps with Swift过程中，对语言，程序设计，编程能力等部分的学习和记录。&lt;/p&gt;
&lt;h3&gt;Optional&lt;/h3&gt;
&lt;p&gt;The simple way to declare a optional value:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var testString: String?
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It means: &lt;code&gt;testString&lt;/code&gt; is an &lt;strong&gt;optional value&lt;/strong&gt; and if &lt;code&gt;testString&lt;/code&gt; has a value, it must be a string; if not, it is &lt;code&gt;nil&lt;/code&gt;. Notice:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;only optional value can be nil&lt;/li&gt;
&lt;li&gt;optional can be available for any type, such as class, scalar&lt;/li&gt;
&lt;li&gt;using &lt;code&gt;!&lt;/code&gt; to unwrapped the optional value to get/set&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;From the above, for the normal &lt;code&gt;var&lt;/code&gt;, we don't need to check like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var testString: String = "demo"
if testString {

}
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;It will have an error. &lt;br/&gt;
nil is different from that in ObjC.  &lt;/p&gt;
&lt;p&gt;During the course, there is another way to declare optional:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;@IBOutlet weak var label: UILabel!
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;Paul&lt;/code&gt; says it is called &lt;code&gt;implicit optional value&lt;/code&gt;. The difference of optional between using ? and ! only lies in usage, for example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;var label: UILabel?
label!.text!= label!.text! + digit

var label2: UILabel!
label2.text! = label2.text! + digit
//here, UILable's text is `text?`
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;optional chaining&lt;/h3&gt;
&lt;p&gt;In Book [The Swift Programming Language], there is a charpt &lt;a href="https://itun.es/us/jEUH0.l"&gt;Optional Chaining&lt;/a&gt;, it is :&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;Optional chaining is a process for querying and calling properties, methods, and subscripts on an optional that might currently be nil.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;Just grab the example from the book:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if​ ​let​ ​johnsStreet​ = ​john​.​residence​?.​address​?.​street​ {
​    ​println​(​"John's street name is ​\(​johnsStreet​)​."​)
​} ​else​ {
​    ​println​(​"Unable to retrieve the address."​)
​}
​// prints "Unable to retrieve the address.”
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We can use &lt;code&gt;?&lt;/code&gt; to get &lt;code&gt;john&lt;/code&gt;'s optional property &lt;code&gt;residence&lt;/code&gt;'s optional propery &lt;code&gt;address&lt;/code&gt;'s optional property &lt;code&gt;street&lt;/code&gt;. That's I think why it is called &lt;code&gt;chaining&lt;/code&gt;. Notice if &lt;code&gt;address&lt;/code&gt; is nil, it will go to the &lt;code&gt;else&lt;/code&gt;.&lt;br/&gt;
There is an important thing: any method,property called in the &lt;code&gt;optional chaining&lt;/code&gt; becomes the optional value event it is not defined as optional. &lt;/p&gt;
&lt;h3&gt;Why we need optional&lt;/h3&gt;
&lt;p&gt;In swift, &lt;code&gt;nil&lt;/code&gt; is not a &lt;strong&gt;value&lt;/strong&gt;, and hence the normal var can't have the value of &lt;code&gt;nil&lt;/code&gt;. But we do need leave the var empty(without value), and &lt;code&gt;optional&lt;/code&gt; comes for that.&lt;/p&gt;
&lt;h3&gt;&lt;/h3&gt;
&lt;h3&gt;&lt;/h3&gt;</summary><category term="swift"></category><category term="iOS"></category></entry><entry><title>Compare of Testflight&amp;&amp;Enterprise Distribution</title><link href="http://icocoa.tk/compare-of-testflightenterprise-distribution.html" rel="alternate"></link><updated>2015-02-28T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-02-28:compare-of-testflightenterprise-distribution.html</id><summary type="html">&lt;h3&gt;前言&lt;/h3&gt;
&lt;p&gt;应要求整理的分发方式比较。可惜了有enterprise的我们，还是没有充分利用enterprise的特点。&lt;br/&gt;
下面从是否需要review，UDID以及下载方式进行比较，最后简单介绍利用dropbox进行wireless下载in-house app的过程。&lt;/p&gt;
&lt;h3&gt;1 Compare&lt;/h3&gt;
&lt;p&gt;First of all, a simple comparing of Tesftflight and Enterprise distribution is listed below.&lt;/p&gt;
&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;Type&lt;/th&gt;
&lt;th&gt;TestFlight&lt;/th&gt;
&lt;th&gt;Enterprise&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;Review by Apple&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Device UDID&lt;/td&gt;
&lt;td&gt;Required&lt;/td&gt;
&lt;td&gt;NO&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;Download&lt;/td&gt;
&lt;td&gt;TestFlight iOS App(iOS8)&lt;/td&gt;
&lt;td&gt;Custom Server&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;h3&gt;2 Testflight distribution&lt;/h3&gt;
&lt;h4&gt;2.1 Review&lt;/h4&gt;
&lt;p&gt;It needs to upload the app to Apple and wait for Apple's review when the app is distributed to the customers by Testflight. It usually costs one day or more. &lt;br/&gt;
We also need emails of testers so that we can add them as the external testers. We can only add a maxmium of 1000 testers. &lt;br/&gt;
Moreover, the app which is passed review can only be validated for 30 days.&lt;/p&gt;
&lt;h4&gt;2.2 Device UDID&lt;/h4&gt;
&lt;p&gt;The UDID of tester's device is requied or the tester cannot install the app.&lt;/p&gt;
&lt;h4&gt;2.3 Download&lt;/h4&gt;
&lt;p&gt;The tester should use TestFlight iOS app to download the to-be-tested app, and the TestFlight iOS app is available &lt;strong&gt;only&lt;/strong&gt; in &lt;code&gt;iOS8+&lt;/code&gt;.
We manage the testflight distribution via &lt;a href="https://itunesconnect.apple.com/WebObjects/iTunesConnect.woa/ra/ng/"&gt;itunes connect&lt;/a&gt;.&lt;/p&gt;
&lt;h3&gt;3 Enterprise distribution&lt;/h3&gt;
&lt;p&gt;When talking about distributed to custmers with Enterprise distribution, it means &lt;code&gt;in-house&lt;/code&gt; distribution.&lt;/p&gt;
&lt;h4&gt;3.1 Review&lt;/h4&gt;
&lt;p&gt;We don't need to pass Apple's review as we not distribute    it via Apple's store.&lt;/p&gt;
&lt;h4&gt;3.2 Device UDID&lt;/h4&gt;
&lt;p&gt;Using &lt;code&gt;in-house&lt;/code&gt;, &lt;strong&gt;no&lt;/strong&gt; device UDID is required.&lt;br/&gt;
By the way, we can also need the device's UDID so that we can make the app available for specified devices. At this time, it is not called &lt;code&gt;in-house&lt;/code&gt; and  not makes full use of iOS Enterprise Program.&lt;/p&gt;
&lt;h4&gt;3.3 Download&lt;/h4&gt;
&lt;p&gt;The customers donwload the app via our server which can be visit via &lt;code&gt;https&lt;/code&gt; and it can be valid until we delete it from the server. &lt;/p&gt;
&lt;h4&gt;3.4 Others&lt;/h4&gt;
&lt;p&gt;Sticktly speaking, when we use &lt;code&gt;in-house&lt;/code&gt; enterprise distribution, we can only distibute the app to the employers of our company. See details of last second from &lt;a href="https://developer.apple.com/support/ios/enterprise.php"&gt;here&lt;/a&gt;.&lt;br/&gt;
But it is just an official declare, and there's no technical limit to install out of the company. &lt;/p&gt;
&lt;h3&gt;4 wireless in-house distribution using dropbox&lt;/h3&gt;
&lt;p&gt;The reason that why we choose dropbox is that &lt;code&gt;https&lt;/code&gt; is required. If you have any other links which use &lt;code&gt;https&lt;/code&gt;, that will also be OK.&lt;br/&gt;
What we need is :&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;enterprise ipa&lt;/li&gt;
&lt;li&gt;plist file&lt;/li&gt;
&lt;li&gt;html file&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;4.1 ipa&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Product-&amp;gt;Archive&lt;/code&gt; to create the archive. When it is finished, &lt;code&gt;Export&lt;/code&gt; and choose to &lt;code&gt;Save for Enterprise Deployment&lt;/code&gt;. In Xcode6, it will just create the ipa if you can create this kind distribution.&lt;/p&gt;
&lt;h4&gt;4.2 plist file&lt;/h4&gt;
&lt;p&gt;The content of this plist file should be like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;&amp;lt;?xml version="1.0" encoding="UTF-8"?&amp;gt;&lt;/span&gt;
&lt;span class="cp"&gt;&amp;lt;!DOCTYPE plist PUBLIC "-//Apple//DTD PLIST 1.0//EN" "http://www.apple.com/DTDs/PropertyList-1.0.dtd"&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;plist&lt;/span&gt; &lt;span class="na"&gt;version=&lt;/span&gt;&lt;span class="s"&gt;"1.0"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;items&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;assets&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;kind&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;software-package&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;url&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Your URL of ipa&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;metadata&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;bundle-identifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Your true identifier&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;bundle-version&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Your Version&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;kind&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;software&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;title&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
                &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Your App Name&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
            &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/plist&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.3 html&lt;/h4&gt;
&lt;p&gt;create a simple html file, like:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;a&lt;/span&gt; &lt;span class="na"&gt;href=&lt;/span&gt;&lt;span class="s"&gt;"itms-services://?action=download-manifest&amp;amp;url=Your URL to plist"&lt;/span&gt;&lt;span class="nt"&gt;&amp;gt;&lt;/span&gt;
click this link to install
&lt;span class="nt"&gt;&amp;lt;/a&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;4.4 notice the URLs&lt;/h4&gt;
&lt;p&gt;Put the 3 files to the dropbox and share those to public, and write down the share link URLs.
When we use the URL, please replace &lt;code&gt;www.dropbox.com&lt;/code&gt; with &lt;code&gt;dl.dropboxusercontent.com&lt;/code&gt;, and remove the appendix like:&lt;code&gt;?dl=0&lt;/code&gt;. &lt;br/&gt;
Then we can fill in the html and plist file with the URL.&lt;br/&gt;
Finally, visit the html's share line in your iPhone's safari, click the "click this link to install" and your iphone will automatically download the ipa.&lt;/p&gt;</summary><category term="iOS"></category><category term="distribution"></category></entry><entry><title>个人App发布前的测试</title><link href="http://icocoa.tk/ge-ren-appfa-bu-qian-de-ce-shi.html" rel="alternate"></link><updated>2015-02-25T00:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-02-25:ge-ren-appfa-bu-qian-de-ce-shi.html</id><summary type="html">&lt;h2&gt;前言&lt;/h2&gt;
&lt;p&gt;假期里原本想好好的放松，多看几本书，多运动，不曾想一半的时间花费在修改bug上了。算上假期前提交的版本，整个春节期间发布了3个小版本的更新，申请了2次紧急提交审核。其中经历不可谓不惊心动魄，虽然未必对下载量有所帮助，但至少也让用户感觉到：这大过年的也在更新，也是蛮拼的了:-)。&lt;/p&gt;
&lt;h2&gt;测试流程&lt;/h2&gt;
&lt;p&gt;言归正传，春节期间提交的紧急修复起因都是程序出了严重的bug，而且都是在修复某个bug的过程中引入的bug。这说明即使是个人开发者，对于提交前的测试流程必须要重视。不管是养成一个好习惯，或者是开发出较高质量的程序，完备的测试是不可或缺的。下面结合自身的情况，把相应的测试守则完备下，督促自己执行。&lt;/p&gt;
&lt;h3&gt;功能设计和实现阶段&lt;/h3&gt;
&lt;p&gt;在分解App的功能的设计阶段，或者在实现功能的阶段，根据功能点，撰写相应的测试内容。具体来说就是针对每一个功能点，设计测试步骤；功能复杂的时候测试步骤也要细化。这里尤其要注意的是务必覆盖所有的功能点。此外，针对边界情况的测试，基本也包含在此阶段。&lt;/p&gt;
&lt;h3&gt;模块化集成阶段&lt;/h3&gt;
&lt;p&gt;当完成几个模块后，可以着手集成测试，这个阶段主要侧重运行时模块之间的运行情况。有时候单独的功能使用没有任何问题，但是当和其他模块功能一起使用的过程中，会发生问题。&lt;/p&gt;
&lt;h3&gt;测试环境&lt;/h3&gt;
&lt;p&gt;发布前的App必须完整经历Ad hoc版本的测试，因为developer模式下有些bug不会产生。这一点，相信很多人都深有体会。&lt;/p&gt;
&lt;h2&gt;修复bug后的测试流程&lt;/h2&gt;
&lt;p&gt;很多情况下，修复了某bug后，出于对自己的自信，只对修复bug进行测试。但往往在无意间，一个新的bug就引入了。因此，修复了bug后还是要当一个新App一样，重新测试。&lt;/p&gt;
&lt;h3&gt;自动化测试&lt;/h3&gt;
&lt;p&gt;说到这里，就不得不想起自动化测试了。虽然要实现自动化测试，开始需要耗费一些精力，但是如上所述修复某个bug的情形，如果这时可以用jekins自动跑一跑测试用例，相信会省力不少。而且，用心做一个App的话，更新N(N&amp;gt;10)个版本的可能性还是存在的，相信到最后，App的bug也会越来越少。&lt;br/&gt;
这里也督促自己需要重拾jekins以及UIAutomate。&lt;/p&gt;
&lt;h2&gt;后记&lt;/h2&gt;
&lt;p&gt;常常提醒自己，不能在同一个地方跌倒多次。春节期间，App的发布经历无疑是一个狠狠的掌掴。那么，到底是什么引起的呢？自己的不负责任，水平有限亦或是其他？其实，简单的说就是缺少必要的制度，这里就是测试。试想，一个企业发布的app经历那么多轮的测试尚且会有问题，何况是个人的呢？虽然个人的App在复杂度上和企业类的app无法相提并论，但是bug的生存空间和几率却完全是相等的。所以没有理由只重视开发而忽视测试。&lt;br/&gt;
当然，也有人说免费的App何须花这么多精力？然而，如果把App当成是你的作品，像一座房子，一辆车子一般，想必没有人会愿意出现crash或者其他致命的错误吧。说到底，这也是一种人生的态度。我相信，在力所能及的范围内，做好每一件事，时间久了，必然会积累出质变！&lt;/p&gt;</summary><category term="iOS"></category><category term="测试"></category></entry><entry><title>过去一周的思考</title><link href="http://icocoa.tk/guo-qu-yi-zhou-de-si-kao.html" rel="alternate"></link><updated>2015-02-13T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-02-13:guo-qu-yi-zhou-de-si-kao.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;过去的一周可以算是波澜起伏，主要关于两方面：一个是app的下载，另一个是app的发布。&lt;/p&gt;
&lt;h2&gt;app的下载&lt;/h2&gt;
&lt;p&gt;ASO是一个至今不得窥其入门的东西，某个收费的app自上线至今约3个月的时间保持平均每天3个的下载节奏。期间在app中集成的分享平台中发过带app的tag的链接（主要是国外的分享平台），这种方式可以引起用户的注意，可以算是营销的一种方式。只是一个人势单力薄，无法做到每天的更新。这种方式和app的下载互为因果，因为很难单纯的通过这种方式提高下载量，相反这种推广的效果还取决于app的下载基数。因此，我认为这属于“锦上添花”增加用户基数型的营销模式。&lt;br/&gt;
虽然推广没有花费大力气，但是本周还是发生了下载量突变的情形。5-10日之间下载量分别是个位数，2位数，3位数，3位数，2位数，个位数。至此，恢复以往的平静。在此期间，做到分类付费和畅销排名前三。虽然之前也油锅这样的经历，但这次的app是收费的，意义不同寻常。此外，这样的一个过山车的表现也很让我诧异。是什么导致下载量突然的上升呢？我搜索了一下相关的分享平台，没有大量的使用app的痕迹。通过Appannie的变化追踪来看，我倾向于Apple调整了app的排名算法（如果这些下载量不是黑卡造成的话）。线索就在于5日以及之前的排名已经落后到不知什么地步，而后突然就排名上升。考虑到下载量在相应的category中中规中矩，评价几乎没有的情况，才做出算法调整的判断。&lt;br/&gt;
这个“风波”对我的启示，就是验证了长尾理论。同时也说明，长尾并不是没有做头的。这应该是对个人开发者的一个鼓励，在大公司充斥app排行榜的如今，个人开发者肉汤还是可以喝上的。  &lt;/p&gt;
&lt;h2&gt;app的发布流程&lt;/h2&gt;
&lt;p&gt;查看app的运行情况，发现有闪退。刚好那天下载量飙升到3位数，心里一激动就做了个版本，同时附带着修复了一些其他可能引起闪退的地方。由于着急，联机测试没有问题后，没有进行Adhoc测试就提交发布了。考虑到时间紧迫性，给Apple申请了一个紧急审核的ticket，Apple的团队倒也挺人性的，邮件里跟我解释了下原本不应该答应的，然后说这次网开一面，提交后的8小时内就通过了。然而，第二天从store上下载测试的时候，发现某个机型奔溃了。。。这时又做了一个Adhoc的包测试，发现依然闪退。这时，我突然一阵冷汗，为自己的大意后悔不已。此时，我已经不可能再厚着脸皮请求紧急审核了，只能默默的修复一遍，重新提交一个新版本，目测要8天的时间。在此期间，会有多少同样机型的新/老用户遇到同样的问题，这个不得而知。唯一清楚的，这个原本天时地利的条件，却由于缺少“人和”而彻底陷入败局。&lt;br/&gt;
由此，我立下规矩，无论是多么简单的修复，不管是多么紧急的情况，没有经过Adhoc的真机测试，绝对不允许提交审核！&lt;br/&gt;
在新版本发布后的日子里，我观察到某个国家的评论还算正面——至少说明不是在所有机型上都存在那个闪退问题。这是唯一让我可以自我安慰的东西了。  &lt;/p&gt;
&lt;h2&gt;今后的打算&lt;/h2&gt;
&lt;p&gt;To Be Independent是我的一个梦想，Apple Store至少让我看到还是有希望的。App要想有好的表现，切中用户需求的痛点是重中之重——这是今年行事的方向。 此外，就是对待App的发布，一定要严格按照既定的流程来，不能因为是个人开发而马虎讲究！&lt;/p&gt;</summary><category term="iOS"></category></entry><entry><title>Xcode6制作iOS Framework</title><link href="http://icocoa.tk/xcode6zhi-zuo-ios-framework.html" rel="alternate"></link><updated>2015-02-05T14:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-02-05:xcode6zhi-zuo-ios-framework.html</id><summary type="html">&lt;h2&gt;简介&lt;/h2&gt;
&lt;p&gt;最近需要用到Framework，在Xcode6上实践了一下，虽然制作原理没有变化，但在Xcode6中操作还是有一些不一样。我遇到的问题在&lt;a href="http://www.raywenderlich.com/65964/create-a-framework-for-ios"&gt;raywenderlich&lt;/a&gt;上都有解决。&lt;br/&gt;
使用过第三方如统计之类工具的，对framework不会陌生。所以framework最大的一个好处就是提供接口但隐藏代码，在开发SDK过程中经常使用。&lt;/p&gt;
&lt;h2&gt;静态库模板&lt;/h2&gt;
&lt;p&gt;选择如下的静态模板创建工程，当然也可以在已有工程下创建新的target。这里可以看到Xcode6中新加了&lt;code&gt;Cocoa Touch Framework&lt;/code&gt;，但是这里我们还是选择静态库模板。&lt;br/&gt;
&lt;img alt="static_template" src="./imgs/20150205/static_template.png"/&gt;&lt;/p&gt;
&lt;h2&gt;添加文件&lt;/h2&gt;
&lt;p&gt;Framework本身包含库头文件和静态库，所以首先我们要把需要打包成framework的文件添加的工程，注意添加的时候确认target对象是否正确。接下来，查看文件引用了哪些系统库，在&lt;code&gt;build phase-&amp;gt;Link Binary With Libraries&lt;/code&gt;中将系统库添加进去，通常会添加Foundation或是UIKit库。然后添加相应的代码，添加的时候注意target是库对象。再在&lt;code&gt;build phase-&amp;gt;Headers&lt;/code&gt;中找到头文件，将需要设置为public的文件拖到&lt;code&gt;Public&lt;/code&gt;一榄。
这时build一下，可以发现已经生成一个.a文件了。但此时还没有完成framework的制作：
1. 该静态库只包含一种架构
2. 头文件没有和库一起打包&lt;/p&gt;
&lt;p&gt;借用 raywenderlich上的图来说明framework的组织结构：&lt;br/&gt;
&lt;img alt="ios_framework_directory_structure" src="http://cdn3.raywenderlich.com/wp-content/uploads/2014/02/ios_framework_directory_structure.png"/&gt; &lt;/p&gt;
&lt;h2&gt;生成Framework&lt;/h2&gt;
&lt;p&gt;接下来，我们给静态库添加执行脚本，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;set -e

export FRAMEWORK_LOCN="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BUILT_PRODUCTS_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PRODUCT_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.framework"

# Create the path to the real Headers die
mkdir -p "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;FRAMEWORK_LOCN&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Versions/A/Headers"

# Create the required symlinks
/bin/ln -sfh A "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;FRAMEWORK_LOCN&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Versions/Current"
/bin/ln -sfh Versions/Current/Headers "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;FRAMEWORK_LOCN&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Headers"
/bin/ln -sfh "Versions/Current/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PRODUCT_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
"&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;FRAMEWORK_LOCN&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PRODUCT_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"

# Copy the public headers into the framework
/bin/cp -a "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TARGET_BUILD_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PUBLIC_HEADERS_FOLDER_PATH&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/" \
"&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;FRAMEWORK_LOCN&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Versions/A/Headers"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接着创建一个&lt;code&gt;Aggregate&lt;/code&gt;对象，然后给该对象也添加执行脚本，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;set -e

# If we're already inside this script then die
if [ -n "&lt;span class="nv"&gt;$RW_MULTIPLATFORM_BUILD_IN_PROGRESS&lt;/span&gt;" ]; then
exit 0
fi
export RW_MULTIPLATFORM_BUILD_IN_PROGRESS=1

RW_FRAMEWORK_NAME=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
RW_FRAMEWORK_NAME="PjsipFramework"
RW_INPUT_STATIC_LIB="lib&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PROJECT_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.a"
RW_INPUT_STATIC_LIB="libPjsipFramework.a"

RW_FRAMEWORK_LOCATION="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BUILT_PRODUCTS_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.framework"

function build_static_library {
    # Will rebuild the static library as specified
    #     build_static_library sdk
    xcrun xcodebuild -project "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;PROJECT_FILE_PATH&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    -target "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;TARGET_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    -configuration "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;CONFIGURATION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    -sdk "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    ONLY_ACTIVE_ARCH=NO \
    BUILD_DIR="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BUILD_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    OBJROOT="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;OBJROOT&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    BUILD_ROOT="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BUILD_ROOT&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
    SYMROOT="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;SYMROOT&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" &lt;span class="nv"&gt;$ACTION&lt;/span&gt;
}

function make_fat_library {
    # Will smash 2 static libs together
    #     make_fat_library in1 in2 out
    xcrun lipo -create "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;2&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" -output "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
}

# 1 - Extract the platform (iphoneos/iphonesimulator) from the SDK name
if [[ "&lt;span class="nv"&gt;$SDK_NAME&lt;/span&gt;" =~ ([A-Za-z]+) ]]; then
RW_SDK_PLATFORM=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BASH_REMATCH&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
else
echo "Could not find platform name from SDK_NAME: &lt;span class="nv"&gt;$SDK_NAME&lt;/span&gt;"
exit 1
fi

# 2 - Extract the version from the SDK
if [[ "&lt;span class="nv"&gt;$SDK_NAME&lt;/span&gt;" =~ ([0-9]+.*$) ]]; then
RW_SDK_VERSION=&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BASH_REMATCH&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;
else
echo "Could not find sdk version from SDK_NAME: &lt;span class="nv"&gt;$SDK_NAME&lt;/span&gt;"
exit 1
fi

# 3 - Determine the other platform
if [ "&lt;span class="nv"&gt;$RW_SDK_PLATFORM&lt;/span&gt;" == "iphoneos" ]; then
RW_OTHER_PLATFORM=iphonesimulator
else
RW_OTHER_PLATFORM=iphoneos
fi

# 4 - Find the build directory
if [[ "&lt;span class="nv"&gt;$BUILT_PRODUCTS_DIR&lt;/span&gt;" =~ (.*)&lt;span class="nv"&gt;$RW_SDK_PLATFORM&lt;/span&gt;$ ]]; then
RW_OTHER_BUILT_PRODUCTS_DIR="&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BASH_REMATCH&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;&lt;span class="cp"&gt;}${&lt;/span&gt;&lt;span class="n"&gt;RW_OTHER_PLATFORM&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
else
echo "Could not find other platform build directory."
exit 1
fi

# Build the other platform.
build_static_library "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_OTHER_PLATFORM&lt;/span&gt;&lt;span class="cp"&gt;}${&lt;/span&gt;&lt;span class="n"&gt;RW_SDK_VERSION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"

# If we're currently building for iphonesimulator, then need to rebuild
#   to ensure that we get both i386 and x86_64
if [ "&lt;span class="nv"&gt;$RW_SDK_PLATFORM&lt;/span&gt;" == "iphonesimulator" ]; then
build_static_library "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;SDK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"
fi

# Join the 2 static libs into 1 and push into the .framework
make_fat_library "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;BUILT_PRODUCTS_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_INPUT_STATIC_LIB&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
"&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_OTHER_BUILT_PRODUCTS_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_INPUT_STATIC_LIB&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
"&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_LOCATION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Versions/A/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"

# Ensure that the framework is present in both platform's build directories
cp -a "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_LOCATION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Versions/A/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" \
"&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_OTHER_BUILT_PRODUCTS_DIR&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.framework/Versions/A/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;"

# Copy the framework to the user's desktop
ditto "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_LOCATION&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;" "&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;HOME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;/Desktop/&lt;span class="cp"&gt;${&lt;/span&gt;&lt;span class="n"&gt;RW_FRAMEWORK_NAME&lt;/span&gt;&lt;span class="cp"&gt;}&lt;/span&gt;.framework"
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;脚本的内容不多说了，有解释。&lt;br/&gt;
接下来在&lt;code&gt;Aggregate&lt;/code&gt;对象中的&lt;code&gt;Target Dependencies&lt;/code&gt;中添加之前的静态库作为依赖。接着选择&lt;code&gt;Aggregate&lt;/code&gt;对象，build一下，就可以生成所需的framework了。此脚本执行完后，framework会生成在用户桌面。使用&lt;code&gt;xcrun lipo -info your.framework/Versions/A/customFramework&lt;/code&gt; 可以检测库是否包含多个架构。&lt;/p&gt;
&lt;h2&gt;framework的使用&lt;/h2&gt;
&lt;p&gt;新建一个工程，将上述framework添加到工程，在需要使用的地方添加如&lt;code&gt;#import &amp;lt;YourFramework/PublicFile.h&amp;gt;&lt;/code&gt;，这样就可以使用了&lt;/p&gt;
&lt;h2&gt;其他问题&lt;/h2&gt;
&lt;p&gt;因为是创建一个framework给他人使用，以下设置最好留给使用framework的工程设置：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Dead Code Stripping –  NO&lt;/li&gt;
&lt;li&gt;Strip Debug Symbols During Copy – NO&lt;/li&gt;
&lt;li&gt;Strip Style – Non-Global Symbols&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;结束&lt;/h2&gt;
&lt;p&gt;以上是创建framework的记录总结，使用framework一点也不神秘，可以帮助我们更好的模块化工程，加深层次的设计和实践，从而提高开发的水平。&lt;/p&gt;</summary><category term="iOS"></category><category term="framework"></category></entry><entry><title>[Tips]NSTimer对Target的强引用</title><link href="http://icocoa.tk/tipsnstimerdui-targetde-qiang-yin-yong.html" rel="alternate"></link><updated>2015-01-22T17:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-22:tipsnstimerdui-targetde-qiang-yin-yong.html</id><summary type="html">&lt;h2&gt;NSTimer对Target的强引用&lt;/h2&gt;
&lt;p&gt;这是一个老坑，虽然app发生错误后经过一些调试很快定位到NSTimer，还是觉得有必要记录下。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ (NSTimer *)scheduledTimerWithTimeInterval:(NSTimeInterval)ti target:(id)aTarget selector:(SEL)aSelector userInfo:(id)userInfo repeats:(BOOL)yesOrNo
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，API文档中清楚地解释到：&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;The object to which to send the message specified by aSelector when the timer fires. The timer maintains a strong reference to target until it (the timer) is invalidated.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;在实际运用中，target往往是当前的调用者，比如一个ViewController。这样就形成了一个经典的循环引用问题，导致当前的ViewControler始终无法释放。&lt;/p&gt;
&lt;h2&gt;解决之道&lt;/h2&gt;
&lt;p&gt;对于Timer要始终牢记手动invalidate，并且不能在dealloc中进行invalidate。&lt;/p&gt;</summary><category term="objc"></category><category term="iOS"></category></entry><entry><title>VOIP:pjsip的编译和使用</title><link href="http://icocoa.tk/voippjsipde-bian-yi-he-shi-yong.html" rel="alternate"></link><updated>2015-01-18T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-18:voippjsipde-bian-yi-he-shi-yong.html</id><summary type="html">&lt;h2&gt;1pjsip简介&lt;/h2&gt;
&lt;p&gt;&lt;a href="http://www.pjsip.org/"&gt;pjsip&lt;/a&gt;是免费开源的多媒体通信库，纯c编写，可移植性非常好，支持多种协议，多种编/解码方式。对iOS的后台支持的很好(按文档的所说)，v2.3已经支持iOS上的视频传输。鉴于此，pjsip是实现VOIP比较好的选择。&lt;/p&gt;
&lt;h2&gt;2pjsip编译&lt;/h2&gt;
&lt;p&gt;可移植性(portable)是pjsip宣称的一大&lt;a href="http://www.pjsip.org/about.htm#portable"&gt;特性&lt;/a&gt;。在iOS上的使用方法，有详细的&lt;a href="http://trac.pjsip.org/repos/wiki/Getting-Started/iPhone"&gt;使用手册&lt;/a&gt;，这里会简单的记录下需要注意的地方。&lt;/p&gt;
&lt;h3&gt;2.1 准备&lt;/h3&gt;
&lt;p&gt;编译首先需要有源码，请到&lt;a href="http://trac.pjsip.org/repos/wiki/Getting-Started/Download-Source"&gt;这里&lt;/a&gt;查看。对于想直接使用pjsip的建议直接下载release的&lt;a href="http://trac.pjsip.org/repos/wiki/Getting-Started/Download-Source"&gt;稳定版本&lt;/a&gt;，win系统请下zip格式，其余的请下tar格式。&lt;br/&gt;
源码下载好后，进入其中的&lt;code&gt;./pjlib/include/pj/&lt;/code&gt;，创建文件&lt;code&gt;config_site.h&lt;/code&gt;， 内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="cp"&gt;#define PJ_CONFIG_IPHONE 1&lt;/span&gt;
&lt;span class="cp"&gt;#include &amp;lt;pj/config_site_sample.h&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;2.2 编译&lt;/h3&gt;
&lt;p&gt;因为不同iPhone的处理器架构不一样，我们在编译的时候需要指定arch，iPhone6是arm64, 5s是armv7s，5是armv7，使用下面的命令：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;cd&lt;/span&gt; /path/to/your/pjsip/dir
&lt;span class="nv"&gt;$ ARCH&lt;/span&gt;&lt;span class="o"&gt;=&lt;/span&gt;&lt;span class="s1"&gt;'-arch arm64'&lt;/span&gt; ./configure-iphone
&lt;span class="nv"&gt;$ &lt;/span&gt;make dep &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make clean &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; make
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样所需的库和头文件都编译好了，可以运行sample了&lt;/p&gt;
&lt;h3&gt;2.3 sample&lt;/h3&gt;
&lt;p&gt;v2.3版本中，进入&lt;code&gt;./pjsip-apps/src/pjsua/ios&lt;/code&gt;，打开&lt;code&gt;ipjsua.xcodeproj&lt;/code&gt;，运行后会看到一个带有&lt;em&gt;pjsua&lt;/em&gt;的黑色界面，底部有诸如：&lt;code&gt;Telnet to xx.xx.xx.xx:xxxx&lt;/code&gt;的字样。从v2.1以上的版本，sample带有&lt;code&gt;CLI&lt;/code&gt;功能，具体的命令见&lt;a href="http://trac.pjsip.org/repos/wiki/PJSUA-CLI"&gt;手册&lt;/a&gt;。&lt;br/&gt;
为了演示如何打电话，需要事先准备好sip服务器，安装好2台测试机。打开terminal，通过telnet连接测试机A，首先添加账号，输入：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+a sip:100@server.com sip:server.com * 100 123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，100是sip服务器上的账号，123456是账号密码，server.com是服务器。如法炮制telnet连接测试机B后，也添加一个账号，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+a sip:100@server.com sip:server.com * 100 123456
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来通过测试机A拨打电话给测试机B：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;call new sip:101@server.com
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而在测试机B上可以选择接通或挂断： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;call answer 200
call hangup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时拿起手机说话，声音就能从另一台手机中听到。&lt;/p&gt;
&lt;h3&gt;2.4 模拟器上的使用&lt;/h3&gt;
&lt;p&gt;模拟器上的编译命令如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;export DEVPATH=/Applications/Xcode.app/Contents/Developer/Platforms/iPhoneSimulator.platform/Developer
ARCH="-arch i386" CFLAGS="-O2 -m32 -mios-simulator-version-min=7.0" LDFLAGS="-O2 -m32 -mios-simulator-version-min=7.0" ./configure-iphone
make dep &amp;amp;&amp;amp; make clean &amp;amp;&amp;amp; make
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;安装多个Xcode的机器根据情况选择合适Xcode的路径，根据所需适配的iOS最低系统自行修改iOS参数。&lt;/p&gt;
&lt;h2&gt;3 引入工程&lt;/h2&gt;
&lt;p&gt;编译好的库和头文件位于以下文件夹内的&lt;code&gt;include&lt;/code&gt;和&lt;code&gt;lib&lt;/code&gt;内：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;/pjlib&lt;/li&gt;
&lt;li&gt;/pjlib-util&lt;/li&gt;
&lt;li&gt;/pjmedia&lt;/li&gt;
&lt;li&gt;/pjnath&lt;/li&gt;
&lt;li&gt;/pjnath&lt;/li&gt;
&lt;li&gt;/third_party&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来，把lib内的.a文件都拖到xcode工程中，再接着添加include中的文件。对于include内的文件，也可以把上述6个文件夹包含的include文件合并到一个文件夹，然后设置工程的&lt;code&gt;Header Search Paths&lt;/code&gt;参数。 
接着Xcode6以前的项目需要在pch文件中添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;#define PJ_AUTOCONF
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而Xcode6创建的项目，在&lt;code&gt;Preprocessor Macros&lt;/code&gt;中添加&lt;code&gt;PJ_AUTOCONF&lt;/code&gt;参数。这样，在需要使用pjsip的地方引入头文件&lt;code&gt;#include &amp;lt;pjsua-lib/pjsua.h&amp;gt;&lt;/code&gt;即可使用了。&lt;/p&gt;
&lt;h3&gt;3.1 支持多版本的编译&lt;/h3&gt;
&lt;p&gt;分别设置不同的arch，然后使用lipo合并，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;lipo -arch armv6 lib/armv6/libpjlib.a -arch armv7 lib/armv7/libpjlib.a -create -output lib/libpjlib.a
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在测试的时候，可以把真机和模拟器的库打包在一起，等到发布的时候只需要使用真机打包的库。&lt;/p&gt;
&lt;h2&gt;4 其他要点&lt;/h2&gt;
&lt;h3&gt;4.1 支持openssl&lt;/h3&gt;
&lt;p&gt;如果通话需要加密，那么请编译openssl，具体方法在&lt;a href="http://trac.pjsip.org/repos/wiki/Getting-Started/iPhone#OpenSSLSuport"&gt;这里&lt;/a&gt;。暂时还没有用到，但感觉项目以后会用到，先mark下。&lt;/p&gt;
&lt;h3&gt;4.2 常见问题&lt;/h3&gt;
&lt;p&gt;还有一些iOS系统集成中常见的&lt;a href="http://trac.pjsip.org/repos/wiki/Getting-Started/iPhone#Commonproblems"&gt;问题说明&lt;/a&gt;，可以先浏览下，从中也可以看到pjsip对后台任务提供了内在支持。&lt;/p&gt;</summary><category term="iOS"></category><category term="pjsip"></category></entry><entry><title>限制文本输入长度</title><link href="http://icocoa.tk/xian-zhi-wen-ben-shu-ru-chang-du.html" rel="alternate"></link><updated>2015-01-09T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-09:xian-zhi-wen-ben-shu-ru-chang-du.html</id><summary type="html">&lt;h2&gt;需求&lt;/h2&gt;
&lt;p&gt;限制字符输入长度是个常见的需求，比如注册的账号或者密码。通常，从用户体验的角度，iOS App中当输入超过制定长度的字符时不需要显式的弹出提示，而只需要让超过的字符不显示即可。这个功能看似简单，但是考虑到一些输入系统例如中文输入法的联想功能，就不那么简单。&lt;/p&gt;
&lt;h2&gt;一般的实现&lt;/h2&gt;
&lt;p&gt;以UITextField为例，通常的做法是在delegate中做文章。这样的解决方案很多，stackflow上一个比较全面的解答：&lt;a href="http://stackoverflow.com/questions/433337/set-the-maximum-character-length-of-a-uitextfield"&gt;Set the maximum character length of a UITextField&lt;/a&gt;，大致的思路就是在输入即将要替换的时候，计算最终要显示的字符串。这个方法对于英文输入是没有问题的，但是对于其他语言如中文输入就会存在问题。举例来说中文拼音输入“的”时，用户需要输入de，在未选中“的”时，de以选中的状态在输入框中显示，并作为输入框的内容，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="input1" src="./imgs/20150109/IMG_0040.png"/&gt;&lt;img alt="input2" src="./imgs/20150109/IMG_0041.png"/&gt;&lt;/p&gt;
&lt;p&gt;按照中文的输入法，de两个字符并不是最终显示在UITextField控件中，所以背景有选中区域，但此时UITextFiled的属性&lt;em&gt;text&lt;/em&gt;的内容包含de。然后，右图显示的是输入“的”后产生的联想，注意此时点击“确”的时候，UITextField的任一delegate都不会响应。所以，要另想办法解决。&lt;/p&gt;
&lt;h2&gt;解决办法&lt;/h2&gt;
&lt;p&gt;UITextField有一个属性&lt;em&gt;markedTextRange&lt;/em&gt;用于标识如中文拼音输入字母时的情形，那么解决的思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UITextFiled的delegate中先检查markedTextRange是否为空，不为空时不做检查允许输入；否则按原先的思路计算字符长度&lt;/li&gt;
&lt;li&gt;注册&lt;em&gt;UITextFieldTextDidChangeNotification&lt;/em&gt;消息，用于处理联想输入情形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面给出代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;textField:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UITextField&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;textField&lt;/span&gt; &lt;span class="nf"&gt;shouldChangeCharactersInRange:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRange&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt; &lt;span class="nf"&gt;replacementString:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;string&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//delete&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;textField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;markedTextRange&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MAX_LEN&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;textChange:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSNotification&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;noti&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;markedTextRange&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MAX_LEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nl"&gt;substringToIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;MAX_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是在&lt;em&gt;UITextFieldTextDidChangeNotification&lt;/em&gt;的响应中需要检测markedTextRange，只有在为nil的情况下再进行字符截断处理，否则程序会抛出异常。&lt;/p&gt;</summary><category term="objc"></category></entry><entry><title>新年开篇</title><link href="http://icocoa.tk/xin-nian-kai-pian.html" rel="alternate"></link><updated>2015-01-05T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-05:xin-nian-kai-pian.html</id><summary type="html">&lt;p&gt;转眼间，又进入了新的一年。虽然农历新年尚有不到两个月，但年的氛围已经起来了。此时，尤其适合回顾过去，展望未来。&lt;/p&gt;
&lt;h2&gt;过去的2014年&lt;/h2&gt;
&lt;p&gt;过去的一年，收获还是颇多的。借鉴前几次计划的不足，2014年初制订计划的时候，没有那么“严格”。比如，要求看书的数量为两本，这样年尾的时候，不至于完不成目标还给自己太大的心里负担。&lt;/p&gt;
&lt;h2&gt;iOS&lt;/h2&gt;
&lt;p&gt;iOS的开发是主打，iOS8新特性的extension总算搞明白并使用在自己的app里。
个人app今年终于上线，总共3个，分别对应不同的类型。原先打算通过挂广告赚点零花钱，却不曾想这条路对于我是那么艰难。反倒是一个付费的app，有不俗的表现，起码明年的续费不用担心了。这给我很大的感触，就是创造的东西要解决用户的实际需求，说的好看点就是时下流行的“抓住用户的痛点”。这个怎么抓，只能各自去体会。自己的经验而言，首要的是行动，想那么多不如先做一点点；在实际航行的时候，再一点点的调整方向。等有了经验以后，有些东西就会水到渠成了。&lt;/p&gt;
&lt;h2&gt;SAE&lt;/h2&gt;
&lt;p&gt;sae上搭建了一些小服务，主要是用于app中的版本检查之类。服务端的开发没有深入，这一块可能会在今年加快实施的步伐，不过现在还没有得到明确的消息。之前搭建的wordpress偷偷的浪费了不少云豆，索性停了，不过blog没有转出，有点可惜，有时间的时候，需要好好处理下。现在使用github pages作为个人blog，记录自己的心得，现正保证平均一周至少一文的标准。&lt;/p&gt;
&lt;h2&gt;设计&lt;/h2&gt;
&lt;p&gt;接触了sketch，真是神器。app中的素材都是通过sketch来生成的，下面需要使用sketch来设计原型，然后再进行实际开发。今年还是花了不少时间在设计上，但是自己看书摸索的过程比较辛苦，效果也不好。2015年，需要换个思路。&lt;/p&gt;
&lt;h2&gt;python&lt;/h2&gt;
&lt;p&gt;python基本的技能已经掌握，在年末之前使用了scrapy，小有体会。继续深入，为下一步计划准备。&lt;/p&gt;
&lt;h2&gt;明年目标&lt;/h2&gt;
&lt;p&gt;首先插一句，不管目标是什么，制订的内容一定要保持自己能够每天坚持去做。只有这样，才能在实际行动中获得快感，激励继续前行。这就是所谓的正反馈，对于个人、团队都是不可缺少的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看完 git 权威指南&lt;/li&gt;
&lt;li&gt;每周至少一次更新github page&lt;/li&gt;
&lt;li&gt;更新air app，并力争上线游戏类新作品&lt;/li&gt;
&lt;li&gt;学习日语，NHK的全部学完
以上是2015上半年计划，先曝曝光，免得自己偷懒或是以后篡改&lt;/li&gt;
&lt;/ol&gt;</summary><category term="总结 计划"></category></entry><entry><title>NSZombierEnable</title><link href="http://icocoa.tk/nszombierenable.html" rel="alternate"></link><updated>2014-12-18T10:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-18:nszombierenable.html</id><summary type="html">&lt;p&gt;今天在cocoachina上看到一篇关于实现NSZombier的翻译贴，原文来自&lt;a href="https://mikeash.com/"&gt;Mike Ash&lt;/a&gt;。此人是(Friday Q&amp;amp;A)的作者，更为神奇的是他白天是飞行员，晚上是程序员，这在天朝不可想像。本文主要是基于他以下两篇文章的笔记。&lt;br/&gt;
&lt;a href="https://mikeash.com/pyblog/friday-qa-2014-11-07-lets-build-nszombie.html"&gt;Friday Q&amp;amp;A 2011-05-20: The Inner Life of Zombies&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://mikeash.com/pyblog/friday-qa-2011-05-20-the-inner-life-of-zombies.html"&gt;Friday Q&amp;amp;A 2014-11-07: Let's Build NSZombie&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;启用NSZombier对象&lt;/h3&gt;
&lt;p&gt;有经验的开发者在遇到诸如&lt;code&gt;EXC_BAD_ACCESS&lt;/code&gt;的错误时往往会设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;为&lt;code&gt;YES&lt;/code&gt;，这样类似的错误发生后，就可以定位到出错的位置，从而便于诊断问题所在。&lt;br/&gt;
诸如此类的内存错误不管是MRC还是ARC下，都是会发生的。发生的原因在于：一个已经release的指针对象，又收到了某个消息，这时就会发生古怪。在MRC下，alloc一个对象A，然后release后，该对象所指向的内存被系统回收，标记为可用状态。根据程序运行的情况，该处内存可能过会被系统回收也可能马上分配给另一对象B。这时，如果程序还认为A对象存在，并发生某个消息给A时，就会发生错误。可以设计如下的测试代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"test"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该片段放置在某个点击事件中，当我们没有设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;时，运行一下：
&lt;img alt="NSZombier_Disable" src="./imgs/20141218/NSZombier_Disable.png"/&gt;&lt;/p&gt;
&lt;p&gt;测试的时候，快速点击了两下，可以发现console里输出了3次"test"，然后程序crash定位在release后的&lt;code&gt;NSLog&lt;/code&gt;处。这说明release后系统可能会没有立即清理该处内存，导致可以输出该内存所存储的内容。&lt;br/&gt;
接下来，启用&lt;code&gt;NSZombieEnabled&lt;/code&gt;，Xcode6中打开&lt;code&gt;schema-&amp;gt;Diagnostics-&amp;gt;Enable Zombie Objects&lt;/code&gt;，然后测试：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="NSZombier_Enable" src="./imgs/20141218/NSZombier_Enable.png"/&gt;&lt;/p&gt;
&lt;p&gt;console里输出了 
     [CFString respondsToSelector:]: message sent to deallocated instance 0x7fa52a7df560
这很明确的指明了错误发生的原因：给dealloc的对象发送了消息。所以在大型项目中，设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;后还是很便于定位内存错误。&lt;/p&gt;
&lt;p&gt;这种给释放的对象发送消息还有可能发生一种错误，就是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFString xxxxx]: unrecognized selector sent to instance 0x7fdd626b2b90'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是因为释放掉的内存被系统分配给另一个对象，而程序继续发送消息给原先的对象时，就很容易发生该类型错误。如果恰好新对象也有一个同名的方法，虽然不至于导致程序马上crash可造成的后果就可大可小了。因此如果程序crash然后console显示因为发送给某个没用到的对象一个程序内找不到的方法的错误时，往往都是对象释放后仍去使用造成的。   &lt;/p&gt;
&lt;h3&gt;深入NSZombier&lt;/h3&gt;
&lt;p&gt;启用&lt;code&gt;NSZombieEnabled&lt;/code&gt;后，对于要释放的内存，系统会创建一个NSZombier的对象来"接管"该内存，当NSZombier对象收到消息后，就会crash并显示错误信息和调用栈。我们使用mikeash的代码来深入研究下内存变化，添加如下的函数并更新原代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#import &amp;lt;malloc/malloc.h&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@ malloc_size &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; - %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSData&lt;/span&gt; &lt;span class="n"&gt;dataWithBytes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;UTF8String&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"Fresh NSObject"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"Destroyed NSObject"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;，运行效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2014-12-18 09:59:50.975 NSZombierTest[1579:185318] test
Fresh NSObject malloc_size 32 - &amp;lt;b8647209 01000000 8c070000 01000000 04746573 74000000 00000000 00000000&amp;gt;
Destroyed NSObject malloc_size 0 - &amp;lt;b8647209 01000000 8c076000 00000000 04746573 74000000 00000000 00000000&amp;gt;
2014-12-18 09:59:50.976 NSZombierTest[1579:185318] test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时release后对象内存size为0，但指向内存地址还是和之前的一样。&lt;br/&gt;
然后设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;，运行效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;31.229&lt;/span&gt; &lt;span class="n"&gt;NSZombierTest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1683&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;206192&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="n"&gt;Fresh&lt;/span&gt; &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b8542f07&lt;/span&gt; &lt;span class="mo"&gt;01000000&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;c070000&lt;/span&gt; &lt;span class="mo"&gt;01000000&lt;/span&gt; &lt;span class="mo"&gt;04746573&lt;/span&gt; &lt;span class="mi"&gt;74000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;Destroyed&lt;/span&gt; &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;c050f14b&lt;/span&gt; &lt;span class="mf"&gt;927f&lt;/span&gt;&lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;c076000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;04746573&lt;/span&gt; &lt;span class="mi"&gt;74000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;31.230&lt;/span&gt; &lt;span class="n"&gt;NSZombierTest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1683&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;206192&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CFString&lt;/span&gt; &lt;span class="nl"&gt;respondsToSelector&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="n"&gt;sent&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;deallocated&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="mh"&gt;0x7f924bfd9780&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时release后的对象内存size为32和release前一样大，同时内存的地址也改变了。这就印证了NSZombier对象的作用。更进一步的，Mike指出系统会使用一个NSZombier类型的对象覆盖之前release的内存，我们继续使用Mike的代码做测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;DumpClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Class&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Dumping class %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Superclass: %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_getSuperclass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Ivars:\n"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Ivar&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ivars&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_copyIvarList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Ivar&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ivars&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"    %s %s %d\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ivar_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ivar_getTypeEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ivar_getOffset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ivars&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Methods:\n"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;methods&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_copyMethodList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"    %s %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sel_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;method_getTypeEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;
&lt;span class="nt"&gt;DumpClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;object_getClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;testString&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Dumping class _NSZombie_CFString
Superclass: nil
Ivars:
    isa # 0
Methods:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出此时的Zombier对象是&lt;code&gt;_NSZombie_CFString&lt;/code&gt;类型，该类型和&lt;code&gt;NSObject&lt;/code&gt;一样，是root class且只包含isa指针，但没有任何方法。  &lt;/p&gt;
&lt;h3&gt;实现 NSZombierEnable&lt;/h3&gt;
&lt;p&gt;实现这一机制，无疑依靠objc的runtime机制。首先想一想需要做哪些事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成一个相应的NSZombier class&lt;/li&gt;
&lt;li&gt;设置该类对消息的响应&lt;/li&gt;
&lt;li&gt;获取释放的对象，将其改写为上述NSZombier class&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我把Mike的相关代码整理了下并做了说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//启用NSZomiber，该函数可以放在+initialize中执行，目的的替换类默认的dealloc方法&lt;/span&gt;
 &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EnableZombies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dealloc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;method_setImplementation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ZombieDealloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//将要释放的对象设置成相应的Zombier class&lt;/span&gt;
 &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ZombieDealloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZombifyClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;object_setClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//创建Zombierclass，并添加方法&lt;/span&gt;
 &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="nf"&gt;ZombifyClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSStringFromClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;@"MAZombie_"&lt;/span&gt; &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
     &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSClassFromString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;zombieClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;objc_allocateClassPair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt; &lt;span class="n"&gt;UTF8String&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;class_addMethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;methodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;:),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ZombieMethodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"@@::"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;class_addMethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;EmptyIMP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"v@:"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;objc_registerClassPair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EmptyIMP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="c1"&gt;//消息转发&lt;/span&gt;
&lt;span class="bp"&gt;NSMethodSignature&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;ZombieMethodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSStringFromClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="nl"&gt;substringFromIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;@"MAZombie_"&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Selector %@ sent to deallocated instance %p of class %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NSStringFromSelector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;abort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c1"&gt;//测试代码&lt;/span&gt;
&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSIndexSet&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;NSZombierTest[3236:495027] Selector count sent to deallocated instance 0x7fbd80eabd00 of class NSIndexSet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的评论中有人给出了Chromium的zombie的实现，源代码可以去&lt;a href="https://chromium.googlesource.com/chromium/src/+/master/chrome/common/mac/objc_zombie.mm"&gt;主页&lt;/a&gt;上查看。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;由此可见，对象的生命周期/相应内存的变化，以及objc的runtime机制，无疑是理解&lt;code&gt;NSZombierEnable&lt;/code&gt;的关键。&lt;/p&gt;</summary><category term="objc"></category></entry><entry><title>Find All Unlocalized Strings</title><link href="http://icocoa.tk/find-all-unlocalized-strings.html" rel="alternate"></link><updated>2014-12-16T17:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-16:find-all-unlocalized-strings.html</id><summary type="html">&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;We have a project which uses &lt;code&gt;NSLocalizedString&lt;/code&gt; macro but some strings  are not localized in the &lt;code&gt;Localizable.strings&lt;/code&gt; file. What we do is to find all these strings and implement the &lt;code&gt;Localizable.strings&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Apple's Tool&lt;/h3&gt;
&lt;p&gt;As I refered &lt;a href="http://stackoverflow.com/a/27266522/371974"&gt;here&lt;/a&gt;, Apple has a built-in tool but is for Appkit application. Open the scheme, and in the &lt;code&gt;Arguments&lt;/code&gt; tab, input the following strings to &lt;code&gt;Arguments Passed On Launch&lt;/code&gt;:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; -NSShowNonLocalizedStrings YES
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, build and run your &lt;strong&gt;Cocoa&lt;/strong&gt; application, the unlocalized string will be shown in console.&lt;br/&gt;
Now the good news is that with iOS8 the console can also print the unlocalized string for the iOS app. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; 2014-12-16 15:53:44.073 iOSUnlocalizedTest[6251:1015330] Localizable string "name" not found in strings table "Localizable" of bundle CFBundle 0x7f9fe3515b80 &amp;lt;/Users/XXXXX/Library/Developer/CoreSimulator/Devices/F7E36A7E-14FF-4D2A-8881-A62C14CB66DE/data/Containers/Bundle/Application/18EB0513-5162-4CEC-9823-17AC3B513EFB/iOSUnlocalizedTest.app&amp;gt; (executable, loaded)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, this is not the final answer as it is just a runtime checking not a static checking(As the setting above is under the &lt;code&gt;Run&lt;/code&gt;). You can't get all expected results at a glance.&lt;/p&gt;
&lt;h3&gt;What we do&lt;/h3&gt;
&lt;p&gt;It is apparent that we have to fix it manually. Considering all the shown strings using &lt;code&gt;NSLocalizedString&lt;/code&gt;, we can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;find all strings in 'NSLocalizedString' macro&lt;/li&gt;
&lt;li&gt;check the string whether exists in the &lt;code&gt;Localized.Strings&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So let's start!&lt;br/&gt;
Open a shell, cd to the project and then run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -n -h "LocalizedString" -r ./ &amp;gt;&amp;gt;../result
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it will save all the lines including "LocalizedString" to the result. In the result file, it will list the file name and line number so that we can recheck it.&lt;br/&gt;
Then we try to get the targeted string which is the first parameter of &lt;code&gt;NSLocalizedString&lt;/code&gt; macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -o -n "\"\w\{1,\}\"" ./result &amp;gt;&amp;gt; singleWord
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it will save all the words to &lt;code&gt;singleWord&lt;/code&gt; file.&lt;br/&gt;
Then we copy the content from &lt;code&gt;Localizable.String&lt;/code&gt; to a txt file and then using the following script &lt;strong&gt;find.sh&lt;/strong&gt;:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;

cat &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read &lt;/span&gt;line
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="c"&gt;# echo $line&lt;/span&gt;
    grep  &lt;span class="nv"&gt;$line&lt;/span&gt; ./japios.txt &amp;gt;&amp;gt; ./has.txt
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt; &amp;gt;&amp;gt; ./has.txt
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt; &amp;gt;&amp;gt; ./nothas.txt
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;run the sh file using: &lt;code&gt;./find.sh singkeWord&lt;/code&gt;. It will save the localized words to has.txt and the non-localized words to the nothas.txt.&lt;br/&gt;
Notice in the script, japios.txt should be created from the &lt;code&gt;Localizable.String&lt;/code&gt; file as &lt;code&gt;Localizable.String&lt;/code&gt; file is recognized as binary file and &lt;code&gt;grep&lt;/code&gt; can't work.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;Using the following steps, we can find all the unlocalized one, but there are places to be imporoved:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the comment code still be figured out&lt;/li&gt;
&lt;li&gt;there are the duplicated words &lt;/li&gt;
&lt;li&gt;can't figure out those which not use &lt;code&gt;NSLocalizedString&lt;/code&gt; macro&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Localized"></category></entry><entry><title>懂得止损</title><link href="http://icocoa.tk/dong-de-zhi-sun.html" rel="alternate"></link><updated>2014-12-08T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-08:dong-de-zhi-sun.html</id><summary type="html">&lt;h2&gt;缘起&lt;/h2&gt;
&lt;p&gt;止损一词似乎在股市中运用的颇多，大概是直接和金钱有联系的缘故。可是大家不要忘记，在当下，每个人的实践也是笔巨大的财富。想想首富们一分钟能赚的钱，就知道此言不虚。虽然你我离首富尚有些距离，但时间的宝贵会随着年龄的增长与日俱增。&lt;br/&gt;
最近在做app的分享功能，使用的是&lt;code&gt;Umeng&lt;/code&gt;的组件，之所以使用Umeng是因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;之前在技术群中，经常见到有人对shareSDK的诟病&lt;/li&gt;
&lt;li&gt;使用umeng的统计组件，对其印象不错
可是，偏偏这个分享，花费了整整一周的时间。&lt;br/&gt;
虽然我在这里直接列出了umeng和sharesdk，但是绝无软广的意思，想表达的是在浪费了一定宝贵时间的时候，个人应该如何选择分析并做出决策的重要性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;事件过程&lt;/h2&gt;
&lt;p&gt;分享的问题主要是facebook分享失败。在facebook的开发页面注册好app，申请并通过了pulic_action(是post wall的必须)的权限。由于疏忽，使用了Test User进行share的测试，没有任何问题。可是，使用了一个普通账号——既不是admin，也不是developer或tester的账号进行测试时，就会发现分享失败。经过排查，发现在第一次授权的时候，facebook授权页面上显示&lt;code&gt;该app不能post wall&lt;/code&gt;。我的第一直觉先是排查app的设置，未果后联系umeng的客服(这里需要点名一下，umeng的客服水平真的是有待提高)。客服听完我的描述，给出的结论是：既然测试账户可以分享，那么就是说明代码是没有问题的。哈哈，言外之意就是：你个sb，自己不会用，来作甚！ok，那虚心的问下对方，app的设置有什么需要注意的地方。这时，就像服务器超时一般，直到企业qq弹出长时间未说话，然后关闭对话的消息。 
上述的过程，花费了2个工作日，尤其是排查facebook上app的设置，花了近1天时间。&lt;br/&gt;
直到第三天，我丝毫没有怀疑umeng的sdk，还在facebook的开发组里发帖。说实在的，老外的水平也是参差不齐，我特别说明已经取得了相应的权限，还有人不断回复权限要审核。这时有位资料显示是facebook开发人员的回复引起了我的注意，他说：我这种情况facebook的app会弹出2次授权提示，第二次提示的时候会告诉用户该app拥有post权限。虽然以前做过facebook的分享，但是两年前的事情了，我开始意识到这是关键。与此同时，我也发现umeng给出的demo中，facebook分享也有同样的问题，我逐渐意识到这是个bug。于是赶紧联系客服，这次居然没有下文。好在我也不是太TMD一根筋，立马下载并使用了sharesdk，发现facebook的授权果然是会弹出2次。这时已经是第4天，还好自己的开发经验不算差，很快的集成好sharesdk。这时又发现了几个使用问题，联系sharesdk的客服，——不得不说，有了比较后sharesdk简直把你当vip一般看待的。周五晚上五点半快下班的时候，还在帮我解答问题，还好我也没耽搁太久，很快就搞定了一切。&lt;/p&gt;
&lt;h2&gt;过程分析&lt;/h2&gt;
&lt;p&gt;首先，因为现在的分析平台确实太多，逐个去集成太麻烦，所以第三方的分享服务才这么有市场。既然有市场，就有好坏之分。虽然是免费的产品，但花费的时间是无法用金钱衡量的(当然我不否认第三方服务为我们节省了大量时间)。这就像是金钱投资，花费了时间，总归需要有回报。当只有一个facebook分享有问题的情况下，要颠覆自己舍弃该sdk是件不易的事情。&lt;br/&gt;
其次，国外的分享平台由于众所周知的原因，一般情况下不太会涉及。这就导致个人对此类平台的陌生：至少我之前根本不知道facebook的授权流程已经&lt;code&gt;进化&lt;/code&gt;到现在的样子了。
最后，就是没有完全测试第三方提供的demo，如果先试用demo的话，就会发现其本身就存在bug&lt;/p&gt;
&lt;h2&gt;止损需要具备的条件&lt;/h2&gt;
&lt;p&gt;虽然5天的时间不是100%的都在处理这个事情，但是这样的一个功能占据了一周的时间，还是需要警惕的。从现在的角度看，可以在以下的时间点及时转换sdk进行&lt;code&gt;止损&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发现facebook上app的设置权限没有问题&lt;/li&gt;
&lt;li&gt;测试用户和普通用户分享的不同情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以没有及时那样做，或者说不敢止损的原因在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虽然有第三方的集成服务，但程序中要初始化一些相关的代码。怕麻烦，以及只有facebook不能分享，导致对umeng的期望过大&lt;/li&gt;
&lt;li&gt;个人对facebook平台的认识缺乏，简单的说就是技术上了解的不多，导致不能及时觉察到问题的症结所在&lt;/li&gt;
&lt;li&gt;先天对sharesdk有了排斥，以及相对的对umeng有了些许好感。主观的因素，往往能决定性的影响人的判断&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;经验教训&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一切都是不可靠的，第三方的服务可以使用但不能依赖&lt;/li&gt;
&lt;li&gt;一切不明白why或者细节的都是可怕的。你不知道实现过程，只知道结果，所以问题发生的时候无从判断&lt;/li&gt;
&lt;li&gt;要增强自己的技术力&lt;/li&gt;
&lt;/ol&gt;</summary><category term=""></category></entry><entry><title>App Extension Study 4</title><link href="http://icocoa.tk/app-extension-study-4.html" rel="alternate"></link><updated>2014-11-19T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-19:app-extension-study-4.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;本篇介绍剩下的&lt;code&gt;Custom Keyboard&lt;/code&gt;，之前的3篇： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;第一篇&lt;/a&gt;: 介绍了Extension的基本概念/运行周期/数据共享等通用技术细节  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-2.html"&gt;第二篇&lt;/a&gt;介绍并实践:widget，share，action和Photo Editing&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-3.html"&gt;第三篇&lt;/a&gt;介绍并实践了Sync和File Procvider&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 Custom Keyboard&lt;/h3&gt;
&lt;p&gt;iOS8终于对第三方输入法开放，引起一片毋需越狱的呼声，这就是通过extension实现的。在以前，app可以单独实现适合自己的文本输入法；而iOS8上，如果用户在设置中添加第三方的键盘，就会对所有app可见(如果app没有禁止使用第三方输入法的话)。对于重视用户隐私的苹果公司而言，虽然开放了输入法的扩展，但是对于用户数据和隐私的保护是非常重视，因此在开发的时候要时刻关注。&lt;/p&gt;
&lt;h4&gt;2.1 第三方输入法要具备的特征&lt;/h4&gt;
&lt;p&gt;输入法的核心是要对用户的点击等手势及时的响应，提供可选的文本和插入文本等。除此之外，重要的就是要能够切换到下一个输入法。苹果文档中列出了一些特征，虽然不要求全部实现，但实现的话会加分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据键盘类型，提供合适的页面布局&lt;/li&gt;
&lt;li&gt;自动纠正和建议&lt;/li&gt;
&lt;li&gt;自动的大小写(指首字母大写)&lt;/li&gt;
&lt;li&gt;双击space生成句号(这个很多人都不知道吧)&lt;/li&gt;
&lt;li&gt;大小写&lt;/li&gt;
&lt;li&gt;提供键帽的图片(keycap artwork)&lt;/li&gt;
&lt;li&gt;为表意文字提供多级输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意的是，在&lt;code&gt;设置&lt;/code&gt;中对键盘的一些设置，只对系统的键盘有效。因此，如果要添加自定义键盘的设置，需要自行添加&lt;code&gt;setting bundle&lt;/code&gt;。如果输入的文本要求是加密，那么iOS会自动使用系统的键盘暂时代替第三方的键盘输入。对于指定拨号类的输入如&lt;code&gt;UIKeyboardTypePhonePad&lt;/code&gt;和&lt;code&gt;UIKeyboardTypeNamePhonePad&lt;/code&gt;，第三方输入法也是不支持的。&lt;br/&gt;
因为第三方的输入法对所有的app都是适用的，所以iOS8中也提供了方法，供app选择是否可以使用第三方输入。如果只想使用系统的键盘输入，那么只要实现如下代理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(NSString *)extensionPointIdentifier
{
    return NO;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2 API的使用&lt;/h4&gt;
&lt;p&gt;首先来看一下第三方输入法的基本构成：&lt;br/&gt;
&lt;img alt="API_Start" src="./imgs/20141119/API_start.png"/&gt; &lt;/p&gt;
&lt;p&gt;第三方输入法激活后的调用和系统输入法的界面构成完全一样，页面主要是由&lt;code&gt;UIInputViewController&lt;/code&gt;的子类构成，可以在上面添加各种按钮或其他控件。图上很明显的加了可以切换输入法的按钮，和上述的要点吻合。&lt;code&gt;Text Input Object&lt;/code&gt;是类似&lt;code&gt;UITextView&lt;/code&gt;会弹出键盘的对象，&lt;code&gt;insertText:&lt;/code&gt;则是输入法输出字符这个最基本的功能。&lt;br/&gt;
&lt;code&gt;UIInputViewController&lt;/code&gt;包含一个实现了&lt;code&gt;UITextDocumentProxy&lt;/code&gt;协议的&lt;code&gt;NSObject&lt;/code&gt;属性&lt;code&gt;textDocumentProxy&lt;/code&gt;，该proxy对象作用比较大，以下事情都是由它负责的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入/删除字符&lt;/li&gt;
&lt;li&gt;查看当前文本&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制插入光标的位置
由于&lt;code&gt;UIInputViewController&lt;/code&gt;实现了&lt;code&gt;UITextInputDelegate&lt;/code&gt;协议，当字符选中或输入的字符有变化时，相应的代理方法会触发。&lt;br/&gt;
对于要支持多语言的，可以有2种选择：  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为每一种语言设计一个键盘，并作为一个单独的Custom Keyboard对象添加到containing app中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;只设计一个键盘，在切当的时候动态切换到主语言。使用primaryLanguage属性可以切换到主语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于自动纠正，可以通过UILexicon访问基本的自动纠正词库。词库的来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来自通讯录中的姓/名数据&lt;/li&gt;
&lt;li&gt;在Settings&amp;gt;General&amp;gt;Keyboard&amp;gt;Shortcuts list中定义的数据&lt;/li&gt;
&lt;li&gt;常见的单词库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于键盘的高度，最好设置成和&lt;code&gt;UIInputViewController&lt;/code&gt;中视图的高度一致。默认情况下，键盘的宽度是始终和屏幕的宽度一致的，所以我们只需要关心高度的设置。&lt;/p&gt;
&lt;h4&gt;2.3 开发的要点&lt;/h4&gt;
&lt;p&gt;主要指：
1. Trust: 慎重对待用户的输入数据
2. "next keyboard" key: 可以切换到下一输入法&lt;/p&gt;
&lt;h5&gt;2.3.1 信任&lt;/h5&gt;
&lt;p&gt;主要涵盖以下3个方面：
1. 按键数据的安全性：因为可以根据按键知道输入的文本内容，千万不能以任何接口上传到自己的服务器
2. 慎用其他数据：启用了network access后，就能访问位置和通讯录，那么使用这些数据的时候就要想好如何跟用户解释
3. 精确性：这个不涉及隐私，主要是影响到用户是否认为你是合意的输入法
默认情况下，网络访问是关闭的，当启用后，输入法将获得一些额外能力，但同时输入法的责任也相应的增加：&lt;br/&gt;
&lt;img alt="responsibility.png" src="./imgs/20141119/responsibility.png"/&gt; 
以上列出了所有增加的能力以及开发者需要考虑的问题。&lt;/p&gt;
&lt;h4&gt;2.4 模版文件&lt;/h4&gt;
&lt;p&gt;新建一个&lt;code&gt;Custom Board&lt;/code&gt;的target，安装并运行&lt;code&gt;containing app&lt;/code&gt;一下，然后就可以在&lt;code&gt;Settings&amp;gt;General&amp;gt;Keyboard&amp;gt;Keyboards&amp;gt;Add New Keyboard&lt;/code&gt;中添加，然后打开某个文本，可以切换到我们定义的输入法。
自定义的键盘的名字可以在plist文件中用&lt;code&gt;Bundle display name&lt;/code&gt;指定，如果在&lt;code&gt;containing app&lt;/code&gt;和&lt;code&gt;extension&lt;/code&gt;都指定了该键值的话，那么在添加键盘的时候会显示&lt;code&gt;Contaning app&lt;/code&gt;中定义的名字，添加完毕后两者都一起显示:&lt;br/&gt;
&lt;img alt="keyboardName" src="./imgs/20141119/keyboard_name.png"/&gt;&lt;br/&gt;
接下来看一下plist文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;IsASCIICapable&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;PrefersRightToLeft&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;PrimaryLanguage&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;en-US&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;RequestsOpenAccess&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.keyboard-service&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPrincipalClass&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;KeyboardViewController&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要打开完全访问，需要设置&lt;code&gt;RequestsOpenAccess&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;。&lt;code&gt;IsASCIICapable&lt;/code&gt;指的是是否可以输入ascii字符，&lt;code&gt;PrefersRightToLeft&lt;/code&gt;是为从右向左的语言设置的。而&lt;code&gt;PrimaryLanguage&lt;/code&gt;是键盘的主语言，它的写法是&lt;code&gt;&amp;lt;language&amp;gt;-&amp;lt;REGION&amp;gt;&lt;/code&gt;。相应的语言和地区的值的定义在&lt;a href="http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c"&gt;这里&lt;/a&gt;。&lt;br/&gt;
Build&amp;amp;Run一下，我们的输入法就安装在系统了，使用前先在设置中启用，然后打开搜索，切换几下，就可以看到了:
&lt;img alt="keyboad" src="./imgs/20141119/keyboard.png"/&gt;&lt;/p&gt;
&lt;h3&gt;3 结束&lt;/h3&gt;
&lt;p&gt;至此，所有的extension都讲解完了，extension的基本原理贯穿在7中extension之中。Store上已经有很多实现extesnion的app，而且我发现实现了extension的app提交后在2个小时左右就能&lt;code&gt;waiting in review&lt;/code&gt;，所以开发者们要加油了。  &lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>Git版本库管理</title><link href="http://icocoa.tk/gitban-ben-ku-guan-li.html" rel="alternate"></link><updated>2014-11-18T10:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-18:gitban-ben-ku-guan-li.html</id><summary type="html">&lt;p&gt;在开发过程中往往会使用第三方库，可有时候会因为某种原因不使用了，我们可以使用 &lt;code&gt;reset&lt;/code&gt;或是直接删除的方式将库删除，比如开发中用到了某度的SDK，可是发现crash的概率太大需要舍弃之。可是，这些库的影子还在版本库的历史中可以找到，会增大库的体积。这时候我们就需要完全清楚这些“残留”文件。&lt;br/&gt;
本篇内容可在&lt;a href="http://www.amazon.cn/gp/product/B0058FLC40/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3132&amp;amp;creativeASIN=B0058FLC40&amp;amp;linkCode=as2&amp;amp;tag=scorpiozj-23"&gt;Git权威指南&lt;/a&gt;第14章中找到。&lt;/p&gt;
&lt;h4&gt;松散对象&lt;/h4&gt;
&lt;p&gt;Git中对于以SHA1值作为目录名和文件保存的对象称之为松散对象。因此 add，commit等操作都会产生一系列的松散对象。大量的松散对象会造成访问效率低下，占用过多存储空间。在Git中可以通过打包的方式提高访问效率，同时也方便通过增量更新的方式节省存储空间。&lt;/p&gt;
&lt;h4&gt;暂存区中的临时对象&lt;/h4&gt;
&lt;p&gt;添加到暂存区的文件发现不需要了，我们应该怎么办？
首先我们复制2个稍大的(10M)的文件到工作区，然后添加到暂存区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cp /Users/xxxxx/Desktop/test.zip bigfile
&lt;span class="nv"&gt;$ &lt;/span&gt;cp /Users/xxxxx/Desktop/test.zip bigfile.dup
&lt;span class="nv"&gt;$ &lt;/span&gt;git add bigfile bigfile.dup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查看工作区和版本库的大小：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh
31M .
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
10M .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为添加到库中的文件Git是以blob对象的形式存储，对于相同文件只存储一份，所以库的大小是10M。&lt;br/&gt;
查看添加后的对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们把添加的文件撤出暂存区： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reset HEAD
&lt;span class="nv"&gt;$ &lt;/span&gt;git status -s
?? bigfile
?? bigfile.dup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时再查看大小： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh
31M .
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
10M .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现大小并没有变化，这说明版本库中还保存着那个对象，可以通过&lt;code&gt;fsck&lt;/code&gt;命令查看：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling blob 5d1150e0e75f30161bba7799170c887d8f1104a0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要将这个文件从版本库彻底删除那么需要执行&lt;code&gt;prune&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git prune
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
172K    .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以看出版本库已经不包含文件对象&lt;/p&gt;
&lt;h4&gt;重置操作引入的对象&lt;/h4&gt;
&lt;p&gt;对于已经添加到版本库中的文件，又该如何清除相应的文件对象呢？我们还是添加2个文件并commit： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;"add bigfiles"&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="n"&gt;a5feb75&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;bigfiles&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;insertions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;deletions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="mi"&gt;100644&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;
&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="mi"&gt;100644&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查看文件对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
.git/objects//6b/ff29c5d2ae75913cb00de0887f6bc1e4dfbc31
.git/objects//a5/feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;git cat-file -t 5d11&lt;/code&gt;可以查看文件对象的类型，上述3个对象的类型分别为：树，提交，和blob。
接下来使用&lt;code&gt;reset&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reset --hard HEAD^
HEAD is now at 6652a0d Add Images &lt;span class="k"&gt;for&lt;/span&gt; git treeview.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在查看文件对象会发现还是存在上述的3个对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
.git/objects//6b/ff29c5d2ae75913cb00de0887f6bc1e4dfbc31
.git/objects//a5/feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时执行&lt;code&gt;fsck&lt;/code&gt;会发现没有找到未关联的对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然，所有的对象都是关联的，因为我们还可以撤销该次提交。要找到该文件对象，需要使用：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck --no-reflogs
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling commit a5feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于所有的记录都存储在&lt;code&gt;reflog&lt;/code&gt;中，所以我们需要清除&lt;code&gt;reflog&lt;/code&gt;，在这里需要注意：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; reflog expire --all&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt; git reflog&lt;/span&gt;
&lt;span class="x"&gt;6652a0d HEAD@&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;0}: reset: moving to HEAD^&lt;/span&gt;
&lt;span class="x"&gt;a5feb75 HEAD@&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;1}: commit: add bigfiles&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这只会清空90天前的数据，可以带&lt;code&gt;date&lt;/code&gt;参数来指定日期：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reflog expire --expire&lt;span class="o"&gt;=&lt;/span&gt;now --all
&lt;span class="nv"&gt;$ &lt;/span&gt;git reflog
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时记录全部清除，可以使用&lt;code&gt;fsck&lt;/code&gt;和&lt;code&gt;prune&lt;/code&gt;了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling commit a5feb75fd7255b0085b92448a14d2fae62ea75be
&lt;span class="nv"&gt;$ &lt;/span&gt;git prune
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
164K    .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;git gc&lt;/h4&gt;
&lt;p&gt;实际使用中很少使用&lt;code&gt;prune&lt;/code&gt;，而是使用&lt;code&gt;git gc&lt;/code&gt;，该命令可以执行一系列的优化：主要是打包文件，丢弃过期的历史，清除未关联的对象等等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; gc&lt;/span&gt;
&lt;span class="x"&gt;//将未关联的对象从打包文件中移出，成为松散文件&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; gc --expire=now&lt;/span&gt;
&lt;span class="x"&gt;//直接清除未关联的文件，释放存储空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际中，git的某些操作会自动执行&lt;code&gt;gc&lt;/code&gt;命令，因此不需要手动执行&lt;code&gt;gc&lt;/code&gt;进行版本库的清理了。&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>App Extension Study 3</title><link href="http://icocoa.tk/app-extension-study-3.html" rel="alternate"></link><updated>2014-11-14T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-14:app-extension-study-3.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;第一篇&lt;/a&gt;介绍了Extension的基本概念，Extension的运行周期，和containing app的数据共享等细节，&lt;a href="http://github.icocoa.tk/app-extension-study-2.html"&gt;第二篇&lt;/a&gt;介绍并实践了4种extension，而本篇就要介绍Sync和File Provider。 &lt;/p&gt;
&lt;h3&gt;2 Finder Sync (OS X)&lt;/h3&gt;
&lt;p&gt;因为extension要运行在10.10的OS X上，由于没升级，所以本节就侧重“理论”了。  &lt;/p&gt;
&lt;h4&gt;2.1 含义&lt;/h4&gt;
&lt;p&gt;顾名思义，就是保持本地的某些文件夹和远程的文件夹内容保持一致。它可以让用户在Finder实时察觉同步的状态并随时控制同步的进程。比如说可以在文件夹上加badge或是文字来告诉用户当前的状态，或是在Finder窗口添加工具栏方便打开监视的文件夹或强制退出同步(不知道网盘类的应用如何集成该extension呢)。因此，&lt;code&gt;Finder Sync&lt;/code&gt;的host app只能是&lt;code&gt;Finder&lt;/code&gt;。&lt;br/&gt;
&lt;code&gt;Finder Sync&lt;/code&gt;可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册一系列文件夹进行同步&lt;/li&gt;
&lt;li&gt;当用户打开/退出上述文件夹时会收到通知&lt;/li&gt;
&lt;li&gt;可以添加/移除/更新该文件夹上的badge&lt;/li&gt;
&lt;li&gt;在注册的文件夹内，通过control点击内容后会弹出文本彩蛋&lt;/li&gt;
&lt;li&gt;可以给Finder的工具栏添加按钮&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2.2模版文件&lt;/h4&gt;
&lt;p&gt;plist文件和widget中的类似，默认的类是&lt;code&gt;FIFinderSync&lt;/code&gt;子类，实现文件中预先生成的方法很好的解释了FinderSync的工作流程。&lt;br/&gt;
首先是&lt;code&gt;init&lt;/code&gt;,  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;instancetype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%s launched from %@ ; compiled at %s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__PRETTY_FUNCTION__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSBundle&lt;/span&gt; &lt;span class="n"&gt;mainBundle&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;bundlePath&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__TIME__&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Set up the directory we are syncing.&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myFolderURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="nl"&gt;fileURLWithPath&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"/Users/Shared/MySyncExtension Documents"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;directoryURLs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="nl"&gt;setWithObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myFolderURL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// Set up images for our badge identifiers. For demonstration purposes, this uses off-the-shelf images.&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeImage&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSImageNameColorPanel&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;label&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Status One"&lt;/span&gt; &lt;span class="nl"&gt;forBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"One"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeImage&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSImageNameCaution&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;label&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Status Two"&lt;/span&gt; &lt;span class="nl"&gt;forBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Two"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化函数中主要做的就是注册要同步的文件夹，可以是多个。通常指定的文件夹是在containing app中操作的，因此需要用到&lt;code&gt;share group&lt;/code&gt;来共享数据。所以，实际中会通过&lt;code&gt;NSUserDefaults&lt;/code&gt;来读取，然后再注册。除此之外，还可以进行badge等修饰。这里badge的图片里不能有padding(我的理解就是图片的内容都要顶边)，此外还有像素的限制：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retina屏： 12x12-320x320&lt;/li&gt;
&lt;li&gt;非retina屏： 8x8-160x160&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来就是实现一系列&lt;code&gt;FIFinderSync&lt;/code&gt;协议：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;beginObservingDirectoryAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// The user is now seeing the container's contents.&lt;/span&gt;
&lt;span class="c1"&gt;// If they see it in more than one view at a time, we're only told once.&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"beginObservingDirectoryAtURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户打开同步文件夹或其子文件夹时，调用此方法，查看的文件夹路径作为&lt;code&gt;url&lt;/code&gt;参数传入。&lt;br/&gt;
和打开香对应的，有关闭浏览同步文件夹的协议： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;endObservingDirectoryAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// The user is no longer seeing the container's contents.&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"endObservingDirectoryAtURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个协议，当同步文件夹里的内容要显示的时候，会调用：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;requestBadgeIdentifierForURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"requestBadgeIdentifierForURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// For demonstration purposes, this picks one of our two badges, or no badge at all, based on the filename.&lt;/span&gt;
&lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;whichBadge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;badgeIdentifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"One"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"Two"&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;whichBadge&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;badgeIdentifier&lt;/span&gt; &lt;span class="nl"&gt;forURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如例子所做的那样，文件夹内的每个内容显示的时候会调用该协议，然后extension根据一些条件(比如文件的名字等)来决定是否加badge以及加哪种badge。&lt;/p&gt;
&lt;p&gt;接下来就是菜单和工具栏相关的协议：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;menuForMenuKind:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FIMenuKind&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;whichMenu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Produce a menu for the extension.&lt;/span&gt;
    &lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="nl"&gt;addItemWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Example Menu Item"&lt;/span&gt; &lt;span class="nl"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;sampleAction&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="nl"&gt;keyEquivalent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;menu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现自定义的菜单就要实现该协议，根据不同的&lt;code&gt;FIMenuKind&lt;/code&gt;,提供不同的菜单。  &lt;/p&gt;
&lt;p&gt;接下来是在Finder窗口添加自定义的工具按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemName&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;@"FinderSynTest"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemToolTip&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;@"FinderSynTest: Click the toolbar item for a menu."&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemImage&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSImageNameCaution&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户点击按钮后，系统就会调用之前的&lt;code&gt;menuForMenuKind:&lt;/code&gt;方法，并把&lt;code&gt;FIMenuKindToolbarItemMenu&lt;/code&gt;类参数传入。&lt;/p&gt;
&lt;h4&gt;2.3 Finder Sync典型用例&lt;/h4&gt;
&lt;p&gt;因为同步文件夹内可以会有很多很多的内容，这时候效率就显得特别重要了。适时更新就显得尤为重要，简单的说就是lazy-load，需要用到的时候再去加载，可见的时候才有必要去更新。&lt;code&gt;Finder Sync&lt;/code&gt;的典型运作流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当打开同步文件夹或子文件夹时，系统调用&lt;code&gt;beginObservingDirectoryAtURL:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于要显示的每个子内容，系统调用&lt;code&gt;requestBadgeIdentifierForURL:&lt;/code&gt;，在这个方法里主要做：
    a. 检查每个子内容的状态，然后来调用&lt;code&gt;setBadgeIdentifier:forURL:&lt;/code&gt;，这里的状态由app自己来定义，比如：正在同步，同步出错，同步成功
    b. 对于设置badge的子内容，要记录下来。&lt;/li&gt;
&lt;li&gt;当关闭窗口时，调用&lt;code&gt;endObservingDirectoryAtURL:&lt;/code&gt;，删除所有在2.b中记录的内容，并停止检测文件夹的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 Document Provider&lt;/h3&gt;
&lt;h4&gt;3.1 Document Provider是什么&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Document Provider&lt;/code&gt;充当containing app管理的文件和其他 app 之间的“中介”，该中介可以让其他app &lt;code&gt;导入&lt;/code&gt;或是&lt;code&gt;打开&lt;/code&gt;文件，可以从服务器上&lt;code&gt;上传&lt;/code&gt;/&lt;code&gt;下载&lt;/code&gt;文件，也可以&lt;code&gt;导出&lt;/code&gt;/&lt;code&gt;移动&lt;/code&gt;文件到扩展的共享数据区。因此，&lt;code&gt;Document Provider&lt;/code&gt;由2个独立的extension组成：一个是&lt;code&gt;Document Picker View Controller extension&lt;/code&gt;(简称&lt;code&gt;picker extension&lt;/code&gt;)，另一个则是&lt;code&gt;File Provider extension&lt;/code&gt;(简称&lt;code&gt;provider extension&lt;/code&gt;)。前者负责将可供使用的文件展示给用户，后者则根据用户选择的类型(指导入，打开，导出，移动等4种类型)提供相应的服务。在host app中，通过&lt;code&gt;UIDocumentPickerViewController&lt;/code&gt;或是&lt;code&gt;UIDocumentMenuViewController&lt;/code&gt;调用&lt;code&gt;picker extension&lt;/code&gt;，extesnion根据实际需要把相关的文件呈现给用户，供用户选择；用户选择完毕后，有需要的话，再去运行&lt;code&gt;provider extension&lt;/code&gt;。这里说“有需要”是因为理想情况下，&lt;code&gt;Document Provide&lt;/code&gt;r最好支持上述4种类型，但不是必须。同时，只有打开和移动操作是一定要提供&lt;code&gt;provider extension&lt;/code&gt;的，因为导入导出操作可只与共享数据区进行数据交换：比如说只是备份文件。&lt;br/&gt;
需要注意的是，iCloud也“集成”了该类型的扩展，就是说如果app启用了icloud，那么可以查看icloud的文件并选择操作。启用iCloud需要在plist文件中添加类似如下的属性：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainers&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;iCloud.com.example.MyApp&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;true/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerSupportedFolderLevels&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Any&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerName&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MyApp&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 picker extension&lt;/h4&gt;
&lt;p&gt;新建一个&lt;code&gt;File Provider&lt;/code&gt;，在导航上就可以看到Xcode会提供是否要创建&lt;code&gt;provider extension&lt;/code&gt;的选项，一并勾上，然后来观察程序创建了2个target。先看&lt;code&gt;picker extension&lt;/code&gt;的plist文件： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;UIDocumentPickerModes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeImport&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeOpen&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeExportToService&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeMoveToService&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;UIDocumentPickerSupportedFileTypes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;public.content&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.fileprovider-ui&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;键&lt;code&gt;UIDocumentPickerModes&lt;/code&gt;设置了支持的操作类型，而&lt;code&gt;UIDocumentPickerSupportedFileTypes&lt;/code&gt;则设置了支持的文件类型，&lt;code&gt;public.content&lt;/code&gt;说明支持所有的文件。
再来看模版文件，可以看到&lt;code&gt;picker extension&lt;/code&gt;的实现是继承&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt;的子类，下图是&lt;code&gt;picker extension&lt;/code&gt;的示例界面：&lt;br/&gt;
&lt;img alt="picker_ui" src="./imgs/20141117/picker_ui.png"/&gt;&lt;/p&gt;
&lt;p&gt;顶部的Bar是系统提供的，程序内无法自定义。左边的location是切换不同的文件来源，因为iPhone上可以安装多个提供了document provider的containing app。Bar下面的部分就是可以定制的picker extension的界面，完全在&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt;中自定义。&lt;br/&gt;
picker extension的生命周期：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;host app弹出&lt;code&gt;UIDocumentMenuViewController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用户选择了你的&lt;code&gt;picker extension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化&lt;code&gt;UIDocumentPickerViewExtensionViewController&lt;/code&gt;子类&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;方法，根据&lt;code&gt;UIDocumentPickerMode&lt;/code&gt;，展示不同的界面&lt;/li&gt;
&lt;li&gt;此时，extension的界面已经在host app中展示好&lt;/li&gt;
&lt;li&gt;当用户选择后，extension做相应的操作，然后&lt;em&gt;必须&lt;/em&gt;调用&lt;code&gt;dismissGrantingAccessToURL:&lt;/code&gt;方法推出界面，并把文件的URL作为参数传递给host app，以便host app执行代理：&lt;code&gt;-[UIDocumentPickerViewControllerDelegate documentPicker:didPickDocumentAtURL:]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt; 消失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见，实现&lt;code&gt;picker extension&lt;/code&gt;的关键就是重载&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;以及调用&lt;code&gt;dismissGrantingAccessToURL:&lt;/code&gt;。前者是负责界面，后者是负责用户操作的响应。前者主要关心不同类型的界面展示，比如导出操作和打开不一样，肯定要有一个导出场所。其他的需求例如是只显示支持的文件类型还是显示所有类型但标记不支持的文件类型等，也是在&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;中实现。而相应的，以及调用&lt;code&gt;dismissGrantingAccessToURL&lt;/code&gt;就是退出extension的必须，这个只是调用而不用重载。传递的URL参数代表用户选中的文件类型。根据不同的操作类型，URL参数有不同的要求： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入：本地文件类型。如果选择的是远程服务器上的文件，那么需要先下载到本地方能调用dismiss&lt;/li&gt;
&lt;li&gt;打开：如果指定的文件不存在，&lt;code&gt;provider extension&lt;/code&gt;会去创建。该地址必须是位于&lt;code&gt;provider extension&lt;/code&gt;属性&lt;code&gt;documentStorageURL&lt;/code&gt;指定的文件夹路径下面&lt;/li&gt;
&lt;li&gt;导出：只有&lt;code&gt;picker extension&lt;/code&gt;可以访问的URL，系统会在该URL下复制一份文件并返回给host app，表明导出操作成功。但是，host app无法通过该URL访问文件&lt;/li&gt;
&lt;li&gt;移动：和打开类型一样，位于&lt;code&gt;documentStorageURL&lt;/code&gt;下面，系统会将文件移动到该URL，并把URL返回给host app，但此时host app可以访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，如果涉及到用户授权，可以在extension中实现，也可以使用通知的方式在containing app中实现。&lt;/p&gt;
&lt;h4&gt;3.3 provider extension&lt;/h4&gt;
&lt;p&gt;如果picker提供打开和导出功能，那么就一定要实现&lt;code&gt;provider extension&lt;/code&gt;。provider可以在host app之外打开/移动文件，可以让host app下载文件。&lt;br/&gt;
对于远程未下载的文件，&lt;code&gt;provider extension&lt;/code&gt;是用&lt;code&gt;placeholder&lt;/code&gt;代替，通过&lt;code&gt;fileCoordinator&lt;/code&gt;实现读写。文件的变化会以通知的方式传递给extension，以便作出相应的变化。&lt;br/&gt;
接下来还是先看plist文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionFileProviderDocumentGroup&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.devpubs&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.fileprovider-nonui&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPrincipalClass&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;FileProvider&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;NSExtensionFileProviderDocumentGroup&lt;/code&gt;定义了可以访问的组，该值也同样在entitle文件中声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;com.apple.security.application-groups&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.devpubs&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着看代码，实现部分是&lt;code&gt;NSFileProviderExtension&lt;/code&gt;的子类，该类的头文件中着重注明了2个类只能调用不需要重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;BOOL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;writePlaceholderAtURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderURL&lt;/span&gt; &lt;span class="nt"&gt;withMetadata&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSDictionary&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;metadata&lt;/span&gt; &lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;**)&lt;/span&gt;&lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderURLForURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要作用是为未下载的文件创建&lt;code&gt;placeholder&lt;/code&gt;，&lt;code&gt;metadata&lt;/code&gt;通常包含文件大小，名字以及缩略图。
接下来是必须重载的方法，模版文件中主要有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;providePlaceholderAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nf"&gt;completionHandler:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Should call + writePlaceholderAtURL:withMetadata:error: with the placeholder URL, then call the completion handler with the error if applicable.&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="n"&gt;lastPathComponent&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSFileProviderExtension&lt;/span&gt; &lt;span class="nl"&gt;placeholderURLForURL&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;documentStorageURL&lt;/span&gt; &lt;span class="nl"&gt;URLByAppendingPathComponent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;

    &lt;span class="n"&gt;NSUInteger&lt;/span&gt; &lt;span class="n"&gt;fileSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// TODO: get file size for file at &amp;lt;url&amp;gt; from model&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="bp"&gt;NSDictionary&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@{&lt;/span&gt; &lt;span class="nl"&gt;NSURLFileSizeKey&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;fileSize&lt;/span&gt;&lt;span class="l"&gt;)}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSFileProviderExtension&lt;/span&gt; &lt;span class="nl"&gt;writePlaceholderAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="nl"&gt;withMetadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;startProvidingItemAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nf"&gt;completionHandler:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Should ensure that the actual file is in the position returned by URLForItemWithIdentifier:, then call the completion handler&lt;/span&gt;
    &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;__block&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileError&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="bp"&gt;NSData&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSData&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// TODO: get the contents of file at &amp;lt;url&amp;gt; from model&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fileData&lt;/span&gt; &lt;span class="nl"&gt;writeToURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fileError&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileError&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当文件开始读取的时候，上述2个方法都会被触发。触发的先后视情况而定。和iCloud一样，操作文件是使用&lt;code&gt;NSFileCoordinator&lt;/code&gt;。对于未下载的情形，第一个方法首先执行，在该方法中首先创建&lt;code&gt;placeholder&lt;/code&gt;，然后调用&lt;code&gt;coordinate&lt;/code&gt;方法写文件，最后务必调用&lt;code&gt;completionHandler&lt;/code&gt;。第二个方法执行的内容和第一个差不多，只是不需要创建&lt;code&gt;placeholder&lt;/code&gt;，所以这里要注意确认url指定的路径下，文件是否存在。
接下来就是文件有变化时，收到的通知：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;itemChangedAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Called at some point after the file has changed; the provider may then trigger an upload&lt;/span&gt;

    &lt;span class="c1"&gt;// TODO: mark file at &amp;lt;url&amp;gt; as needing an update in the model; kick off update process&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Item changed at URL %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，需要自行设计，文件变化后尤其是产生冲突后的处理。&lt;/p&gt;
&lt;p&gt;最后一个就是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;stopProvidingItemAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Called after the last claim to the file has been released. At this point, it is safe for the file provider to remove the content file.&lt;/span&gt;
    &lt;span class="c1"&gt;// Care should be taken that the corresponding placeholder file stays behind after the content file has been deleted.&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSFileCoordinatorWritingForDeleting&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSFileManager&lt;/span&gt; &lt;span class="n"&gt;defaultManager&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;removeItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;providePlaceholderAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法是系统检测到没有进程调用该文件时触发的，这里可以把文件从共享区域中删除以节省空间。 
另外还有4个方法可以重载：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;An&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt; &lt;span class="nt"&gt;unique&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;provider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;When&lt;/span&gt; &lt;span class="nt"&gt;modifying&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;files&lt;/span&gt; &lt;span class="nt"&gt;stored&lt;/span&gt; &lt;span class="nt"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;directory&lt;/span&gt; &lt;span class="nt"&gt;returned&lt;/span&gt; &lt;span class="nt"&gt;by&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;you&lt;/span&gt; &lt;span class="nt"&gt;should&lt;/span&gt; &lt;span class="nt"&gt;pass&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;your&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt; &lt;span class="nt"&gt;coordinator&lt;/span&gt;&lt;span class="s1"&gt;'s setPurposeIdentifier: method.&lt;/span&gt;
&lt;span class="s1"&gt;// By default, this returns the bundle identifier of the application containing your extension. You need to make sure to use the same identifier in your containing app.&lt;/span&gt;
&lt;span class="s1"&gt;- (NSString *)providerIdentifier;&lt;/span&gt;

&lt;span class="s1"&gt;// The root URL for provided documents. This URL must be writable from your app extension, and must only be used for the extension'&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt; &lt;span class="nt"&gt;files&lt;/span&gt; &lt;span class="nt"&gt;or&lt;/span&gt; &lt;span class="nt"&gt;their&lt;/span&gt; &lt;span class="nt"&gt;placeholders&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;Should&lt;/span&gt; &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;URL&lt;/span&gt; &lt;span class="nt"&gt;corresponding&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;specific&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;Fail&lt;/span&gt; &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt; &lt;span class="nt"&gt;not&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;subpath&lt;/span&gt; &lt;span class="nt"&gt;of&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;This&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;each&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt; &lt;span class="nt"&gt;must&lt;/span&gt; &lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;corresponding&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;same&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;By&lt;/span&gt; &lt;span class="nt"&gt;default&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;returns&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;relative&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;returned&lt;/span&gt; &lt;span class="nt"&gt;by&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;URLForItemWithPersistentIdentifier&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;persistentIdentifierForItemAtURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是因为通常情况下，重载这些方法会影响到plist和entitlement中的设置，所以一般情况下也可以认为是不需要重载的。&lt;br/&gt;
需要说明的是，文档中指出如果在8.0上使用了&lt;code&gt;iCloud Drive&lt;/code&gt;，那么访问文件需要使用&lt;code&gt;UIDocument&lt;/code&gt;或是&lt;code&gt;NSFileProviderExtension&lt;/code&gt;，而不要使用&lt;code&gt;NSFileCoordinator&lt;/code&gt;。
最后WWDC2014中有一个&lt;a href="http://adcdownload.apple.com//wwdc_2014/wwdc_2014_sample_code/newboxanintroductiontoiclouddocumentenhancementsinios8.0.zip"&gt;示例&lt;/a&gt;，可以下载后研究下。&lt;/p&gt;
&lt;h3&gt;End&lt;/h3&gt;
&lt;p&gt;以上介绍了&lt;code&gt;Finder Sync&lt;/code&gt;和&lt;code&gt;File Provider&lt;/code&gt;的，还剩下&lt;code&gt;Custom Keyboard&lt;/code&gt;，下文完结。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>Pelican若干问题汇总</title><link href="http://icocoa.tk/pelicanruo-gan-wen-ti-hui-zong.html" rel="alternate"></link><updated>2014-11-09T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-09:pelicanruo-gan-wen-ti-hui-zong.html</id><summary type="html">&lt;p&gt;前几天感冒，鼻塞导致做任何事情都没有精力，只能花点时间整理pelican使用中遇到的一些问题。&lt;/p&gt;
&lt;h4&gt;WARNING: No valid files found in content.&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;fab build&lt;/code&gt;后命令行中出现如下的警告:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[localhost] local: pelican -s pelicanconf.py
WARNING: No valid files found in content.
WARNING: Could not process content/output/archives.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/authors.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/categories.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/index.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/tags.html
'NoneType' object has no attribute 'lower'
Done: Processed 18 articles and 0 pages in 2.23 seconds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然生成了文章，但总感觉怪怪的。也许是强迫症，不过修改这个警告也让我学会了一些东西。&lt;br/&gt;
首先确认了&lt;code&gt;md&lt;/code&gt;文件中语法格式没有问题，接下来重新安装了&lt;code&gt;markdown&lt;/code&gt;，&lt;code&gt;pelican&lt;/code&gt;和&lt;code&gt;Fabric&lt;/code&gt;，确保不是软件引起的问题。更新后，警告依然存在，于是google，第一页出现了很多强相关性的链接，专注github上的issue。先找的是&lt;a href="https://github.com/getpelican/pelican/issues/1097"&gt;issue 1097&lt;/a&gt;，尝试运行&lt;code&gt;pelican --debug&lt;/code&gt;，发现没有有效的提示信息。再看&lt;a href="https://github.com/getpelican/pelican/issues/1116"&gt;issue 1116&lt;/a&gt;，这个帖子的方法是修改&lt;code&gt;fabfile.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;build&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="kd"&gt;local&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'pelican content/ -s pelicanconf.py'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;regenerate&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="kd"&gt;local&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'pelican content/ -r -s pelicanconf.py'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;照做然后&lt;code&gt;build&lt;/code&gt;后，警告消失了，此外还把page不生成的问题解决了&lt;/p&gt;
&lt;h4&gt;Pages不生成&lt;/h4&gt;
&lt;p&gt;在content文件夹下添加了&lt;code&gt;pages&lt;/code&gt;文件夹，写入了一些md文件，但发现总是生成不了。一度怀疑是pages中的md文件需要独特的语法：比如有特定的metadata需要写入，或是选用的主题不支持pages。当折腾大半天的时候，却发现上述的警告产生的原因也是该问题产生的凶手！顺便说一下，该问题也导致&lt;code&gt;disqus&lt;/code&gt;评论系统加载不上去。&lt;br/&gt;
所以，千万不要忽视警告，尤其是让人觉得不影响最终运行的情况。&lt;/p&gt;</summary><category term="python"></category><category term="pelican"></category></entry><entry><title>文件权限</title><link href="http://icocoa.tk/wen-jian-quan-xian.html" rel="alternate"></link><updated>2014-11-09T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-09:wen-jian-quan-xian.html</id><summary type="html">&lt;h4&gt;权限&lt;/h4&gt;
&lt;p&gt;Linux系统中对文件/目录的权限设置是很重要的部分，通常通过&lt;code&gt;ls&lt;/code&gt;来查看：
    ls -l README
    -rw-r--r--   1 xxxx  staff    234 Nov  9 11:27 README
说明：&lt;br/&gt;
第一列就是权限，有10位，从左至右第一位表示文件的类型，&lt;strong&gt;-__表示是文件，__d__表示是目录。接下来的9位分成3组，分别对应文件拥有者，共享文件所在组以及其他用户拥有的权限。__r__表示可读，__w__表示可写，__x__表示可执行，&lt;/strong&gt;-__表示没有该项权限。&lt;br/&gt;
第二列数字1表示索引节点的目录连接。
第三列就是文件拥有者的名字，第四列则是共享文件所在组。
第五列是文件的字节数，第六、七、八列是时间，最后一列是名字。
其中文件权限可以用二进制表达，该例对应的则是： &lt;code&gt;110100100&lt;/code&gt;，用十进制表达则是： &lt;code&gt;644&lt;/code&gt;。因此，有时候修改权限 &lt;code&gt;777&lt;/code&gt;的时候，就一定要小心了，要么是小白行为，要么就是带有恶意。  &lt;/p&gt;
&lt;h4&gt;SUID/SGID&lt;/h4&gt;
&lt;p&gt;通常情况下，执行一个程序时，相应的进程具有&lt;strong&gt;执行这一程序的用户&lt;/strong&gt;的权限，但有时这并没有赋予进程正确完成任务所必要的权限。这个时候，可以直接修改文件权限以满足程序的运行，但是这样可能会对系统安全造成伤害。Linux系统的解决办法是设置SUID/SGID使得用户分别以&lt;em&gt;程序拥有者&lt;/em&gt;或&lt;em&gt;用户组&lt;/em&gt;的权限，而不是它自己的权限去运行程序。&lt;br/&gt;
这里SUID代表 "set user ID"，SGID则代表 "set group ID"，同时设置SUID和SGID的话，SUID的优先级高。&lt;br/&gt;
设置的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod u+s filename //设置SUID位
chmod u-s filename //去掉SUID设置
chmod g+s filename //设置SGID位
chmod g-s filename //去掉SGID设置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ls -l
total 8
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; xxxxxx  staff  &lt;span class="m"&gt;3&lt;/span&gt; Nov  &lt;span class="m"&gt;9&lt;/span&gt; 16:51 hello
&lt;span class="nv"&gt;$ &lt;/span&gt;chmod u+s hello 
&lt;span class="nv"&gt;$ &lt;/span&gt;ls -l
total 8
-rwSr--r--  &lt;span class="m"&gt;1&lt;/span&gt; xxxxxx  staff  &lt;span class="m"&gt;3&lt;/span&gt; Nov  &lt;span class="m"&gt;9&lt;/span&gt; 16:51 hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为原本的拥有者不具备&lt;code&gt;x&lt;/code&gt;权限，所以设置后显示&lt;code&gt;S&lt;/code&gt;；如果有对应的 &lt;code&gt;x&lt;/code&gt;权限，设置后则会显示 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;</summary><category term="security"></category></entry><entry><title>iOS8下控件的旋转</title><link href="http://icocoa.tk/ios8xia-kong-jian-de-xuan-zhuan.html" rel="alternate"></link><updated>2014-11-07T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-07:ios8xia-kong-jian-de-xuan-zhuan.html</id><summary type="html">&lt;h4&gt;由起&lt;/h4&gt;
&lt;p&gt;使用iOS8 SDK编译后的项目在ipad上运行发现某些控件如HUD弹出后它的位置有了旋转，但是该现象在iOS8的iphone设备上却没有出现。果断认为是iOS8SDK引起的，需要做紧急修复。&lt;/p&gt;
&lt;h4&gt;修复&lt;/h4&gt;
&lt;p&gt;代码中迅速找到&lt;code&gt;rotation&lt;/code&gt;的相关部分，发现已经是使用&lt;code&gt;[[UIApplication sharedApplication] statusBarOrientation]&lt;/code&gt;，那应该不会是方向获取错误导致的。那姑且以为是iPad上特有的现象，于是加了设备的判断，测试通过！可惜在iOS7的iPad上还是有问题，正当烦恼之际，突然想起之前的某个&lt;a href="https://github.com/wimagguc/ios-custom-alertview/issues/50"&gt;issue&lt;/a&gt;，果然是同样的问题，最终的解决方案是: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if (floor(NSFoundationVersionNumber) &amp;lt;= NSFoundationVersionNumber_iOS_7_1)
    {
        switch (interfaceOrientation) {
            case UIInterfaceOrientationLandscapeLeft:
                self.transform = CGAffineTransformMakeRotation(M_PI * 270.0 / 180.0);
                break;

            case UIInterfaceOrientationLandscapeRight:
                self.transform = CGAffineTransformMakeRotation(M_PI * 90.0 / 180.0);
                break;

            case UIInterfaceOrientationPortraitUpsideDown:
                self.transform = CGAffineTransformMakeRotation(M_PI * 180.0 / 180.0);
                break;

            default:
                break;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题最终解决，不过这个bug倒是满奇怪的，希望给遇到同样问题的人一个帮助。&lt;/p&gt;</summary><category term="ios8"></category></entry><entry><title>iOS8之UIAlertController</title><link href="http://icocoa.tk/ios8zhi-uialertcontroller.html" rel="alternate"></link><updated>2014-11-05T11:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-05:ios8zhi-uialertcontroller.html</id><summary type="html">&lt;h4&gt;由起&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UIAlertController&lt;/code&gt;是iOS8中引入的，用于整合&lt;code&gt;UIAlertView&lt;/code&gt;和&lt;code&gt;UIActionSheet&lt;/code&gt;的新类，在实现中抛弃了之前的delegate用法，而采用了block的方式，从而使得使用和可读性都简化了不少。&lt;br/&gt;
使用iOS8SDK编译的项目，大多数情况使用之前的&lt;code&gt;UIAlertView&lt;/code&gt;或&lt;code&gt;UIActionSheet&lt;/code&gt;都不会产生问题，如果有问题了，那就需要使用新类了。比如，一个项目中iPad上调用&lt;code&gt;[actionSheet showFromToolbar:]&lt;/code&gt;产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2014-11-05 10:50:26.614 XXXXXX[467:78104] Presenting view controllers on detached view controllers is discouraged &amp;lt;UIViewController: 0x17ea3470&amp;gt;.
2014-11-05 10:50:26.762 XXXXXX[467:78104] *** Terminating app due to uncaught exception 'NSGenericException', reason: 'Your application has presented a UIAlertController (&amp;lt;UIAlertController: 0x17e73620&amp;gt;) of style UIAlertControllerStyleActionSheet. The modalPresentationStyle of a UIAlertController with this style is UIModalPresentationPopover. You must provide location information for this popover through the alert controller's popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem.  If this information is not known when you present the alert controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从奔溃日志中可以看出，虽然代码中使用的是&lt;code&gt;UIActionSheet&lt;/code&gt;，实际运行时却已经是&lt;code&gt;UIAlertController&lt;/code&gt;了。&lt;/p&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;p&gt;使用非常简单，基本用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//初始化alert controller&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertController&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertController&lt;/span&gt; &lt;span class="nl"&gt;alertControllerWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"xxxx"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;message&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;preferredStyle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertControllerStyleActionSheet&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//创建一个操作&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fileAction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="nl"&gt;actionWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"action1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;style&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertActionStyleDefault&lt;/span&gt; &lt;span class="nl"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;doAction1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="c1"&gt;//添加操作&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;addAction&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fileAction&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cancelAction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="nl"&gt;actionWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Cancel"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;style&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertActionStyleCancel&lt;/span&gt; &lt;span class="nl"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;addAction&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;cancelAction&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;//展示alert controller   &lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;presentViewController&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;animated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;YES&lt;/span&gt; &lt;span class="nl"&gt;completion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化controller的时候，通过&lt;code&gt;UIAlertActionStyle&lt;/code&gt;来选择哪种式样，然后就创建一系列action，并添加到controller，最后把controller用present的方式展示出来。对于以前alert上带文字的式样，新API也贴心的提供了&lt;code&gt;addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler&lt;/code&gt;方法来简化操作。  &lt;/p&gt;
&lt;p&gt;可见，新API最大的特点无疑就是吸取了开源社区中已有的block的实现，这样最大限度的简化了代码，并且带来了无与伦比的可读性。由于新API中action的初始化是类方法，如果action不作为类成员的话，也不需要考虑block的循环引用问题。&lt;/p&gt;
&lt;h4&gt;结束&lt;/h4&gt;
&lt;p&gt;iOS8对API的更新还是挺大的，比如&lt;code&gt;UIPopoverViewController&lt;/code&gt;兼容iPad和iPhone，所以可以慢慢的开始更新了。&lt;/p&gt;
&lt;h4&gt;紧急修正&lt;/h4&gt;
&lt;p&gt;经过测试，在ipad上的使用还需要注意一个&lt;strong&gt;问题&lt;/strong&gt;，那就是在present之前要设置&lt;code&gt;UIAlertController&lt;/code&gt;的属性&lt;code&gt;popoverPresentationController&lt;/code&gt;。该属性是&lt;code&gt;UIPopoverPresentationController&lt;/code&gt;类，主要用途就是管理popover中的内容。如果不设置，在iPad竖屏测试的时候没有问题，但是在横屏的时候就会有问题。原因在于，横屏的时候，popover没有指定位置。这时，可以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;UIPopoverPresentationController *popoverPresentationController = alertController.popoverPresentationController;        
popoverPresentationController.barButtonItem = (UIBarButtonItem *)sender;
//或
popoverPresentationController.sourceView = (UIButton *)sender;
popoverPresentationController.sourceRect = [(UIButton *)sender bounds];
&lt;/pre&gt;&lt;/div&gt;</summary><category term="ios8"></category></entry><entry><title>git revert &amp;&amp; svn revert的不同</title><link href="http://icocoa.tk/git-revert-svn-revertde-bu-tong.html" rel="alternate"></link><updated>2014-11-03T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-03:git-revert-svn-revertde-bu-tong.html</id><summary type="html">&lt;p&gt;最近在看git，注意到revert命令，不禁想起svn的revert。于是把两者的功能进行了对比，以加深命令的理解。&lt;/p&gt;
&lt;h4&gt;git revert&lt;/h4&gt;
&lt;p&gt;对应的中文术语叫反转提交，基本的用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git revert commit-ish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令运行后会新加一个提交，该提交的内容即commit-ish所指向提交的父提交，此时版本库的内容“回退”到之前的某个版本。注意在运行本命令前，当前工作区不能有未提交的改动。&lt;/p&gt;
&lt;h4&gt;svn revert&lt;/h4&gt;
&lt;p&gt;svn中revert即回滚，基本用法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;svn revert PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中PATH可以是单个文件，也可以是文件夹。如果是文件夹的话，就需要用-R参数，表示递归执行。执行完命令后，本地文件的所有修改都被放弃，所以此时执行时不需要联网。&lt;/p&gt;
&lt;h4&gt;svn实现git revert的功能&lt;/h4&gt;
&lt;p&gt;如果要向用svn实现git revert的功能那么就需要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;svn update
//确保版本库最新
svn log
//找到想要“回复”的版本号
svn merge -r currentID:revertID PATH
//回滚到revertID所代表的版本
svn commit -m "message"
//确认后提交
&lt;/pre&gt;&lt;/div&gt;</summary><category term="revert"></category><category term="git"></category><category term="svn"></category></entry><entry><title>App Extension Study 2</title><link href="http://icocoa.tk/app-extension-study-2.html" rel="alternate"></link><updated>2014-10-31T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-31:app-extension-study-2.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;上一篇&lt;/a&gt;介绍了Extension的基本概念，Extension的运行周期，和containing app的数据共享等细节，这节开始实践。需要说明的本文不会覆盖所有类型，比如&lt;strong&gt;Finder Sync&lt;/strong&gt;类型是OS X独有的，这里会一带而过。&lt;/p&gt;
&lt;h3&gt;2 Widget&lt;/h3&gt;
&lt;p&gt;Widget就是Today extension，这个大家比较熟悉：下拉通知中显示的股票信息就是一个widget。从这里我们也可以看出widget的特点：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以自定义UI&lt;/li&gt;
&lt;li&gt;必定和containing app有着数据共享&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;2.1 widget 工程模版&lt;/h4&gt;
&lt;p&gt;在已有工程中新建一个target，选择&lt;code&gt;Application Extension&lt;/code&gt;中的&lt;code&gt;Today Extension&lt;/code&gt;，这时工程中增加了如下文件：&lt;br/&gt;
&lt;img alt="widgetImg" src="./imgs/20141031/widget_template.png"/&gt;&lt;br/&gt;
先来看&lt;code&gt;Info.plist&lt;/code&gt;，主要增加了NSExtenstion的key，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.widget-extension&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和app一样，如果不需要使用默认提供的sb文件，那么可以删除&lt;code&gt;NSExtensionMainStoryboard&lt;/code&gt;属性，然后添加&lt;code&gt;NSExtensionPrincipalClass&lt;/code&gt;。&lt;br/&gt;
上面说过widget必定会和containing app进行数据交互，那么我们必须同时开启containing app和widget的&lt;code&gt;App Groups&lt;/code&gt;功能。打开的方式：选中target-&amp;gt;Capabilities-&amp;gt;App Groups。 当你开启后，Xcode6会联网帮你进行一些操作，然后你需要做的就是给App Groups取一个名字，这个名字必须以group开头，建议后面的部分还是用反域名的结构。注意containing和widget的group名字得是一样的，不然就不能进行数据的共享。&lt;br/&gt;
接下来，我们看&lt;code&gt;TodayViewController&lt;/code&gt;，这是&lt;code&gt;UIViewController&lt;/code&gt;的子类，同时实现了&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议。它的实现文件模版中有3个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;viewDidLoad&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;viewDidLoad&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// Do any additional setup after loading the view from its nib.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;didReceiveMemoryWarning&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;didReceiveMemoryWarning&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// Dispose of any resources that can be recreated.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nl"&gt;widgetPerformUpdateWithCompletionHandler&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;NCUpdateResult&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="n"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Perform any setup necessary in order to update the view.&lt;/span&gt;
  &lt;span class="c1"&gt;// If an error is encountered, use NCUpdateResultFailed&lt;/span&gt;
  &lt;span class="c1"&gt;// If there's no update required, use NCUpdateResultNoData&lt;/span&gt;
  &lt;span class="c1"&gt;// If there's an update, use NCUpdateResultNewData&lt;/span&gt;
  &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NCUpdateResultNewData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中最后一个就是&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议，该协议的作用：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在通知中心可见或者在后台的情况下，系统会在合适的时候更新widget&lt;/li&gt;
&lt;li&gt;&lt;code&gt;completionHandler&lt;/code&gt;必须要执行，同时根据运行情况选择合适的&lt;code&gt;NCUpdateResult&lt;/code&gt;作为参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，文档中还说系统会不时的对widget进行截屏，这样当widget可见的时候，widget会将最近的截屏先显示出来，然后再用最新的实时的view替换。从这个意义上说，对于股票类的widget适时的刷新页面就很有必要。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议还包括： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;UIEdgeInsets&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;widgetMarginInsetsForProposedMarginInsets&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;UIEdgeInsets&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;defaultMarginInsets&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以让你自由选择widget四周对齐处的间距。&lt;/p&gt;
&lt;h4&gt;2.2 widget的设计&lt;/h4&gt;
&lt;p&gt;可以在sb文件中设计你的widget页面，作为一个简单的演示，我们设计一个直接显示文字的widget。你可以在containing app中设计一个&lt;code&gt;UITextField&lt;/code&gt;，把输入保存到share group中。然后在widget中读取，并显示在&lt;code&gt;UILabel&lt;/code&gt;中。核心的读写操作一并演示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                    &lt;span class="nl"&gt;initWithSuiteName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"group.xxxxxx"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;setObject&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;detailItem&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"nameKey"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;objectForKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"nameKey"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;苹果建议widget的UI不要使用scrollview，因为所有的widget都是在一个scrollview中，嵌套使用scrollview有多大的不爽想必可想而知，所以尺寸大小需要变化的就直接通过view的大小来实现。当然，如果是横向的scrollview会好一点，不过也建议不要放置太多的内容。因为widget本身就包含着信息一目了然，如果需要用户进行操作，就会拖累widget的体验&lt;/p&gt;
&lt;h4&gt;2.3 widget的显示&lt;/h4&gt;
&lt;p&gt;有时候，当没有可用数据的时候，我们可以控制widget是否显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NCWidgetController&lt;/span&gt; &lt;span class="n"&gt;widgetController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setHasContent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NO&lt;/span&gt; &lt;span class="nl"&gt;forWidgetWithBundleIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"com.XXXXXX"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就能隐藏widget而不显示。&lt;/p&gt;
&lt;h4&gt;2.4 打开contaning app&lt;/h4&gt;
&lt;p&gt;使用URL scheme，首先需要在containing中定义一个scheme，例如: extest，然后在widget中使用&lt;code&gt;extensionContext&lt;/code&gt;属性打开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[self.extensionContext openURL:[NSURL URLWithString:@"extest://"]&lt;/span&gt;
             &lt;span class="err"&gt;completionHandler:^(BOOL&lt;/span&gt; &lt;span class="err"&gt;success)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;}]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.5 编辑&lt;/h4&gt;
&lt;p&gt;OS X上支持widget的编辑，iOS上不支持&lt;/p&gt;
&lt;h3&gt;3 Share&lt;/h3&gt;
&lt;p&gt;Share侧重内容的分享，那么可以猜测有两点需要关注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分享类型/内容如何确定&lt;/li&gt;
&lt;li&gt;分享任务的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.1 Share 模版文件&lt;/h3&gt;
&lt;p&gt;Share extension的添加和widget类似，添加后还是先打开info.plist文件，如何添加如下的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话，Share就可以支持图片/视频/URL，后面的数字代表可以支持的数目。&lt;/p&gt;
&lt;h4&gt;3.2 发送内容&lt;/h4&gt;
&lt;p&gt;完成了上述步骤后，我们安装这个action，并用Photos应用打开该action:
&lt;img alt="share_extension" src="./imgs/20141031/share_extension.png"/&gt; &lt;/p&gt;
&lt;p&gt;如图所示，Share extension会弹出一个对话框视图，视图上有文字输入的地方和Post/Cancel的按钮。回到工程可以发现Share的视图父类是&lt;code&gt;SLComposeServiceViewController&lt;/code&gt;，它定义了一系列方法让子类去重载。重要的而且通常需要实现的一些方法已经定义在模版里，我们逐个来看一下。
首先第一个就是&lt;code&gt;isContentValid&lt;/code&gt;，该方法是用于检查用户输入的有效性(主要指输入字符长度检查)，典型的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;isContentValid&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="c1"&gt;// Do validation of contentText and/or NSExtensionContext attachments here&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;messageLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt;
                                &lt;span class="nl"&gt;stringByTrimmingCharactersInSet&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSCharacterSet&lt;/span&gt; &lt;span class="n"&gt;whitespaceCharacterSet&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;messageLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt;&lt;span class="l"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是&lt;code&gt;didSelectPost&lt;/code&gt;，这是点击Post调用的方法，典型实现：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;didSelectPost&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Perform the post operation.&lt;/span&gt;
&lt;span class="c1"&gt;// When the operation is complete (probably asynchronously), the Share  extension should notify the success or failure, as well as the items that   were actually shared.&lt;/span&gt;
  &lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inputItems&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedContentText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSAttributedString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;initWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt; &lt;span class="nl"&gt;attributes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Complete this implementation by setting the appropriate value on the output item.&lt;/span&gt;
    &lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt; &lt;span class="nl"&gt;completeRequestReturningItems&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt;
 &lt;span class="nl"&gt;expirationHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;completion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Or call [super didSelectPost] to use the superclass's default completion     behavior. &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法里要做几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传任务：使用&lt;code&gt;NSURLSession&lt;/code&gt;把图片(或其他媒体)和文字存储到服务器&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;completeRequestReturningItems:myOutputItems expirationHandler:nil completion:nil&lt;/code&gt;通知host app完成了上传请求&lt;/li&gt;
&lt;li&gt;准备好随时被系统终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来是&lt;code&gt;configurationItems&lt;/code&gt;，该方法是返回一个&lt;code&gt;SLComposeSheetConfigurationItem&lt;/code&gt;对象的数组。如果实现了该方法，那么弹出的UI的最下方会出现该方法定义的item。 &lt;code&gt;SLComposeSheetConfigurationItem&lt;/code&gt;的属性&lt;code&gt;title&lt;/code&gt;出现在左侧，属性&lt;code&gt;value&lt;/code&gt;出现在右侧，点击后弹出配置窗口。  &lt;/p&gt;
&lt;p&gt;最后是&lt;code&gt;presentationAnimationDidFinish&lt;/code&gt;，该方法是Share页面弹出动画结束后执行，苹果建议一些耗费重的工作在这里进行。我建议可以在这里准备好要上传的一些数据，比如获取图片数据，例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;presentationAnimationDidFinish&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inputItems&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSItemProvider&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attachments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="n"&gt;registeredTypeIdentifiers&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="nl"&gt;hasItemConformingToTypeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;kUTTypeImage&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="nl"&gt;loadItemForTypeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;kUTTypeImage&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="bp"&gt;NSSecureCoding&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="nl"&gt;isKindOfClass&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"NSURL: %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;dispatch_async&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imgURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="p"&gt;});&lt;/span&gt;


                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="c1"&gt;//other handling&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Share的内容基本全部覆盖了，觉得不能满足定制需求的可以去头文件查看还有哪些方法没有实现。如果没有找到，那么很大程度就是你的Share extension设计有问题了。&lt;br/&gt;
如果Share extension的运作和实现理解了，下面的Action，PhotoEditing会更容易理解，因为后两者的实现流程和Share非常类似。&lt;/p&gt;
&lt;h3&gt;4 Action&lt;/h3&gt;
&lt;p&gt;Action可以获得host app提供的可视数据，如何直接或者经过修改后使用，并把最终修改的数据交还给containing app。 
在iOS中，Action Extension：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帮助用户以另一种方式查看当前的文档&lt;/li&gt;
&lt;li&gt;extension总是在action sheet或全屏的模态视图中出现&lt;/li&gt;
&lt;li&gt;当且仅当host app允许，Action extension才会收到选中的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和Share一样，Action也只能位于系统的UI中，如果某个host app可用某个extension并且host app实现了&lt;code&gt;UIActivityController&lt;/code&gt;，否则将不能调用extension。&lt;/p&gt;
&lt;h4&gt;4.1 Action模版文件&lt;/h4&gt;
&lt;p&gt;新建一个Action对象后，我们还是先看plist文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;TRUEPREDICATE&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.ui-services&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认的plist文件还是不够完备的，需要自己添加，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActionWantsFullScreenPresentation&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionServiceRoleType&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;NSExtensionServiceRoleTypeViewer&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.ui-services&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;NSExtensionActionWantsFullScreenPresentation&lt;/code&gt;指定Action是否需要全屏显示，而&lt;code&gt;NSExtensionServiceRoleType&lt;/code&gt;则有2种取值：
&lt;em&gt; &lt;code&gt;NSExtensionServiceRoleTypeEditor&lt;/code&gt;: 可以编辑或转换文档，并将修改过的文档回传给host app
&lt;/em&gt; &lt;code&gt;NSExtensionServiceRoleTypeViewer&lt;/code&gt;: 将选中的文档以另一种形式打开浏览&lt;/p&gt;
&lt;p&gt;需要说明的是，文档中说明了&lt;code&gt;NSExtensionServiceRoleType&lt;/code&gt;是OS X上才有的。&lt;/p&gt;
&lt;h4&gt;4.2 Action UI设计&lt;/h4&gt;
&lt;p&gt;UI的设计和具体的应用有关，限制较少，唯一需要注意的是Action需要提供一个类似app icon的图片，以便在&lt;code&gt;UIactivityController&lt;/code&gt;中显示。图片的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带有适度透明的黑或白底&lt;/li&gt;
&lt;li&gt;不要有阴影&lt;/li&gt;
&lt;li&gt;图片要抗锯齿&lt;/li&gt;
&lt;li&gt;尺寸：60x60 iphone；76x76 ipad&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.3 内容回传&lt;/h4&gt;
&lt;p&gt;主要实现&lt;code&gt;done&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;done&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// Return any edited content to the host app.&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedContentText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myTextView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt; &lt;span class="nl"&gt;completeRequestReturningItems&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5 Photo Editing&lt;/h3&gt;
&lt;p&gt;Photo Editing和Action很类似，唯一的区别就是Photo Editing的host只能是Photos app。它的启动方式是：Photos-&amp;gt;单个图片浏览-&amp;gt;编辑-&amp;gt;左上角按钮。经过Photo Editing处理的图片会返回给Photos，用户可以选择接受或取消该改变。&lt;/p&gt;
&lt;h4&gt;5.1 Photo Editing如何运行&lt;/h4&gt;
&lt;p&gt;Photos会保存多个版本的asset数据：原始的数据，历次做过修改的数据(比如添加的滤镜参数)，以及现有含修改的数据。当启用Photo Editing，Photos会问extension能否读懂修改数据，如果可以读懂Photos会把原始数据作为输入传递给extension，再把修改数据传递给extension。这样，extension可以使用修改数据(比如修改滤镜参数)或者直接添加新的编辑。&lt;br/&gt;
如果extension不支持修改的数据，那么Photos就会把当前的数据作为输入传递给extension，这样extension只能添加新的便捷了。&lt;/p&gt;
&lt;h4&gt;5.2 模版文件&lt;/h4&gt;
&lt;p&gt;plist文件新加&lt;code&gt;PHSupportedMediaTypes&lt;/code&gt;的key，它的值是 &lt;code&gt;Image&lt;/code&gt;或&lt;code&gt;Video&lt;/code&gt;。&lt;br/&gt;
而查看实现文件可以发现视图控制器实现了&lt;code&gt;PHContentEditingController&lt;/code&gt;协议，该协议的代理方法都是&lt;code&gt;required&lt;/code&gt;，方法的说明见下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;extension&lt;/span&gt;&lt;span class="err"&gt;能否处理编辑的数据&lt;/span&gt;
 &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;BOOL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;canHandleAdjustmentData&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;PHAdjustmentData&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;adjustmentData&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;contentEditingInput&lt;/span&gt;&lt;span class="err"&gt;是原始输入数据，&lt;/span&gt;&lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="err"&gt;则是现在版本的数据&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;startContentEditingWithInput&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;PHContentEditingInput&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;contentEditingInput&lt;/span&gt; &lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;编辑完成后调用，注意要调用&lt;/span&gt;&lt;span class="nt"&gt;completionHandler&lt;/span&gt;&lt;span class="err"&gt;来通知&lt;/span&gt;&lt;span class="nt"&gt;host&lt;/span&gt; &lt;span class="nt"&gt;app&lt;/span&gt;&lt;span class="err"&gt;编辑完成&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;finishContentEditingWithCompletionHandler&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;(^)(&lt;/span&gt;&lt;span class="nt"&gt;PHContentEditingOutput&lt;/span&gt; &lt;span class="o"&gt;*))&lt;/span&gt;&lt;span class="nt"&gt;completionHandler&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.3 sample&lt;/h4&gt;
&lt;p&gt;官方有一个例子:&lt;a href="https://developer.apple.com/devcenter/download.action?path=/wwdc_2014/wwdc_2014_sample_code/samplephotoeditingextension.zip"&gt;samplephotoeditingextension&lt;/a&gt;，可以去看看。&lt;/p&gt;
&lt;h3&gt;Bingo&lt;/h3&gt;
&lt;p&gt;以上介绍了widget， Share，Action和Photo Editing，剩下后文继续。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>App Extension Study 1</title><link href="http://icocoa.tk/app-extension-study-1.html" rel="alternate"></link><updated>2014-10-16T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-16:app-extension-study-1.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;app extension是iOS8引入的功能，使得iOS8也有了“插件”系统。虽然一时还不知道可以做些什么应用，但我相信会有杀手级的extension出现而且某种程度会影响到app的生态系统发展。所以，我们需要了解并熟悉如何制作app extension。本系列会以&lt;a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html"&gt;官方文档&lt;/a&gt;为指引，按图索骥，拨开app extension的面纱(主要侧重iOS)。&lt;/p&gt;
&lt;h2&gt;App Extension&lt;/h2&gt;
&lt;p&gt;有很多关于App Extension的介绍，所以就不详细介绍，这里侧重介绍Extension的生命周期以及和其他app的通信。&lt;/p&gt;
&lt;h3&gt;术语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;host app: 用户在某个app中启用了extension，该app就叫host app&lt;/li&gt;
&lt;li&gt;containing app: extension不能单独作为target存在，必须依附在某个具有普通app的工程内，该app就是containing app。一个containing app可以有多个extension。&lt;/li&gt;
&lt;li&gt;app extension: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当下载了含有extension的containing app，那么如果某个app可以使用该extension，那么就可以在app(此即host app)中调用extension&lt;/p&gt;
&lt;h3&gt;生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img alt="extension_life_cycle" src="./imgs/20141016/extension_cycle.png"/&gt;&lt;br/&gt;
extension是由用户选择启动，然后作为一个单独的“程序”运行，直到运行结束，系统kill该extension，至此结束extension的使命。需要说明的是，无法在containing app中启用extension。&lt;br/&gt;
尽管extension通常是在host app中启动，但是extension的运行过程却不受 host/containing app 的“干预”——不能在host或containing app 中影响extention的运行。但是系统提供了某种机制使得三者之间可以共享部分数据。&lt;/p&gt;
&lt;h3&gt;通信&lt;/h3&gt;
&lt;h4&gt;与host app 通信&lt;/h4&gt;
&lt;p&gt;&lt;img alt="with_host" src="./imgs/20141016/communicat_only_with_host.png"/&gt;&lt;br/&gt;
两者关系干净利落：一个请求，一个响应，没有其他藕断丝连。iOS8中&lt;code&gt;UIViewController&lt;/code&gt;包含了&lt;code&gt;extensionContext&lt;/code&gt;的新属性。请求的所有信息都包含在该context属性中。&lt;br/&gt;
该图的虚线表明extension和containing没有直接的通信。 &lt;/p&gt;
&lt;h4&gt;与containing app 通信&lt;/h4&gt;
&lt;p&gt;从某种意义上，extension是“依附”着containing app的，既然不能直接通信，那么必然有迂回的方式。&lt;br/&gt;
&lt;img alt="with_containing" src="./imgs/20141016/communicat_indirectly_with_containing.png"/&gt;&lt;br/&gt;
上图中显示extension可以通过 OpenURL的方式打开自己的contaning app。更为重要的是，两者直接有一个shared resources区域来交换数据信息。&lt;/p&gt;
&lt;h4&gt;其他注意事项&lt;/h4&gt;
&lt;p&gt;由extension的工程必须包含arm64或x86_64框架，另外extension :  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能访问相机和麦克风&lt;/li&gt;
&lt;li&gt;不能执行长时间的后台任务，如果要上传／下载的话，需要使用 &lt;code&gt;NSURLSession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不能访问 &lt;code&gt;UIApplication&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;不能接受通过 &lt;em&gt;AirDrop&lt;/em&gt; 传送的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创建App Extesnion&lt;/h2&gt;
&lt;p&gt;使用Xcode6创建一个application，然后在new一个target，这时模板选项里会出现 "Application Extension"，选择任一添加。这样运行安装app后，连带之前的扩展也一并安装了。  &lt;/p&gt;
&lt;h3&gt;extension的工程文件&lt;/h3&gt;
&lt;p&gt;&lt;img alt="extension_template" src="./imgs/20141016/extension_template.png"/&gt;&lt;br/&gt;
extension的组成很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ViewController: extension的主要实现部分&lt;/li&gt;
&lt;li&gt;storyboard: extension的UI界面入口&lt;/li&gt;
&lt;li&gt;Info.plist: 老朋友了，主要关注&lt;code&gt;NSExtension&lt;/code&gt;键值。以后对一些限制，比如文件类型都在这里添加&lt;/li&gt;
&lt;li&gt;entitlements: optional，如果要启用share resource，就需要开启app group，那么会自动生产该文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;extension的常见处理流程&lt;/h3&gt;
&lt;p&gt;如前所说，请求的extenison的所有信息可以通过&lt;code&gt;UIViewController&lt;/code&gt;的&lt;code&gt;extensionContext&lt;/code&gt;获取。至于相关信息怎么获取，下面分门别类细说。  &lt;/p&gt;
&lt;h3&gt;debug&lt;/h3&gt;
&lt;p&gt;选中extesnion的scheme，然后debug，Xcode6会让你选择某个host app，然后进入该host app。在host app启用extension后，就可以debug了。&lt;/p&gt;
&lt;h3&gt;distribution&lt;/h3&gt;
&lt;p&gt;提交containing app即可——没有实践过，itunes connect是否要设置，暂时不详  &lt;/p&gt;
&lt;h2&gt;处理常见场景&lt;/h2&gt;
&lt;p&gt;在开始实践extension之前，有必要直到一些常见问题如何处理。&lt;/p&gt;
&lt;h3&gt;使用嵌入式框架共享代码&lt;/h3&gt;
&lt;p&gt;constaining和extension可以通过该方式共享代码，需要注意的是extension中不是所有API都可以使用，并且要包含64位的架构。这两点是文档中Apple反复提及的，一旦有违反这样的情况而进行提交的会直接被打回。&lt;br/&gt;
添加完库后，要将target的"Require Only App-Extension-Safe API"设置为"YES"。  &lt;/p&gt;
&lt;h3&gt;shared resources&lt;/h3&gt;
&lt;p&gt;前面说过extension和containing可以共享数据。这时分别对containing 和extension target启用"App Group"。Xcode6会自动获取group名，当然也可以自行添加。共享数据的读写是通过老朋友&lt;code&gt;NSUserDefault&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Create and share access to an NSUserDefaults object.&lt;/span&gt;
&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithSuiteName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"com.example.domain.MyShareExtension"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Use the shared user defaults object to update the user's account.&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;setObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theAccountName&lt;/span&gt; &lt;span class="nl"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"lastAccountName"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对共享区域的数据，extesnion和containing都有读写权限，所以某一方进行读写后要及时同步数据。  &lt;/p&gt;
&lt;h3&gt;访问网页&lt;/h3&gt;
&lt;p&gt;Share和Action类型的extension可以通过safari访问某个页面，执行你设定的js脚本，然后把执行的结果返回给extension。注意可以在extension执行前就执行脚本访问web页面，也可以在extension执行完毕后访问或修改web页面(该情形只在iOS有效)。&lt;br/&gt;
步骤：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建js文件，文件中要有一个名为&lt;code&gt;ExtensionPreprocessingJS&lt;/code&gt;的全局对象&lt;/li&gt;
&lt;li&gt;修改plist：将&lt;code&gt;NSExtensionActivationRule&lt;/code&gt;的属性&lt;code&gt;NSExtensionActivationSupportsWebPageWithMaxCount&lt;/code&gt;设置为非零的值&lt;/li&gt;
&lt;li&gt;当extension开始后，使用 &lt;code&gt;NSItemProvider&lt;/code&gt;获取js运行的结果&lt;/li&gt;
&lt;li&gt;iOS中如果要传递给js文件参数， 也通过 &lt;code&gt;NSItemProvider&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了让safari响应extension的js文件，需要添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionJavaScriptPreprocessingFile&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MyJavaScriptFile&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- Do not include the ".js" filename extension --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;js文件的写法&lt;/h4&gt;
&lt;p&gt;sample: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Pass the baseURI of the webpage to the extension.&lt;/span&gt;
      &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;completionFunction&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;"baseURI"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;baseURI&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that the finalize function is only available in iOS.&lt;/span&gt;
  &lt;span class="nl"&gt;finalize&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// arguments contains the value the extension provides in [NSExtensionContext completeRequestReturningItems:completion:].&lt;/span&gt;
  &lt;span class="c1"&gt;// In this example, the extension provides a color as a returning item.&lt;/span&gt;
  &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backgroundColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"bgColor"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// The JavaScript file must contain a global object named "ExtensionPreprocessingJS". &lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;ExtensionPreprocessingJS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释和说明：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当safari加载了js后，立即执行&lt;code&gt;run&lt;/code&gt;函数，执行的结果通过&lt;code&gt;completionFunction&lt;/code&gt;返回给extension&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finalize&lt;/code&gt;函数是extension执行&lt;code&gt;completeRequestReturningItems:completion:&lt;/code&gt;后执行，extesnion传递的参数在arguments中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对应的extension中： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取run执行的结果：&lt;/p&gt;
&lt;p&gt;[imageProvider loadItemForTypeIdentifier:kUTTypePropertyList options:nil
completionHandler:^(NSDictionary &lt;em&gt;item, NSError &lt;/em&gt;error) {
NSDictionary &lt;em&gt;results = (NSDictionary &lt;/em&gt;)item;
NSString *baseURI = [[results objectForKey:NSExtensionJavaScriptPreprocessingResultsKey] objectForKey:@"baseURI"];
}];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递给finalize：&lt;/p&gt;
&lt;p&gt;NSExtensionItem &lt;em&gt;extensionItem = [[NSExtensionItem alloc] init];
extensionItem.attachments = @[[[NSItemProvider alloc] initWithItem:@{NSExtensionJavaScriptFinalizeArgumentKey: @{@"bgColor":@"red"}} typeIdentifier:(NSString &lt;/em&gt;)kUTTypePropertyList]];
[[self extensionContext] completeRequestReturningItems:@[extensionItem]
  completion:nil];&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;上传和下载&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;NSURLSession&lt;/code&gt;，经过测试，&lt;code&gt;upload task session&lt;/code&gt; 不能在extension中使用。&lt;/p&gt;
&lt;h3&gt;声明Share/Action extension支持的数据类型&lt;/h3&gt;
&lt;p&gt;sample：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;10&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不支持的数据类型设置值为0或者移除该键。 &lt;/p&gt;
&lt;h3&gt;适配iOS8前的containing app&lt;/h3&gt;
&lt;p&gt;使用了嵌入式框架后，也能继续兼容iOS8之前的系统。这就要使用&lt;code&gt;dlopen&lt;/code&gt;，该命令可以在编译时条件链接和加载库。注意要在objc使用&lt;code&gt;dlopen&lt;/code&gt;。在containing执行的时候，检测系统只有是iOS8及以后的系统，才加载库。 &lt;/p&gt;
&lt;p&gt;下面会依次实现各种类型的extension，并将其中遇到的问题说明(待续)。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>git bisect查找xcode6工程在iOS7下不全屏的问题</title><link href="http://icocoa.tk/git-bisectcha-zhao-xcode6gong-cheng-zai-ios7xia-bu-quan-ping-de-wen-ti.html" rel="alternate"></link><updated>2014-10-16T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-16:git-bisectcha-zhao-xcode6gong-cheng-zai-ios7xia-bu-quan-ping-de-wen-ti.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: launch screen,xcode6,git&lt;/p&gt;
&lt;h2&gt;xcode6工程在iOS7下未全屏&lt;/h2&gt;
&lt;p&gt;使用xcode6创建的工程在iOS7下运行，居然出现了未全屏的现象，仿佛一下子回到了iPhone5发布的时代。因为提交了多次，不清楚是哪次引入的问题。所幸使用了git管理版本，想找到出错的提交，就靠git了。&lt;/p&gt;
&lt;h2&gt;git bisect&lt;/h2&gt;
&lt;p&gt;在不知道bisect之前，我能想到的办法是通过 &lt;code&gt;reset hard&lt;/code&gt; 或者&lt;code&gt;archive&lt;/code&gt; “恢复”到逐个提交，然后运行看结果。可是强大的git提供了bisect，于是一切都好办了。&lt;br/&gt;
bisect的使用就是标记两个版本，一个正确一个错误，然后git会自动找中间某个提交，由用户来确认是正确还是错误。如此反复，就能定位到引入错误的提交，具体执行过程演示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git log --oneline //列出提交记录
git bisect start //开始查找
git bisect bad //标记当前（master）为错误版本
git bisect good A-commit //提供一个运行正确的版本，下面开始查找

git bisect reset //当确认错误的提交后，需要清理战场，回到HEAD
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;LaunchScreen.xib&lt;/h2&gt;
&lt;p&gt;经过bisect的检查，发现是将工程的 Deployment target设置为iOS7引起的。因为Xcode6中模板工程默认使用LaunchScreen.xib，而且size class是对iOS8才有效，所以猜想应该是LaunchScreen引起的。重新运行了下工程，发现在iOS7下的确启动画面没有显示。而目前iOS7的用户还是占了大多数，很显然不可能只适配iOS8，所以工程还是得使用LaunchImage。&lt;/p&gt;
&lt;h2&gt;启用LaunchImage&lt;/h2&gt;
&lt;p&gt;启用很简单，在target的general设置中找到 &lt;code&gt;App Icons and Launch Images&lt;/code&gt;， 然后点击 &lt;code&gt;Use Asset Catalog&lt;/code&gt;，接下来按提示操作就可以了。  &lt;/p&gt;
&lt;p&gt;就目前的测试和google搜索情况来看，这种iOS7的不全屏显示问题只能通过这种方式解决。从app的launch过程（下图）可以看出，启动图片的加载是在&lt;code&gt;Load the main UI file&lt;/code&gt;进行的，此时还无法通过代码和程序进行“交互”。&lt;br/&gt;
&lt;img alt="app launch process" src="./imgs/20141016/app_launch_process.png"/&gt;&lt;br/&gt;
(图片来自 &lt;a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforHandlingAppStateTransitions/StrategiesforHandlingAppStateTransitions.html#//apple_ref/doc/uid/TP40007072-CH8-SW1"&gt;App Programming Guide&lt;/a&gt;)&lt;/p&gt;</summary><category term="ios8"></category><category term="git"></category><category term="launch screen"></category></entry><entry><title>git commit -a 的误区</title><link href="http://icocoa.tk/git-commit-a-de-wu-qu.html" rel="alternate"></link><updated>2014-09-22T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-09-22:git-commit-a-de-wu-qu.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: git 错误理解&lt;/p&gt;
&lt;h2&gt;SVN下的项目管理&lt;/h2&gt;
&lt;p&gt;在使用SVN进行版本管理的时候，我喜欢完成一个功能后进行提交。因为SVN设计的项目大多是在Linux系统，由于缺少较好的IDE，通常会先使用&lt;code&gt;svn status&lt;/code&gt; 查看修改的文件，然后逐一确认，最后使用 &lt;code&gt;svn ci -a -m \"commit content\"&lt;/code&gt; 进行提交。&lt;/p&gt;
&lt;h2&gt;git下的误区&lt;/h2&gt;
&lt;p&gt;大多数情况下，我一直按照SVN的方式处理git项目。我也一直感觉使用&lt;code&gt;git commit -a&lt;/code&gt;很爽，直到有一天发现git的log显示...&lt;br/&gt;
接下来我们来做一些操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git init
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"this is a init text"&lt;/span&gt; &amp;gt;&amp;gt; hello.txt
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Untracked files:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to include in what will be committed&lt;span class="o"&gt;)&lt;/span&gt;

    hello.txt

nothing added to commit but untracked files present &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add"&lt;/span&gt; to track&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然，我们需要先“添加” 文件到版本库（注意这个add在git中不是添加到版本库），然后进行提交：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add .
&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s2"&gt;"init commit"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来修改文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"add a line"&lt;/span&gt; &amp;gt;&amp;gt; hello.txt 
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class="k"&gt;for&lt;/span&gt; commit:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to update what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git checkout -- &amp;lt;file&amp;gt;..."&lt;/span&gt; to discard changes in working directory&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt

no changes added to commit &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add"&lt;/span&gt; and/or &lt;span class="s2"&gt;"git commit -a"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看log，它提示我们先进行add操作再进行commit（如果确定要提交的情形下），但是等一下，add操作不是已经做了吗？难道add的含义不是添加文件到版本库以便进行追踪？&lt;/p&gt;
&lt;h2&gt;git add到底是什么意思&lt;/h2&gt;
&lt;p&gt;我们先接着上面继续操作：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add hello.txt 
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git reset HEAD &amp;lt;file&amp;gt;..."&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时的log和之前相比，没有了add的建议操作，为了更明显显示这种区别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"difference"&lt;/span&gt; &amp;gt;&amp;gt;hello.txt
&lt;span class="nv"&gt;$git&lt;/span&gt; status 
On branch master
Changes to be committed:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git reset HEAD &amp;lt;file&amp;gt;..."&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt

Changes not staged &lt;span class="k"&gt;for&lt;/span&gt; commit:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to update what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git checkout -- &amp;lt;file&amp;gt;..."&lt;/span&gt; to discard changes in working directory&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者用－s参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; status -s&lt;/span&gt;
&lt;span class="x"&gt;MM hello.txt //在shell中2个M的颜色显示不一样&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以明白，git中的add操作和svn中的add操作是完全不一样的意思。&lt;br/&gt;
在git中， 执行add操作后是把文件加入版本库的暂存区，而commit针对的内容就只是暂存区。&lt;br/&gt;
而 &lt;code&gt;git commit -a&lt;/code&gt; 其实会先执行add操作再提交暂存区的内容，所以这样做是一个非常不好的实践，因为add到暂存区的操作实际是需要我们严格控制的。至于git上为什么要有这样的设计，那么需要知道 &lt;code&gt;reset&lt;/code&gt; 命令。这个下次再讲。&lt;/p&gt;
&lt;h2&gt;反思&lt;/h2&gt;
&lt;p&gt;很早就知道“暂存区”的概念，可是一直没有深入。git 的 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 一直使用，可是却没有想到背后的涵义。所谓 “知其然不知其所以然”，实是大忌！&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>QuartzComposer基本概念</title><link href="http://icocoa.tk/quartzcomposerji-ben-gai-nian.html" rel="alternate"></link><updated>2014-08-25T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-08-25:quartzcomposerji-ben-gai-nian.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: a guide to QuartzComposer&lt;/p&gt;
&lt;p&gt;Processors are green, providers are blue, and consumers are pink
最近才发现QuartzComposer也是一款用来设计交互的工具，原来Xcode自带，现在从Xcode中分离成为单独的app。之所以会关注是发现facebook的设计师也比较推崇该工具。在官网上搜索相关文档，内容都比较陈旧，或许说明这个工具比较成熟吧。&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;1. composition&lt;/h4&gt;
&lt;p&gt;Composer中创建的文件叫Quartz composition ， 其中最基本的单元（module）叫patch。&lt;/p&gt;
&lt;h4&gt;2. patch&lt;/h4&gt;
&lt;p&gt;patch是最基本的单元，苹果准备了丰富的库来完成一系列操作。patch库可以通过cmd＋enter的方式调用，然后找到需要的patch直接拖即可。patch相当于是一个程序，函数原型相当于：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;Result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;more&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt; &lt;span class="nx"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Composer中patch作为了可视化的组件出现了，如下图的billboard。
&lt;img alt="billboard" src="./imgs/20140827/billboard.png"/&gt;&lt;br/&gt;
图中的圆点叫port，左边的port代表输入参数，如果右边也有port的话，就代表输出参数。右上角的数字表示当前所在的层，这个有点类似Quartz2D中的树的概念：数字越小代表着越先执行；从视觉上说，数字越大的会最终显示在view窗口。&lt;/p&gt;
&lt;h5&gt;2.1 patch的种类&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;consumer
用蓝色显示，最终会显示在view窗口&lt;/li&gt;
&lt;li&gt;provider
用粉红色表示，将外部源的数据传递进来。这里的外部源指的是鼠标等事件。&lt;/li&gt;
&lt;li&gt;processor
用黑色显示，主要用于将处理过的数据传递给consumer。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;入门&lt;/h3&gt;
&lt;p&gt;没有使用官方的教程因为没有找到，在库里搜索patch的时候发现有些会带有例子。我是按照&lt;a href="http://qc.prabros.com/primer1.html"&gt;该文&lt;/a&gt;进行入门练习的。&lt;br/&gt;
该示例是模拟点击按钮切换按钮状态的例子，非常详细，跟着练习一边，基本的操作就能上手。最后的作业也很好，主要思路就是在建立一个toogle来过滤状态。&lt;/p&gt;
&lt;h3&gt;感想&lt;/h3&gt;
&lt;p&gt;有了sketch和QuartzComposer，自己设计漂亮的产品将不再遥远啦～&lt;/p&gt;</summary><category term="QuartzComposer"></category></entry><entry><title>MVVM初实践</title><link href="http://icocoa.tk/mvvmchu-shi-jian.html" rel="alternate"></link><updated>2014-08-25T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-08-25:mvvmchu-shi-jian.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: a sample project practising MVVM&lt;/p&gt;
&lt;p&gt;之前已经初步了解了一些MVVM的概念，需要在实践中体会这种设计模式，并理解“响应式”带来的优越性。&lt;br/&gt;
考虑到最近一直在做网盘类产品，于是决定：获取网盘的内容，并可以浏览内容。如果是文件夹的话，则可以点击查看内容。这样，就相当于实现了一个小型的文件查看器。&lt;br/&gt;
另外需要说明的，这里的网盘其实是一个带有系统的SD卡，自身带有AP，可以无线连接访问。同时，提供了API接口获取相关的数据。&lt;/p&gt;
&lt;h3&gt;MVVM 的角色分配&lt;/h3&gt;
&lt;p&gt;视图无疑是用&lt;code&gt;UITableView&lt;/code&gt;, 控制器自然选择&lt;code&gt;UITableViewController&lt;/code&gt;,自然这里需要建立一个&lt;code&gt;ViewModel&lt;/code&gt;来监视一切变化并把这种变化传递给控制器。&lt;/p&gt;
&lt;h3&gt;已知的VM任务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;获取文件夹列表
 VM需要知道当前所在的路径。另外获取到的数据需要重组：比如去掉隐藏文件，进行排序等。这个操作可以封装在某个数据访问层。&lt;/li&gt;
&lt;li&gt;cell的点击操作
对于文件，需要把文件内容显示出来(为了方便，这里只对图片文件显示)。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;控制器的任务&lt;/h3&gt;
&lt;p&gt;显示页面，以及点击cell时的页面切换。&lt;/p&gt;
&lt;h3&gt;VM的内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;UITableView&lt;/code&gt;的 &lt;code&gt;dataSource&lt;/code&gt;
dataSource相应的接口需要由VM来实现。在实现cell的时候，cell上的文件名也要通过VM来获取&lt;/li&gt;
&lt;li&gt;数据获取的时机
一般是在VM的信号didBecomeActiveSignal中去注册相应的事件。当事件完成后（获取列表任务），发送更新signal去通知控制器更新页面，因此在控制器中也要注册更新signal收到时相应的事件。整个伪代码逻辑：  &lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//ViewController&lt;/span&gt;
    &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;weakify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="nl"&gt;subscribeNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;strongify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tableView&lt;/span&gt; &lt;span class="n"&gt;reloadData&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;

&lt;span class="c1"&gt;//ViewModel&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;RACSubject&lt;/span&gt; &lt;span class="n"&gt;subject&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setNameWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%@_MasterVC"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flashCommand&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;RACCommand&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithSignalBlock&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="nl"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//get content list&lt;/span&gt;

        &lt;span class="c1"&gt;//finish data fetching and send signal&lt;/span&gt;

        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;RACSubject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="nl"&gt;sendNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;

&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;weakify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;didBecomeActiveSignal&lt;/span&gt; &lt;span class="nl"&gt;subscribeNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;strongify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flashCommand&lt;/span&gt; &lt;span class="nl"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSNull&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Cell的点击&lt;/h3&gt;
&lt;p&gt;由于有文件和文件夹的区别，cell无法在storyboard中创建2个push的segue，所以先利用对于文件夹的点击在&lt;code&gt;UITableView&lt;/code&gt;的点击delegate事件中进行操作，而文件的点击则通过&lt;code&gt;performSegueWithIdentifier&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;总体来说，实践基本按循MVVM的原则来进行，控制器中的内容变得很清爽，基本上只包含对view的控制，和VM的通信则是通过响应式的方式实现的。同时VM中包含了很多数据处理的内容，基本上逻辑的部分都转移到了VM中进行。在这种情况下，一个controller就要配一个VM，不知道会不会又造成VM的臃肿？&lt;/p&gt;</summary><category term="MVVM"></category></entry><entry><title>CentOS6.5 安装eclipse</title><link href="http://icocoa.tk/centos65-an-zhuang-eclipse.html" rel="alternate"></link><updated>2014-07-23T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-23:centos65-an-zhuang-eclipse.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: install eclipse on centos6.5&lt;/p&gt;
&lt;p&gt;最近要开始折腾centos了，需要用eclipse，下面记录下安装中遇到的问题。&lt;/p&gt;
&lt;h3&gt;eclipse 下载&lt;/h3&gt;
&lt;p&gt;直接在&lt;a href="https://www.eclipse.org/downloads/"&gt;官网&lt;/a&gt;下载，选择合适的版本：网站会识别操作系统，主要注意是32位还是64位&lt;br/&gt;
下载后，解压打开，双击eclipse的可执行程序，发现不能启动。弹出的提示说系统的jvm是1.6，而最新luna版需要1.7或以上。&lt;/p&gt;
&lt;h3&gt;jdk安装&lt;/h3&gt;
&lt;p&gt;主要参考了&lt;a href="http://www.cnblogs.com/zhoulf/archive/2013/02/04/2891608.html"&gt;这篇文章&lt;/a&gt;，具体过程就不多说了，注意操作要在su账号下。&lt;/p&gt;
&lt;h4&gt;source /etc/profile 不生效&lt;/h4&gt;
&lt;p&gt;虽然具体步骤不需多讲，不过我遇到了一个以前偶尔也碰到过的问题，就是执行完source后环境变量没有生效的问题。具体的状况是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在su下，执行完source /etc/profile，查看$PATH，添加的变量已经生效&lt;/li&gt;
&lt;li&gt;退出su，查看$PATH，发现添加的没有生效&lt;/li&gt;
&lt;li&gt;再次进入su，查看$PATH，发现添加的没有生效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目测应该是和linux系统启动的知识有关，果然在&lt;a href="http://www.cnblogs.com/BigIdiot/archive/2012/03/26/2417547.html"&gt;这里&lt;/a&gt;找到了答案，简单的说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/etc/profile:在登录时,操作系统定制用户环境时使用的第一个文件,此 文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。&lt;/li&gt;
&lt;li&gt;/etc/environment:在登录时操作系统使用的第二个文件,系统在 读取你自己的profile前,设置环境文件的环境变量。&lt;/li&gt;
&lt;li&gt;~/.bash_profile:在登录时用到的第三个文件是.profile文 件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用 户登录时,该 文件仅仅执行一次!默认情况下,他设置一些环境变游戏量,执 行用户的.bashrc文件。/etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该 文件被读取.&lt;/li&gt;
&lt;li&gt;~/.bashrc:该文件包含专用于你的bash shell的bash信 息,当登录时以及每次打开新的shell时,该该文件被读取。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，如果修改/etc/profile的话，需要重启系统。&lt;/p&gt;
&lt;p&gt;这样，最终整个过程完成了。&lt;/p&gt;</summary><category term="linux"></category><category term="eclipse"></category><category term="jdk"></category></entry><entry><title>design+code tutorial1 笔记</title><link href="http://icocoa.tk/designcode-tutorial1-bi-ji.html" rel="alternate"></link><updated>2014-07-17T17:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-17:designcode-tutorial1-bi-ji.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: design笔记&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;背景&lt;br/&gt;
添加2个overlay层渲染，分别斜对角线性和圆渐变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iOS7模板文件
normal #FAC3FF 10%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base shape
normal #FAC3FF 10%
添加圆形，斜对角渐变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="iOS"></category><category term="design"></category><category term="sketch"></category></entry><entry><title>MVVM模式初探</title><link href="http://icocoa.tk/mvvmmo-shi-chu-tan.html" rel="alternate"></link><updated>2014-07-17T13:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-17:mvvmmo-shi-chu-tan.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 设计模式&lt;/p&gt;
&lt;h2&gt;MVC的无奈&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html"&gt;MVC&lt;/a&gt;结构是学习iOS开发的人最先学习的一种开发模式，apple提倡以MVC为中心的开发模式。因为它很好的解构了应用场景中相关而又各自独立的部分：视图，视图控制器和数据模型。在MVC的世界里，控制器负责将模型中的数据以内容的形式展现到视图中，同时也把视图上产生的数据变化传递给模型从而将这种变化持久化。于是，在稍微复杂的app中，控制器中的内容会很庞大：网络操作，数据存储，手势响应等等。几乎可以确定，如果app需要添加新功能，超过一半的新增代码是添加在控制器中，这样不可避免的造成控制器的冗余以及大段无法重用的重复代码。&lt;br/&gt;
在开始MVVM时，我们可以稍稍考虑下现有MVC的问题。&lt;/p&gt;
&lt;h3&gt;视图&lt;/h3&gt;
&lt;p&gt;毋庸置疑，视图的作用很重要，但在设计中，视图是否需要和控制器，数据模型同等的地位呢？要知道绝大多数情况下，视图是不会重用的，往往“耦合”在视图控制器中，所以往往代码中有几个view controller，就能知道程序会有几个页面。此外，视图中的UI元素也是直接作为变量存在在控制器代码中，因为只有这样才方便刷新。很显然，视图控制器就可以代表视图本身。  &lt;/p&gt;
&lt;h3&gt;控制器&lt;/h3&gt;
&lt;p&gt;控制器需要把模型代表的数据以合适的形式显示在视图上，这样免不了需要处理（当然也有不需要处理的简单情况，这种不考虑）。这部分我们可以通过创建个工具类生成个类方法来实现。可是，当处理大型工程的适合，你会发现这个工具类里的方法或者需要的参数会越来越多或复杂。到最后，工具类会包含所有数据模型类的转换处理方法。这样就显得臃肿，而且在需要转换某个模型类数据的适合，代码提示会给出很多种选择，需要你去甄别。&lt;br/&gt;
从上所知，控制器包含了“太多”处理数据的流程——也叫展现逻辑(presentation logic)， 下面我们可以看到MVVM如何解决这一部分的问题。&lt;/p&gt;
&lt;h2&gt;MVVM&lt;/h2&gt;
&lt;p&gt;在知道MVVM后，我google了一下，发现这个概念是微软提出的。好吧，设计思想是跨平台，放之四海而皆行的真理。首先来看看MVVM的架构：&lt;br/&gt;
&lt;img alt="MVVM scheme" src="./imgs/20140717/mvvm.png"/&gt;&lt;br/&gt;
上图中，视图和视图控制器作为整体连结在一起，通过视图模型(viewmodel)和数据模型发生关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据有了变化，那么通过viewmodel将“变化”通知给视图控制器&lt;/li&gt;
&lt;li&gt;用户操作需要更新持久化数据时，也是通过viewmodel来起作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很显然，viewmodel的出现把与数据模型息息相关的处理部分从视图控制器中移除，这样控制器就得到了“解脱”。虽然多了viewmodel，可是不会增加太多任务，而且重要的是viewmodel很容易进行测试——稍有经验的人都知道视图控制器的测试问题可以成为一个永恒的话题。此外，使用MVC的过程迁移到MVVM并不会太难，——迁移的过程恰好也是梳理的过程，并且整理的更直观。&lt;/p&gt;
&lt;h2&gt;动态响应&lt;/h2&gt;
&lt;p&gt;假设有个app只要简单的直接显示人的姓和名，不需要展现逻辑，是否也不需要viewmodel了呢？继续看上图，你会发现model到viewmodel方向是notify。在app中，一切的变化都可以归结为状态的变化：比如输入字符，用户每输入一个字符，程序都会收到一次相应。又比如，刷新数据，数据接受完毕后，才会去显示。所以，当数据模型变化后，我们会通过一系列机制来“刷新”视图：代理，通知，KVO等等。而viewmodel也需要有这种特性：当数据有个变化后，能够感知，从而可以告诉视图控制器刷新界面。这种响应，通过KVO或者通知都能实现，而在业界现在首推 &lt;a href="https://github.com/ReactiveCocoa/ReactiveViewModel"&gt;ReactiveViewModel&lt;/a&gt;(提到ReactiveCocoa，可以从函数式响应变成开始聊个不停，但这里对ReactiveCocoa本身不做探讨，因为实践中尚未使用)，需要深入的可以去github上看看。使用过cocoa上controller object的，应该对这部分很感兴趣。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;使用MVVM的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化了控制器内容&lt;/li&gt;
&lt;li&gt;归并了工具类&lt;/li&gt;
&lt;li&gt;便于测试&lt;/li&gt;
&lt;li&gt;易于动态映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是阅读了&lt;a href="http://www.objc.io/issue-13/mvvm.html"&gt;Model-View-ViewModel for iOS&lt;/a&gt;有感而发, 文中的图片也来源于此。&lt;br/&gt;
其中文末给出的参考文章和示例代码，值得一看。&lt;/p&gt;</summary><category term="iOS"></category><category term="mvvm"></category><category term="mvc"></category><category term="pattern"></category></entry><entry><title>umeng 友盟错误报告处理</title><link href="http://icocoa.tk/umeng-you-meng-cuo-wu-bao-gao-chu-li.html" rel="alternate"></link><updated>2014-07-14T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-14:umeng-you-meng-cuo-wu-bao-gao-chu-li.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 错误报告处理&lt;/p&gt;
&lt;p&gt;今天发现友盟的后台中出现了app crash，打开一看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Application received signal SIGSEGV
(null)
(
    0   CoreFoundation                      0x2e44bf23  + 154
    1   libobjc.A.dylib                     0x38bdece7 objc_exception_throw + 38
    2   CoreFoundation                      0x2e44be4d  + 0
    3   ?????????                           0x00107a51 ????????? + 735825
    4   libsystem_platform.dylib            0x391f671b _sigtramp + 34
    5   UIKit                               0x30f20765  + 64
    6   UIKit                               0x30c9a7bd  + 604
    7   UIKit                               0x30f216db  + 1398
    8   UIKit                               0x30d4d3f7  + 418
    9   UIKit                               0x30d4d24f  + 30
    10  UIKit                               0x30d4d207  + 30
    11  UIKit                               0x30c7b977  + 378
    12  UIKit                               0x3116a977  + 110
    13  libobjc.A.dylib                     0x38bee0d3  + 358
    14  CoreFoundation                      0x2e37f4c1 _CFAutoreleasePoolPop + 16
    15  UIKit                               0x30c73bc1  + 36
    16  CoreFoundation                      0x2e417039  + 20
    17  CoreFoundation                      0x2e4149c7  + 286
    18  CoreFoundation                      0x2e414d13  + 738
    19  CoreFoundation                      0x2e37f769 CFRunLoopRunSpecific + 524
    20  CoreFoundation                      0x2e37f54b CFRunLoopRunInMode + 106
    21  GraphicsServices                    0x332dc6d3 GSEventRunModal + 138
    22  UIKit                               0x30cde891 UIApplicationMain + 1136
    23  ?????????                           0x0007bfd3 ????????? + 163795
    24  libdyld.dylib                       0x390dcab7  + 2
)
dSYM UUID: xx-XXX-38B1-B7A0-2XXXXX
CPU Type: armv7s
Slide Address: 0x00004000
Binary Image: ???
Base Address: 0x00054000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为没有相应的dsym信息，所以出错后没有办法symbolicate，也就看不到具体是那个方法引起的。这时我们就要通过上传的archive包，来查找相应地址对应的函数。这里需要说明的是，因为程序的bundle设置为了中文，所以会有上述的_?????_出现。因此，我们也可以得到，程序中引起crash的方法对应的函数地址是&lt;strong&gt;0x0007bfd3&lt;/strong&gt;。&lt;br/&gt;
接下来，我们在xcode找到上传成功的archive包，通过_show in finder_定位。xarchive后缀的文件和app后缀的文件一样，也是个bundle，可以通过右键&lt;em&gt;show content&lt;/em&gt; 打开。我们需要使用的可执行程序包，通常在:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Products/Applications/YourAppName.app/YourAppName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用命令：&lt;br/&gt;
&lt;code&gt;atos -arch armv7s -o /Products/Applications/YourAppName.app/YourAppName 0x0007bfd3&lt;/code&gt;&lt;br/&gt;
这样就会显示出是哪一个方法引起crash了。&lt;/p&gt;</summary><category term="iOS"></category><category term="sigsegv"></category></entry><entry><title>Sketch Tutorials Study 1</title><link href="http://icocoa.tk/sketch-tutorials-study-1.html" rel="alternate"></link><updated>2014-07-08T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-08:sketch-tutorials-study-1.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: some tutorials of sketch&lt;/p&gt;
&lt;p&gt;sketch是Mac上优秀的设计软件，堪称一把利剑。可好剑还得配好剑法，才能发挥威力。最近做的app，在界面上欠缺不少，正好借助sketch进行优化。下面是根据几个tutorial学习了sketch和设计的相关步骤。&lt;/p&gt;
&lt;h3&gt;Flat Styled Icon&lt;/h3&gt;
&lt;p&gt;原文在此：&lt;a href="https://medium.com/@sokratus/how-to-create-a-flat-styled-icon-in-sketch-3-27c4bd09989"&gt;flat styled icon &lt;/a&gt; &lt;br/&gt;
该示例主要展示了&lt;strong&gt;相交&lt;/strong&gt;运算的作用，以及锚点的使用。很多图形，仔细观察，都可以通过各种图形进行布尔运算而实现。通过形状的运算实现，还方便给各个部分填色。不过这一部分对我还是有点难，需要多练习。&lt;br/&gt;
另外，sketch中可以通过双击来激活编辑状态，然后编辑锚点。但是我发现有时候对组合过的图像，这个方法有点不太灵。这时，可以先在左边选中图形，然后点击上方状态栏的"Edit"，然后就可以自由添加锚点了。&lt;/p&gt;
&lt;h3&gt;Shadow Effect&lt;/h3&gt;
&lt;p&gt;原文在此：&lt;a href="http://brilliantsketch.com/make-long-shadow-effect-sketch/"&gt;shadow effect&lt;/a&gt; &lt;br/&gt;
该示例主要讲解了模糊、mask和锚点的使用。对于想做阴影效果，非常有帮助。我还依葫芦画瓢实现了文中文字的shadow效果。理解了这个方法，基本上阴影的实现就掌握了。&lt;/p&gt;
&lt;p&gt;最后，我的练习地址：&lt;a href="https://github.com/scorpiozj/blogproject/tree/master/sketch"&gt;github&lt;/a&gt;&lt;/p&gt;</summary><category term="sketch"></category></entry><entry><title>WWDC2014-223 Notes Protyping</title><link href="http://icocoa.tk/wwdc2014-223-notes-protyping.html" rel="alternate"></link><updated>2014-07-03T22:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-03:wwdc2014-223-notes-protyping.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu
Summary: notes for 223&lt;/p&gt;
&lt;p&gt;原型设计的作用好比开发阶段设计的作用一样，不可缺少。它可以节约时间、成本，把有限的资源放到需要的地方。&lt;br/&gt;
这一讲的内容分为下面几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原型的重要性&lt;/li&gt;
&lt;li&gt;如何利用原型改进产品&lt;/li&gt;
&lt;li&gt;原型设计的工具&lt;/li&gt;
&lt;li&gt;制作fake app&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;重要性&lt;/h2&gt;
&lt;p&gt;它的重要性在于是点子到产品过程中的必经之路，做得越充分越有利用产品的形成。这个毋需多言。&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;p&gt;How是进行原型的关键，通常就是结构任务，并带着问题去回答每一步。演讲者将过程分为3步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make fake apps&lt;/li&gt;
&lt;li&gt;Show people&lt;/li&gt;
&lt;li&gt;Learn from their feedback
三者的关系如下图：&lt;br/&gt;
&lt;img alt="relations icon" src="./imgs/20140703/how-relations.png"/&gt;&lt;br/&gt;
这个闭环首先表明原型设计的无止境，同时也表明这是一个带有反馈的系统表达。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Make&lt;/h3&gt;
&lt;p&gt;演讲者给了3个问题来帮助剖析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What needs to be more real&lt;/li&gt;
&lt;li&gt;What can we fake&lt;/li&gt;
&lt;li&gt;Where will they use it&lt;br/&gt;
make的目的是为了给人看，那么就需要判断fake app中看上去更真实（和最终产品的样貌一致的部分），以及哪些部分进行fake（指的是不是仅仅用几张屏幕截图来组成fake app，而是分割成不同的组成部分），比如文字，图标，图片等。当然，我们要确保用户会在iphone/ipad的设备上使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;p&gt;还是3个问题:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do you know how to ____?&lt;/li&gt;
&lt;li&gt;is it easy to ____?&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How can we make this better?
这里的空格就是表示fake app所承载的功能，就是问用户：  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我这个是用来做某某事的，你知道怎么做吗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;这样做操作简单吗&lt;/li&gt;
&lt;li&gt;怎么能做更好？  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，如果设计考虑到了"Ituitive"的话，用户对fake app的功能应该一目了然。&lt;/p&gt;
&lt;h3&gt;Learn&lt;/h3&gt;
&lt;p&gt;这一部分就是闭环反馈系统的关键了，正反馈吸收，负反馈反思。同时看看有没有碰撞起火花，产生新的灵感&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What's working&lt;/li&gt;
&lt;li&gt;what's not working&lt;/li&gt;
&lt;li&gt;what other ideas does this give us?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;工具&lt;/h2&gt;
&lt;p&gt;主要演示了用keynote进行protype的方法。keynote（或ppt）的动画功能还是一流的，每个人或多或少知道些。在这个过程中，演讲者使用了一个寻找好吃的toast的app为例，演示了如何进行上述环节的过程。这一部分，需要亲自看，体会才能更深&lt;/p&gt;
&lt;h2&gt;制作演示程序&lt;/h2&gt;
&lt;p&gt;使用xcode和core animation制作成可以在device上运行的app。示例的例子在官网上可以下载：&lt;a href="https://developer.apple.com/library/prerelease/ios/samplecode/ToastModern/"&gt;ToastModern&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如何protype是最大的收获，但是这一过程需要多练。  &lt;/li&gt;
&lt;li&gt;各种工具的灵活使用：谁知道keynote也可以protype呢？&lt;/li&gt;
&lt;li&gt;制作fake app的技巧： 不局限于coding实现&lt;/li&gt;
&lt;/ul&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category></entry><entry><title>WWDC2014-211 Notes designing_intuitive_user_experiences</title><link href="http://icocoa.tk/wwdc2014-211-notes-designing_intuitive_user_experiences.html" rel="alternate"></link><updated>2014-06-30T14:20:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-06-30:wwdc2014-211-notes-designing_intuitive_user_experiences.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: Notes for 211&lt;/p&gt;
&lt;h1&gt;intuitive&lt;/h1&gt;
&lt;p&gt;字面意思是“直觉”，意思就是看见页面后就知道该如何操作。这种“知道”可以来源于经验，惯例以及提示  &lt;/p&gt;
&lt;p&gt;开篇就举了设计 &lt;em&gt;“笔”&lt;/em&gt; 的例子：长度，宽度等元素&lt;/p&gt;
&lt;p&gt;Being ituitive is not intuitive&lt;br/&gt;
记住设计不是为自己(已知者)设计，是为其他人设计&lt;/p&gt;
&lt;p&gt;以下按5部分，进行阐述  &lt;/p&gt;
&lt;h2&gt;platform savvy&lt;/h2&gt;
&lt;p&gt;设计“intuitive”的交互，首先要熟悉所在系统的特性。以滑动cell出现操作选项为例，说明用户会进行“滑动”的操作——这种操作在iOS上是“周知”的。而你提供类似的功能时就要遵循一定的“规范”：背景色，长宽，文字说明，文字字体／大小，滑动触发的距离等等。&lt;br/&gt;
这里强调的是设计要和系统保持一致性。类似的包括手势操作：tap, pan, swipe, pinch, long press, rotate，控件：button／switch等。比如，tab的选中和非选中状态设置。&lt;br/&gt;
同时也说明为什么要保持这种一致性：因为是我们对真实世界体验的表现——显然有点是自夸自家的设计了&lt;br/&gt;
当然，演讲者也说明打破惯例（break convention）也不是不可以，这时就需要告诉用户如何使用了——有点像引导操作，但不一样。&lt;/p&gt;
&lt;h2&gt;easy to navigate&lt;/h2&gt;
&lt;p&gt;经典的导航式结构，主要还是围绕以下3个方面来解释：
&lt;em&gt; Tells you where you are
&lt;/em&gt; Shows you where else you can go
&lt;em&gt; Explain what's there
印象深的是“maximize continuty”：以photo中点击小图查看大图的导航为例，可以明确大图是来自哪一张小图。&lt;br/&gt;
这里居然还“批判”了抽屉式导航（视频里叫 hamburger）:
&lt;/em&gt; 页面的内容在app中不可见，需要通过左上方（一般都是放置在左上方）的按钮点开后显示
&lt;em&gt; 通过该页面进行app内容切换的场景很少
&lt;/em&gt; 页面切换耗费比较多：要比nav＋tab式多点一次，以及2倍的等待切换动画完成
当然hamburger也不是不能用（毕竟辩证法说明了万事没有绝对），但是在使用之前还是需要围绕最初的3个方面进行甄别&lt;/p&gt;
&lt;h2&gt;clear&lt;/h2&gt;
&lt;p&gt;清晰-&amp;gt;达意。 比如，tab选中后tintcolor显示出来就很明确告诉用户当前是在哪里。演讲者还侧重谈了如何撰写文字/设计icon&lt;/p&gt;
&lt;h2&gt;simple&lt;/h2&gt;
&lt;p&gt;80/20法则，80%的用户只会使用app提供的20%功能&lt;/p&gt;
&lt;h2&gt;focused&lt;/h2&gt;
&lt;p&gt;简单的说，就是app的目的是什么，那么所有的操作都为然着这个目的而来。&lt;/p&gt;
&lt;p&gt;设计真是门艺术——大家都能判断出体验的好坏，但却不能据此进行改良。这部分内容不仅对designer，对开发／产品人员，也大有裨益——虽然我的体会不是很深。&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category><category term="ux"></category></entry><entry><title>WWDC2014-221 Notes creating_custom_ios_user_interfaces</title><link href="http://icocoa.tk/wwdc2014-221-notes-creating_custom_ios_user_interfaces.html" rel="alternate"></link><updated>2014-06-29T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-06-29:wwdc2014-221-notes-creating_custom_ios_user_interfaces.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: notes for 221&lt;/p&gt;
&lt;p&gt;本场主要分4个议题： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring animations&lt;/li&gt;
&lt;li&gt;Vibrancy and blur&lt;/li&gt;
&lt;li&gt;Shape layers&lt;/li&gt;
&lt;li&gt;Dynamic Core Animation behaviors&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Spring animations&lt;/h2&gt;
&lt;p&gt;顾名思义指的是弹簧动画，很容易让人联想到UIKit Dynamic中的spring效果。但是，UIKit中就提供了API:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是iOS7中就有的API，它和UIKit提供的普通animation API很类似，增加的两个参数：&lt;code&gt;dampingRatio&lt;/code&gt;就是弹性系数，范围在0-1之间，通常取接近1的值；&lt;code&gt;velocity&lt;/code&gt;就是动画的初始速度，这个参数可以用下图来理解：&lt;br/&gt;
&lt;img alt="spring icon" src="./imgs/20140629/spring.png"/&gt;&lt;br/&gt;
横坐标是动画的事件，纵坐标是动画中变化的属性值。那么可以看到，普通的UIView animation的动画过程是比较平滑的；而spring的话，刚开始的“速率”就快多了。&lt;br/&gt;
Spring动画在iOS7中就已经是很多控件的标配，比如在屏幕上拉出设置页面，就带有spring效果。而且从这个API的设计接口来看，估计以后UIView 的普通animation API是会被spring所取代了。所以，在自定义控件的动画中，要注意使用spring动画，以符合iOS的风格&lt;/p&gt;
&lt;h2&gt;Vibrancy and blur&lt;/h2&gt;
&lt;p&gt;iOS7中有用于创建blur view的API：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-drawViewHierarchyInRect:afterScreenUpdates:, 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过该API可以将当前view的状态以UIImage绘制出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//https://developer.apple.com/library/ios/qa/qa1817/_index.html&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nl"&gt;snapshot&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;UIGraphicsBeginImageContextWithOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;drawViewHierarchyInRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt; &lt;span class="nl"&gt;afterScreenUpdates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;UIGraphicsEndImageContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而去年的wwdc中有对UIImage进行blur的例子，两者结合就可以对UIView进行blur化。这种方式用官方语言描述就是：fast&amp;amp;&amp;amp;static. 而如今Apple提供了直接的API——&lt;code&gt;UIVisualEffectView&lt;/code&gt;，使用方式很简单，就是先创建一个effect，然后再提供给view进行初始化,然后把它添加到要blur的view上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;UIVisualEffect&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;blurEffect&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIBlurEffect&lt;/span&gt; &lt;span class="nl"&gt;effectWithStyle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIBlurEffectStyleLight&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="bp"&gt;UIVisualEffectView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;visualEffectView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;UIVisualEffectView&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithEffect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;blurEffect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="n"&gt;visualEffectView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imageView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;imageView&lt;/span&gt; &lt;span class="nl"&gt;addSubview&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;visualEffectView&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见，这里&lt;code&gt;UIVisualEffectView&lt;/code&gt;变成了类似mask的东西。此外，该view提供blur和vibrancy两种效果。&lt;/p&gt;
&lt;h2&gt;Shape layers&lt;/h2&gt;
&lt;p&gt;这是个很古老的东西，它有一个path的属性，可以构建各种路径，从而方便定制UI。它的使用也很简单，和&lt;code&gt;CALayer&lt;/code&gt;的用法类似。&lt;/p&gt;
&lt;h2&gt;Dynamic Core Animation behaviors&lt;/h2&gt;
&lt;p&gt;主要通过实现&lt;code&gt;CAAction&lt;/code&gt;协议来实现动画。UIView animation的机制：&lt;br/&gt;
&lt;img alt="UIView Animation" src="./imgs/20140629/dynamic_core_animation.png"/&gt; &lt;br/&gt;
UIView会去查找是否实现&lt;code&gt;CAAction&lt;/code&gt;协议，没有实现的话就会调用：&lt;br/&gt;
&lt;code&gt;[super actionForLayer:layer key:event]&lt;/code&gt;。因此，如果实现了&lt;code&gt;CAAction&lt;/code&gt;协议就可以定制动画。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/scorpiozj/blogproject/tree/master/WWDC2014_221"&gt;项目地址&lt;/a&gt;&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category></entry></feed>