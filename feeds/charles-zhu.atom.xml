<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom"><title>To be Independent</title><link href="http://icocoa.tk/" rel="alternate"></link><link href="http://icocoa.tk/feeds/charles-zhu.atom.xml" rel="self"></link><id>http://icocoa.tk/</id><updated>2015-01-09T22:30:00+08:00</updated><entry><title>限制文本输入长度</title><link href="http://icocoa.tk/xian-zhi-wen-ben-shu-ru-chang-du.html" rel="alternate"></link><updated>2015-01-09T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-09:xian-zhi-wen-ben-shu-ru-chang-du.html</id><summary type="html">&lt;h2&gt;需求&lt;/h2&gt;
&lt;p&gt;限制字符输入长度是个常见的需求，比如注册的账号或者密码。通常，从用户体验的角度，iOS App中当输入超过制定长度的字符时不需要显式的弹出提示，而只需要让超过的字符不显示即可。这个功能看似简单，但是考虑到一些输入系统例如中文输入法的联想功能，就不那么简单。&lt;/p&gt;
&lt;h2&gt;一般的实现&lt;/h2&gt;
&lt;p&gt;以UITextField为例，通常的做法是在delegate中做文章。这样的解决方案很多，stackflow上一个比较全面的解答：&lt;a href="http://stackoverflow.com/questions/433337/set-the-maximum-character-length-of-a-uitextfield"&gt;Set the maximum character length of a UITextField&lt;/a&gt;，大致的思路就是在输入即将要替换的时候，计算最终要显示的字符串。这个方法对于英文输入是没有问题的，但是对于其他语言如中文输入就会存在问题。举例来说中文拼音输入“的”时，用户需要输入de，在未选中“的”时，de以选中的状态在输入框中显示，并作为输入框的内容，如下图：&lt;/p&gt;
&lt;p&gt;&lt;img alt="input1" src="./imgs/20150109/IMG_0040.png"/&gt;&lt;img alt="input2" src="./imgs/20150109/IMG_0041.png"/&gt;&lt;/p&gt;
&lt;p&gt;按照中文的输入法，de两个字符并不是最终显示在UITextField控件中，所以背景有选中区域，但此时UITextFiled的属性&lt;em&gt;text&lt;/em&gt;的内容包含de。然后，右图显示的是输入“的”后产生的联想，注意此时点击“确”的时候，UITextField的任一delegate都不会响应。所以，要另想办法解决。&lt;/p&gt;
&lt;h2&gt;解决办法&lt;/h2&gt;
&lt;p&gt;UITextField有一个属性&lt;em&gt;markedTextRange&lt;/em&gt;用于标识如中文拼音输入字母时的情形，那么解决的思路：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;UITextFiled的delegate中先检查markedTextRange是否为空，不为空时不做检查允许输入；否则按原先的思路计算字符长度&lt;/li&gt;
&lt;li&gt;注册&lt;em&gt;UITextFieldTextDidChangeNotification&lt;/em&gt;消息，用于处理联想输入情形&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;下面给出代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;textField:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UITextField&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;textField&lt;/span&gt; &lt;span class="nf"&gt;shouldChangeCharactersInRange:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSRange&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;range&lt;/span&gt; &lt;span class="nf"&gt;replacementString:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;string&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;//delete&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="o"&gt;||&lt;/span&gt; &lt;span class="n"&gt;textField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;markedTextRange&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;

    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;textField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MAX_LEN&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;textChange:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSNotification&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;noti&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;markedTextRange&lt;/span&gt; &lt;span class="o"&gt;!=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;MAX_LEN&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;waterTextField&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;string&lt;/span&gt; &lt;span class="nl"&gt;substringToIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;MAX_LEN&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;需要注意的是在&lt;em&gt;UITextFieldTextDidChangeNotification&lt;/em&gt;的响应中需要检测markedTextRange，只有在为nil的情况下再进行字符截断处理，否则程序会抛出异常。&lt;/p&gt;</summary><category term="objc"></category></entry><entry><title>新年开篇</title><link href="http://icocoa.tk/xin-nian-kai-pian.html" rel="alternate"></link><updated>2015-01-05T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2015-01-05:xin-nian-kai-pian.html</id><summary type="html">&lt;p&gt;转眼间，又进入了新的一年。虽然农历新年尚有不到两个月，但年的氛围已经起来了。此时，尤其适合回顾过去，展望未来。&lt;/p&gt;
&lt;h2&gt;过去的2014年&lt;/h2&gt;
&lt;p&gt;过去的一年，收获还是颇多的。借鉴前几次计划的不足，2014年初制订计划的时候，没有那么“严格”。比如，要求看书的数量为两本，这样年尾的时候，不至于完不成目标还给自己太大的心里负担。&lt;/p&gt;
&lt;h2&gt;iOS&lt;/h2&gt;
&lt;p&gt;iOS的开发是主打，iOS8新特性的extension总算搞明白并使用在自己的app里。
个人app今年终于上线，总共3个，分别对应不同的类型。原先打算通过挂广告赚点零花钱，却不曾想这条路对于我是那么艰难。反倒是一个付费的app，有不俗的表现，起码明年的续费不用担心了。这给我很大的感触，就是创造的东西要解决用户的实际需求，说的好看点就是时下流行的“抓住用户的痛点”。这个怎么抓，只能各自去体会。自己的经验而言，首要的是行动，想那么多不如先做一点点；在实际航行的时候，再一点点的调整方向。等有了经验以后，有些东西就会水到渠成了。&lt;/p&gt;
&lt;h2&gt;SAE&lt;/h2&gt;
&lt;p&gt;sae上搭建了一些小服务，主要是用于app中的版本检查之类。服务端的开发没有深入，这一块可能会在今年加快实施的步伐，不过现在还没有得到明确的消息。之前搭建的wordpress偷偷的浪费了不少云豆，索性停了，不过blog没有转出，有点可惜，有时间的时候，需要好好处理下。现在使用github pages作为个人blog，记录自己的心得，现正保证平均一周至少一文的标准。&lt;/p&gt;
&lt;h2&gt;设计&lt;/h2&gt;
&lt;p&gt;接触了sketch，真是神器。app中的素材都是通过sketch来生成的，下面需要使用sketch来设计原型，然后再进行实际开发。今年还是花了不少时间在设计上，但是自己看书摸索的过程比较辛苦，效果也不好。2015年，需要换个思路。&lt;/p&gt;
&lt;h2&gt;python&lt;/h2&gt;
&lt;p&gt;python基本的技能已经掌握，在年末之前使用了scrapy，小有体会。继续深入，为下一步计划准备。&lt;/p&gt;
&lt;h2&gt;明年目标&lt;/h2&gt;
&lt;p&gt;首先插一句，不管目标是什么，制订的内容一定要保持自己能够每天坚持去做。只有这样，才能在实际行动中获得快感，激励继续前行。这就是所谓的正反馈，对于个人、团队都是不可缺少的。&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;看完 git 权威指南&lt;/li&gt;
&lt;li&gt;每周至少一次更新github page&lt;/li&gt;
&lt;li&gt;更新air app，并力争上线游戏类新作品&lt;/li&gt;
&lt;li&gt;学习日语，NHK的全部学完
以上是2015上半年计划，先曝曝光，免得自己偷懒或是以后篡改&lt;/li&gt;
&lt;/ol&gt;</summary><category term="总结 计划"></category></entry><entry><title>NSZombierEnable</title><link href="http://icocoa.tk/nszombierenable.html" rel="alternate"></link><updated>2014-12-18T10:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-18:nszombierenable.html</id><summary type="html">&lt;p&gt;今天在cocoachina上看到一篇关于实现NSZombier的翻译贴，原文来自&lt;a href="https://mikeash.com/"&gt;Mike Ash&lt;/a&gt;。此人是(Friday Q&amp;amp;A)的作者，更为神奇的是他白天是飞行员，晚上是程序员，这在天朝不可想像。本文主要是基于他以下两篇文章的笔记。&lt;br/&gt;
&lt;a href="https://mikeash.com/pyblog/friday-qa-2014-11-07-lets-build-nszombie.html"&gt;Friday Q&amp;amp;A 2011-05-20: The Inner Life of Zombies&lt;/a&gt;&lt;br/&gt;
&lt;a href="https://mikeash.com/pyblog/friday-qa-2011-05-20-the-inner-life-of-zombies.html"&gt;Friday Q&amp;amp;A 2014-11-07: Let's Build NSZombie&lt;/a&gt;&lt;/p&gt;
&lt;h3&gt;启用NSZombier对象&lt;/h3&gt;
&lt;p&gt;有经验的开发者在遇到诸如&lt;code&gt;EXC_BAD_ACCESS&lt;/code&gt;的错误时往往会设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;为&lt;code&gt;YES&lt;/code&gt;，这样类似的错误发生后，就可以定位到出错的位置，从而便于诊断问题所在。&lt;br/&gt;
诸如此类的内存错误不管是MRC还是ARC下，都是会发生的。发生的原因在于：一个已经release的指针对象，又收到了某个消息，这时就会发生古怪。在MRC下，alloc一个对象A，然后release后，该对象所指向的内存被系统回收，标记为可用状态。根据程序运行的情况，该处内存可能过会被系统回收也可能马上分配给另一对象B。这时，如果程序还认为A对象存在，并发生某个消息给A时，就会发生错误。可以设计如下的测试代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"test"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该片段放置在某个点击事件中，当我们没有设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;时，运行一下：
&lt;img alt="NSZombier_Disable" src="./imgs/20141218/NSZombier_Disable.png"/&gt;&lt;/p&gt;
&lt;p&gt;测试的时候，快速点击了两下，可以发现console里输出了3次"test"，然后程序crash定位在release后的&lt;code&gt;NSLog&lt;/code&gt;处。这说明release后系统可能会没有立即清理该处内存，导致可以输出该内存所存储的内容。&lt;br/&gt;
接下来，启用&lt;code&gt;NSZombieEnabled&lt;/code&gt;，Xcode6中打开&lt;code&gt;schema-&amp;gt;Diagnostics-&amp;gt;Enable Zombie Objects&lt;/code&gt;，然后测试：  &lt;/p&gt;
&lt;p&gt;&lt;img alt="NSZombier_Enable" src="./imgs/20141218/NSZombier_Enable.png"/&gt;&lt;/p&gt;
&lt;p&gt;console里输出了 
     [CFString respondsToSelector:]: message sent to deallocated instance 0x7fa52a7df560
这很明确的指明了错误发生的原因：给dealloc的对象发送了消息。所以在大型项目中，设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;后还是很便于定位内存错误。&lt;/p&gt;
&lt;p&gt;这种给释放的对象发送消息还有可能发生一种错误，就是:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;*** Terminating app due to uncaught exception 'NSInvalidArgumentException', reason: '-[__NSCFString xxxxx]: unrecognized selector sent to instance 0x7fdd626b2b90'&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;这是因为释放掉的内存被系统分配给另一个对象，而程序继续发送消息给原先的对象时，就很容易发生该类型错误。如果恰好新对象也有一个同名的方法，虽然不至于导致程序马上crash可造成的后果就可大可小了。因此如果程序crash然后console显示因为发送给某个没用到的对象一个程序内找不到的方法的错误时，往往都是对象释放后仍去使用造成的。   &lt;/p&gt;
&lt;h3&gt;深入NSZombier&lt;/h3&gt;
&lt;p&gt;启用&lt;code&gt;NSZombieEnabled&lt;/code&gt;后，对于要释放的内存，系统会创建一个NSZombier的对象来"接管"该内存，当NSZombier对象收到消息后，就会crash并显示错误信息和调用栈。我们使用mikeash的代码来深入研究下内存变化，添加如下的函数并更新原代码：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#import &amp;lt;malloc/malloc.h&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;void&lt;/span&gt; &lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;stringWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@ malloc_size &lt;/span&gt;&lt;span class="si"&gt;%d&lt;/span&gt;&lt;span class="s"&gt; - %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;msg&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;malloc_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSData&lt;/span&gt; &lt;span class="n"&gt;dataWithBytes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="si"&gt;%s&lt;/span&gt;&lt;span class="se"&gt;\n&lt;/span&gt;&lt;span class="s"&gt;"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;s&lt;/span&gt; &lt;span class="n"&gt;UTF8String&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;
&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;initWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"test"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="nb"&gt;int&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"Fresh NSObject"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;testString&lt;/span&gt; &lt;span class="n"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;Dump&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"Destroyed NSObject"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="err"&gt;@&lt;/span&gt;&lt;span class="s"&gt;"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;testString&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;未设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;，运行效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2014-12-18 09:59:50.975 NSZombierTest[1579:185318] test
Fresh NSObject malloc_size 32 - &amp;lt;b8647209 01000000 8c070000 01000000 04746573 74000000 00000000 00000000&amp;gt;
Destroyed NSObject malloc_size 0 - &amp;lt;b8647209 01000000 8c076000 00000000 04746573 74000000 00000000 00000000&amp;gt;
2014-12-18 09:59:50.976 NSZombierTest[1579:185318] test
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时release后对象内存size为0，但指向内存地址还是和之前的一样。&lt;br/&gt;
然后设置&lt;code&gt;NSZombieEnabled&lt;/code&gt;，运行效果：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;31.229&lt;/span&gt; &lt;span class="n"&gt;NSZombierTest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1683&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;206192&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;test&lt;/span&gt;
&lt;span class="n"&gt;Fresh&lt;/span&gt; &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;b8542f07&lt;/span&gt; &lt;span class="mo"&gt;01000000&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;c070000&lt;/span&gt; &lt;span class="mo"&gt;01000000&lt;/span&gt; &lt;span class="mo"&gt;04746573&lt;/span&gt; &lt;span class="mi"&gt;74000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="n"&gt;Destroyed&lt;/span&gt; &lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="n"&gt;malloc_size&lt;/span&gt; &lt;span class="mi"&gt;32&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="n"&gt;c050f14b&lt;/span&gt; &lt;span class="mf"&gt;927f&lt;/span&gt;&lt;span class="mo"&gt;0000&lt;/span&gt; &lt;span class="mi"&gt;8&lt;/span&gt;&lt;span class="n"&gt;c076000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;04746573&lt;/span&gt; &lt;span class="mi"&gt;74000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt; &lt;span class="mo"&gt;00000000&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt;
&lt;span class="mi"&gt;2014&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;12&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="mi"&gt;18&lt;/span&gt; &lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;10&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mf"&gt;31.230&lt;/span&gt; &lt;span class="n"&gt;NSZombierTest&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="mi"&gt;1683&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;206192&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;***&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;CFString&lt;/span&gt; &lt;span class="nl"&gt;respondsToSelector&lt;/span&gt;&lt;span class="p"&gt;:]&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;message&lt;/span&gt; &lt;span class="n"&gt;sent&lt;/span&gt; &lt;span class="n"&gt;to&lt;/span&gt; &lt;span class="n"&gt;deallocated&lt;/span&gt; &lt;span class="n"&gt;instance&lt;/span&gt; &lt;span class="mh"&gt;0x7f924bfd9780&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时release后的对象内存size为32和release前一样大，同时内存的地址也改变了。这就印证了NSZombier对象的作用。更进一步的，Mike指出系统会使用一个NSZombier类型的对象覆盖之前release的内存，我们继续使用Mike的代码做测试：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="nt"&gt;DumpClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;Class&lt;/span&gt; &lt;span class="nt"&gt;c&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Dumping class %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Superclass: %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;class_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;class_getSuperclass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;)));&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Ivars:\n"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Ivar&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;ivars&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_copyIvarList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Ivar&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ivars&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"    %s %s %d\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ivar_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;ivar_getTypeEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;int&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ivar_getOffset&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;ivars&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="n"&gt;printf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s2"&gt;"Methods:\n"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;methods&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_copyMethodList&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;for&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt; &lt;span class="o"&gt;&amp;amp;&amp;amp;&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="o"&gt;++&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
        &lt;span class="n"&gt;fprintf&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;stderr&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="s2"&gt;"    %s %s\n"&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;sel_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;method_getName&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="n"&gt;method_getTypeEncoding&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="k"&gt;cursor&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;free&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;methods&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt;
&lt;span class="nt"&gt;DumpClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;object_getClass&lt;/span&gt;&lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;testString&lt;/span&gt;&lt;span class="o"&gt;));&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;结果如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Dumping class _NSZombie_CFString
Superclass: nil
Ivars:
    isa # 0
Methods:
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以看出此时的Zombier对象是&lt;code&gt;_NSZombie_CFString&lt;/code&gt;类型，该类型和&lt;code&gt;NSObject&lt;/code&gt;一样，是root class且只包含isa指针，但没有任何方法。  &lt;/p&gt;
&lt;h3&gt;实现 NSZombierEnable&lt;/h3&gt;
&lt;p&gt;实现这一机制，无疑依靠objc的runtime机制。首先想一想需要做哪些事情：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;生成一个相应的NSZombier class&lt;/li&gt;
&lt;li&gt;设置该类对消息的响应&lt;/li&gt;
&lt;li&gt;获取释放的对象，将其改写为上述NSZombier class&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;接下来，我把Mike的相关代码整理了下并做了说明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//启用NSZomiber，该函数可以放在+initialize中执行，目的的替换类默认的dealloc方法&lt;/span&gt;
 &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EnableZombies&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;Method&lt;/span&gt; &lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;class_getInstanceMethod&lt;/span&gt;&lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dealloc&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;method_setImplementation&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ZombieDealloc&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//将要释放的对象设置成相应的Zombier class&lt;/span&gt;
 &lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;ZombieDealloc&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;ZombifyClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;));&lt;/span&gt;
    &lt;span class="n"&gt;object_setClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;c&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//创建Zombierclass，并添加方法&lt;/span&gt;
 &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="nf"&gt;ZombifyClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSStringFromClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;@"MAZombie_"&lt;/span&gt; &lt;span class="nl"&gt;stringByAppendingString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
     &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSClassFromString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="n"&gt;zombieClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;objc_allocateClassPair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;zombieClassName&lt;/span&gt; &lt;span class="n"&gt;UTF8String&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;class_addMethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;methodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;:),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;ZombieMethodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"@@::"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;class_addMethod&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;initialize&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;IMP&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;EmptyIMP&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;"v@:"&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;objc_registerClassPair&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;zombieClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="nf"&gt;EmptyIMP&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; 
&lt;span class="p"&gt;{}&lt;/span&gt;
&lt;span class="c1"&gt;//消息转发&lt;/span&gt;
&lt;span class="bp"&gt;NSMethodSignature&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="nf"&gt;ZombieMethodSignatureForSelector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;_cmd&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="kt"&gt;SEL&lt;/span&gt; &lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="kt"&gt;Class&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;object_getClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;NSStringFromClass&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;className&lt;/span&gt; &lt;span class="nl"&gt;substringFromIndex&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;@"MAZombie_"&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Selector %@ sent to deallocated instance %p of class %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;NSStringFromSelector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;selector&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="n"&gt;obj&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;className&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="n"&gt;abort&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;


&lt;span class="c1"&gt;//测试代码&lt;/span&gt;
&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSIndexSet&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="k"&gt;release&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;obj&lt;/span&gt; &lt;span class="n"&gt;count&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;测试结果：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;NSZombierTest[3236:495027] Selector count sent to deallocated instance 0x7fbd80eabd00 of class NSIndexSet
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最后的评论中有人给出了Chromium的zombie的实现，源代码可以去&lt;a href="https://chromium.googlesource.com/chromium/src/+/master/chrome/common/mac/objc_zombie.mm"&gt;主页&lt;/a&gt;上查看。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;由此可见，对象的生命周期/相应内存的变化，以及objc的runtime机制，无疑是理解&lt;code&gt;NSZombierEnable&lt;/code&gt;的关键。&lt;/p&gt;</summary><category term="objc"></category></entry><entry><title>Find All Unlocalized Strings</title><link href="http://icocoa.tk/find-all-unlocalized-strings.html" rel="alternate"></link><updated>2014-12-16T17:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-16:find-all-unlocalized-strings.html</id><summary type="html">&lt;h3&gt;Requirements&lt;/h3&gt;
&lt;p&gt;We have a project which uses &lt;code&gt;NSLocalizedString&lt;/code&gt; macro but some strings  are not localized in the &lt;code&gt;Localizable.strings&lt;/code&gt; file. What we do is to find all these strings and implement the &lt;code&gt;Localizable.strings&lt;/code&gt; file.&lt;/p&gt;
&lt;h3&gt;Apple's Tool&lt;/h3&gt;
&lt;p&gt;As I refered &lt;a href="http://stackoverflow.com/a/27266522/371974"&gt;here&lt;/a&gt;, Apple has a built-in tool but is for Appkit application. Open the scheme, and in the &lt;code&gt;Arguments&lt;/code&gt; tab, input the following strings to &lt;code&gt;Arguments Passed On Launch&lt;/code&gt;:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; -NSShowNonLocalizedStrings YES
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Then, build and run your &lt;strong&gt;Cocoa&lt;/strong&gt; application, the unlocalized string will be shown in console.&lt;br/&gt;
Now the good news is that with iOS8 the console can also print the unlocalized string for the iOS app. For example:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; 2014-12-16 15:53:44.073 iOSUnlocalizedTest[6251:1015330] Localizable string "name" not found in strings table "Localizable" of bundle CFBundle 0x7f9fe3515b80 &amp;lt;/Users/XXXXX/Library/Developer/CoreSimulator/Devices/F7E36A7E-14FF-4D2A-8881-A62C14CB66DE/data/Containers/Bundle/Application/18EB0513-5162-4CEC-9823-17AC3B513EFB/iOSUnlocalizedTest.app&amp;gt; (executable, loaded)
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;However, this is not the final answer as it is just a runtime checking not a static checking(As the setting above is under the &lt;code&gt;Run&lt;/code&gt;). You can't get all expected results at a glance.&lt;/p&gt;
&lt;h3&gt;What we do&lt;/h3&gt;
&lt;p&gt;It is apparent that we have to fix it manually. Considering all the shown strings using &lt;code&gt;NSLocalizedString&lt;/code&gt;, we can:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;find all strings in 'NSLocalizedString' macro&lt;/li&gt;
&lt;li&gt;check the string whether exists in the &lt;code&gt;Localized.Strings&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;So let's start!&lt;br/&gt;
Open a shell, cd to the project and then run:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -n -h "LocalizedString" -r ./ &amp;gt;&amp;gt;../result
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it will save all the lines including "LocalizedString" to the result. In the result file, it will list the file name and line number so that we can recheck it.&lt;br/&gt;
Then we try to get the targeted string which is the first parameter of &lt;code&gt;NSLocalizedString&lt;/code&gt; macro:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;grep -o -n "\"\w\{1,\}\"" ./result &amp;gt;&amp;gt; singleWord
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;it will save all the words to &lt;code&gt;singleWord&lt;/code&gt; file.&lt;br/&gt;
Then we copy the content from &lt;code&gt;Localizable.String&lt;/code&gt; to a txt file and then using the following script &lt;strong&gt;find.sh&lt;/strong&gt;:&lt;/p&gt;
&lt;table class="highlighttable"&gt;&lt;tr&gt;&lt;td class="linenos"&gt;&lt;div class="linenodiv"&gt;&lt;pre&gt; 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12&lt;/pre&gt;&lt;/div&gt;&lt;/td&gt;&lt;td class="code"&gt;&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c"&gt;#!/bin/sh&lt;/span&gt;

cat &lt;span class="nv"&gt;$1&lt;/span&gt; &lt;span class="p"&gt;|&lt;/span&gt; &lt;span class="k"&gt;while&lt;/span&gt; &lt;span class="nb"&gt;read &lt;/span&gt;line
&lt;span class="k"&gt;do&lt;/span&gt;
&lt;span class="c"&gt;# echo $line&lt;/span&gt;
    grep  &lt;span class="nv"&gt;$line&lt;/span&gt; ./japios.txt &amp;gt;&amp;gt; ./has.txt
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="o"&gt;[&lt;/span&gt; &lt;span class="nv"&gt;$?&lt;/span&gt; &lt;span class="o"&gt;==&lt;/span&gt; &lt;span class="m"&gt;0&lt;/span&gt; &lt;span class="o"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt; &lt;span class="k"&gt;then&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt; &amp;gt;&amp;gt; ./has.txt
    &lt;span class="k"&gt;else&lt;/span&gt;
        &lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="nv"&gt;$line&lt;/span&gt; &amp;gt;&amp;gt; ./nothas.txt
    &lt;span class="k"&gt;fi&lt;/span&gt;
&lt;span class="k"&gt;done&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/td&gt;&lt;/tr&gt;&lt;/table&gt;
&lt;p&gt;run the sh file using: &lt;code&gt;./find.sh singkeWord&lt;/code&gt;. It will save the localized words to has.txt and the non-localized words to the nothas.txt.&lt;br/&gt;
Notice in the script, japios.txt should be created from the &lt;code&gt;Localizable.String&lt;/code&gt; file as &lt;code&gt;Localizable.String&lt;/code&gt; file is recognized as binary file and &lt;code&gt;grep&lt;/code&gt; can't work.&lt;/p&gt;
&lt;h3&gt;Results&lt;/h3&gt;
&lt;p&gt;Using the following steps, we can find all the unlocalized one, but there are places to be imporoved:&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;the comment code still be figured out&lt;/li&gt;
&lt;li&gt;there are the duplicated words &lt;/li&gt;
&lt;li&gt;can't figure out those which not use &lt;code&gt;NSLocalizedString&lt;/code&gt; macro&lt;/li&gt;
&lt;/ol&gt;</summary><category term="Localized"></category></entry><entry><title>懂得止损</title><link href="http://icocoa.tk/dong-de-zhi-sun.html" rel="alternate"></link><updated>2014-12-08T22:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-12-08:dong-de-zhi-sun.html</id><summary type="html">&lt;h2&gt;缘起&lt;/h2&gt;
&lt;p&gt;止损一词似乎在股市中运用的颇多，大概是直接和金钱有联系的缘故。可是大家不要忘记，在当下，每个人的实践也是笔巨大的财富。想想首富们一分钟能赚的钱，就知道此言不虚。虽然你我离首富尚有些距离，但时间的宝贵会随着年龄的增长与日俱增。&lt;br/&gt;
最近在做app的分享功能，使用的是&lt;code&gt;Umeng&lt;/code&gt;的组件，之所以使用Umeng是因为：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;之前在技术群中，经常见到有人对shareSDK的诟病&lt;/li&gt;
&lt;li&gt;使用umeng的统计组件，对其印象不错
可是，偏偏这个分享，花费了整整一周的时间。&lt;br/&gt;
虽然我在这里直接列出了umeng和sharesdk，但是绝无软广的意思，想表达的是在浪费了一定宝贵时间的时候，个人应该如何选择分析并做出决策的重要性。&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;事件过程&lt;/h2&gt;
&lt;p&gt;分享的问题主要是facebook分享失败。在facebook的开发页面注册好app，申请并通过了pulic_action(是post wall的必须)的权限。由于疏忽，使用了Test User进行share的测试，没有任何问题。可是，使用了一个普通账号——既不是admin，也不是developer或tester的账号进行测试时，就会发现分享失败。经过排查，发现在第一次授权的时候，facebook授权页面上显示&lt;code&gt;该app不能post wall&lt;/code&gt;。我的第一直觉先是排查app的设置，未果后联系umeng的客服(这里需要点名一下，umeng的客服水平真的是有待提高)。客服听完我的描述，给出的结论是：既然测试账户可以分享，那么就是说明代码是没有问题的。哈哈，言外之意就是：你个sb，自己不会用，来作甚！ok，那虚心的问下对方，app的设置有什么需要注意的地方。这时，就像服务器超时一般，直到企业qq弹出长时间未说话，然后关闭对话的消息。 
上述的过程，花费了2个工作日，尤其是排查facebook上app的设置，花了近1天时间。&lt;br/&gt;
直到第三天，我丝毫没有怀疑umeng的sdk，还在facebook的开发组里发帖。说实在的，老外的水平也是参差不齐，我特别说明已经取得了相应的权限，还有人不断回复权限要审核。这时有位资料显示是facebook开发人员的回复引起了我的注意，他说：我这种情况facebook的app会弹出2次授权提示，第二次提示的时候会告诉用户该app拥有post权限。虽然以前做过facebook的分享，但是两年前的事情了，我开始意识到这是关键。与此同时，我也发现umeng给出的demo中，facebook分享也有同样的问题，我逐渐意识到这是个bug。于是赶紧联系客服，这次居然没有下文。好在我也不是太TMD一根筋，立马下载并使用了sharesdk，发现facebook的授权果然是会弹出2次。这时已经是第4天，还好自己的开发经验不算差，很快的集成好sharesdk。这时又发现了几个使用问题，联系sharesdk的客服，——不得不说，有了比较后sharesdk简直把你当vip一般看待的。周五晚上五点半快下班的时候，还在帮我解答问题，还好我也没耽搁太久，很快就搞定了一切。&lt;/p&gt;
&lt;h2&gt;过程分析&lt;/h2&gt;
&lt;p&gt;首先，因为现在的分析平台确实太多，逐个去集成太麻烦，所以第三方的分享服务才这么有市场。既然有市场，就有好坏之分。虽然是免费的产品，但花费的时间是无法用金钱衡量的(当然我不否认第三方服务为我们节省了大量时间)。这就像是金钱投资，花费了时间，总归需要有回报。当只有一个facebook分享有问题的情况下，要颠覆自己舍弃该sdk是件不易的事情。&lt;br/&gt;
其次，国外的分享平台由于众所周知的原因，一般情况下不太会涉及。这就导致个人对此类平台的陌生：至少我之前根本不知道facebook的授权流程已经&lt;code&gt;进化&lt;/code&gt;到现在的样子了。
最后，就是没有完全测试第三方提供的demo，如果先试用demo的话，就会发现其本身就存在bug&lt;/p&gt;
&lt;h2&gt;止损需要具备的条件&lt;/h2&gt;
&lt;p&gt;虽然5天的时间不是100%的都在处理这个事情，但是这样的一个功能占据了一周的时间，还是需要警惕的。从现在的角度看，可以在以下的时间点及时转换sdk进行&lt;code&gt;止损&lt;/code&gt;：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当发现facebook上app的设置权限没有问题&lt;/li&gt;
&lt;li&gt;测试用户和普通用户分享的不同情况&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;之所以没有及时那样做，或者说不敢止损的原因在于：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;虽然有第三方的集成服务，但程序中要初始化一些相关的代码。怕麻烦，以及只有facebook不能分享，导致对umeng的期望过大&lt;/li&gt;
&lt;li&gt;个人对facebook平台的认识缺乏，简单的说就是技术上了解的不多，导致不能及时觉察到问题的症结所在&lt;/li&gt;
&lt;li&gt;先天对sharesdk有了排斥，以及相对的对umeng有了些许好感。主观的因素，往往能决定性的影响人的判断&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;经验教训&lt;/h2&gt;
&lt;ol&gt;
&lt;li&gt;一切都是不可靠的，第三方的服务可以使用但不能依赖&lt;/li&gt;
&lt;li&gt;一切不明白why或者细节的都是可怕的。你不知道实现过程，只知道结果，所以问题发生的时候无从判断&lt;/li&gt;
&lt;li&gt;要增强自己的技术力&lt;/li&gt;
&lt;/ol&gt;</summary><category term=""></category></entry><entry><title>App Extension Study 4</title><link href="http://icocoa.tk/app-extension-study-4.html" rel="alternate"></link><updated>2014-11-19T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-19:app-extension-study-4.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;本篇介绍剩下的&lt;code&gt;Custom Keyboard&lt;/code&gt;，之前的3篇： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;第一篇&lt;/a&gt;: 介绍了Extension的基本概念/运行周期/数据共享等通用技术细节  &lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-2.html"&gt;第二篇&lt;/a&gt;介绍并实践:widget，share，action和Photo Editing&lt;/li&gt;
&lt;li&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-3.html"&gt;第三篇&lt;/a&gt;介绍并实践了Sync和File Procvider&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;2 Custom Keyboard&lt;/h3&gt;
&lt;p&gt;iOS8终于对第三方输入法开放，引起一片毋需越狱的呼声，这就是通过extension实现的。在以前，app可以单独实现适合自己的文本输入法；而iOS8上，如果用户在设置中添加第三方的键盘，就会对所有app可见(如果app没有禁止使用第三方输入法的话)。对于重视用户隐私的苹果公司而言，虽然开放了输入法的扩展，但是对于用户数据和隐私的保护是非常重视，因此在开发的时候要时刻关注。&lt;/p&gt;
&lt;h4&gt;2.1 第三方输入法要具备的特征&lt;/h4&gt;
&lt;p&gt;输入法的核心是要对用户的点击等手势及时的响应，提供可选的文本和插入文本等。除此之外，重要的就是要能够切换到下一个输入法。苹果文档中列出了一些特征，虽然不要求全部实现，但实现的话会加分：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;根据键盘类型，提供合适的页面布局&lt;/li&gt;
&lt;li&gt;自动纠正和建议&lt;/li&gt;
&lt;li&gt;自动的大小写(指首字母大写)&lt;/li&gt;
&lt;li&gt;双击space生成句号(这个很多人都不知道吧)&lt;/li&gt;
&lt;li&gt;大小写&lt;/li&gt;
&lt;li&gt;提供键帽的图片(keycap artwork)&lt;/li&gt;
&lt;li&gt;为表意文字提供多级输入&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;要注意的是，在&lt;code&gt;设置&lt;/code&gt;中对键盘的一些设置，只对系统的键盘有效。因此，如果要添加自定义键盘的设置，需要自行添加&lt;code&gt;setting bundle&lt;/code&gt;。如果输入的文本要求是加密，那么iOS会自动使用系统的键盘暂时代替第三方的键盘输入。对于指定拨号类的输入如&lt;code&gt;UIKeyboardTypePhonePad&lt;/code&gt;和&lt;code&gt;UIKeyboardTypeNamePhonePad&lt;/code&gt;，第三方输入法也是不支持的。&lt;br/&gt;
因为第三方的输入法对所有的app都是适用的，所以iOS8中也提供了方法，供app选择是否可以使用第三方输入。如果只想使用系统的键盘输入，那么只要实现如下代理：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;- (BOOL)application:(UIApplication *)application shouldAllowExtensionPointIdentifier:(NSString *)extensionPointIdentifier
{
    return NO;
}
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.2 API的使用&lt;/h4&gt;
&lt;p&gt;首先来看一下第三方输入法的基本构成：&lt;br/&gt;
&lt;img alt="API_Start" src="./imgs/20141119/API_start.png"/&gt; &lt;/p&gt;
&lt;p&gt;第三方输入法激活后的调用和系统输入法的界面构成完全一样，页面主要是由&lt;code&gt;UIInputViewController&lt;/code&gt;的子类构成，可以在上面添加各种按钮或其他控件。图上很明显的加了可以切换输入法的按钮，和上述的要点吻合。&lt;code&gt;Text Input Object&lt;/code&gt;是类似&lt;code&gt;UITextView&lt;/code&gt;会弹出键盘的对象，&lt;code&gt;insertText:&lt;/code&gt;则是输入法输出字符这个最基本的功能。&lt;br/&gt;
&lt;code&gt;UIInputViewController&lt;/code&gt;包含一个实现了&lt;code&gt;UITextDocumentProxy&lt;/code&gt;协议的&lt;code&gt;NSObject&lt;/code&gt;属性&lt;code&gt;textDocumentProxy&lt;/code&gt;，该proxy对象作用比较大，以下事情都是由它负责的：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;插入/删除字符&lt;/li&gt;
&lt;li&gt;查看当前文本&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;控制插入光标的位置
由于&lt;code&gt;UIInputViewController&lt;/code&gt;实现了&lt;code&gt;UITextInputDelegate&lt;/code&gt;协议，当字符选中或输入的字符有变化时，相应的代理方法会触发。&lt;br/&gt;
对于要支持多语言的，可以有2种选择：  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;为每一种语言设计一个键盘，并作为一个单独的Custom Keyboard对象添加到containing app中&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;只设计一个键盘，在切当的时候动态切换到主语言。使用primaryLanguage属性可以切换到主语言&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;对于自动纠正，可以通过UILexicon访问基本的自动纠正词库。词库的来源：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;来自通讯录中的姓/名数据&lt;/li&gt;
&lt;li&gt;在Settings&amp;gt;General&amp;gt;Keyboard&amp;gt;Shortcuts list中定义的数据&lt;/li&gt;
&lt;li&gt;常见的单词库&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;关于键盘的高度，最好设置成和&lt;code&gt;UIInputViewController&lt;/code&gt;中视图的高度一致。默认情况下，键盘的宽度是始终和屏幕的宽度一致的，所以我们只需要关心高度的设置。&lt;/p&gt;
&lt;h4&gt;2.3 开发的要点&lt;/h4&gt;
&lt;p&gt;主要指：
1. Trust: 慎重对待用户的输入数据
2. "next keyboard" key: 可以切换到下一输入法&lt;/p&gt;
&lt;h5&gt;2.3.1 信任&lt;/h5&gt;
&lt;p&gt;主要涵盖以下3个方面：
1. 按键数据的安全性：因为可以根据按键知道输入的文本内容，千万不能以任何接口上传到自己的服务器
2. 慎用其他数据：启用了network access后，就能访问位置和通讯录，那么使用这些数据的时候就要想好如何跟用户解释
3. 精确性：这个不涉及隐私，主要是影响到用户是否认为你是合意的输入法
默认情况下，网络访问是关闭的，当启用后，输入法将获得一些额外能力，但同时输入法的责任也相应的增加：&lt;br/&gt;
&lt;img alt="responsibility.png" src="./imgs/20141119/responsibility.png"/&gt; 
以上列出了所有增加的能力以及开发者需要考虑的问题。&lt;/p&gt;
&lt;h4&gt;2.4 模版文件&lt;/h4&gt;
&lt;p&gt;新建一个&lt;code&gt;Custom Board&lt;/code&gt;的target，安装并运行&lt;code&gt;containing app&lt;/code&gt;一下，然后就可以在&lt;code&gt;Settings&amp;gt;General&amp;gt;Keyboard&amp;gt;Keyboards&amp;gt;Add New Keyboard&lt;/code&gt;中添加，然后打开某个文本，可以切换到我们定义的输入法。
自定义的键盘的名字可以在plist文件中用&lt;code&gt;Bundle display name&lt;/code&gt;指定，如果在&lt;code&gt;containing app&lt;/code&gt;和&lt;code&gt;extension&lt;/code&gt;都指定了该键值的话，那么在添加键盘的时候会显示&lt;code&gt;Contaning app&lt;/code&gt;中定义的名字，添加完毕后两者都一起显示:&lt;br/&gt;
&lt;img alt="keyboardName" src="./imgs/20141119/keyboard_name.png"/&gt;&lt;br/&gt;
接下来看一下plist文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;IsASCIICapable&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;PrefersRightToLeft&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;PrimaryLanguage&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;en-US&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;RequestsOpenAccess&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.keyboard-service&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPrincipalClass&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;KeyboardViewController&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要打开完全访问，需要设置&lt;code&gt;RequestsOpenAccess&lt;/code&gt;为&lt;code&gt;true&lt;/code&gt;。&lt;code&gt;IsASCIICapable&lt;/code&gt;指的是是否可以输入ascii字符，&lt;code&gt;PrefersRightToLeft&lt;/code&gt;是为从右向左的语言设置的。而&lt;code&gt;PrimaryLanguage&lt;/code&gt;是键盘的主语言，它的写法是&lt;code&gt;&amp;lt;language&amp;gt;-&amp;lt;REGION&amp;gt;&lt;/code&gt;。相应的语言和地区的值的定义在&lt;a href="http://www.opensource.apple.com/source/CF/CF-476.14/CFLocaleIdentifier.c"&gt;这里&lt;/a&gt;。&lt;br/&gt;
Build&amp;amp;Run一下，我们的输入法就安装在系统了，使用前先在设置中启用，然后打开搜索，切换几下，就可以看到了:
&lt;img alt="keyboad" src="./imgs/20141119/keyboard.png"/&gt;&lt;/p&gt;
&lt;h3&gt;3 结束&lt;/h3&gt;
&lt;p&gt;至此，所有的extension都讲解完了，extension的基本原理贯穿在7中extension之中。Store上已经有很多实现extesnion的app，而且我发现实现了extension的app提交后在2个小时左右就能&lt;code&gt;waiting in review&lt;/code&gt;，所以开发者们要加油了。  &lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>Git版本库管理</title><link href="http://icocoa.tk/gitban-ben-ku-guan-li.html" rel="alternate"></link><updated>2014-11-18T10:30:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-18:gitban-ben-ku-guan-li.html</id><summary type="html">&lt;p&gt;在开发过程中往往会使用第三方库，可有时候会因为某种原因不使用了，我们可以使用 &lt;code&gt;reset&lt;/code&gt;或是直接删除的方式将库删除，比如开发中用到了某度的SDK，可是发现crash的概率太大需要舍弃之。可是，这些库的影子还在版本库的历史中可以找到，会增大库的体积。这时候我们就需要完全清楚这些“残留”文件。&lt;br/&gt;
本篇内容可在&lt;a href="http://www.amazon.cn/gp/product/B0058FLC40/ref=as_li_ss_tl?ie=UTF8&amp;amp;camp=536&amp;amp;creative=3132&amp;amp;creativeASIN=B0058FLC40&amp;amp;linkCode=as2&amp;amp;tag=scorpiozj-23"&gt;Git权威指南&lt;/a&gt;第14章中找到。&lt;/p&gt;
&lt;h4&gt;松散对象&lt;/h4&gt;
&lt;p&gt;Git中对于以SHA1值作为目录名和文件保存的对象称之为松散对象。因此 add，commit等操作都会产生一系列的松散对象。大量的松散对象会造成访问效率低下，占用过多存储空间。在Git中可以通过打包的方式提高访问效率，同时也方便通过增量更新的方式节省存储空间。&lt;/p&gt;
&lt;h4&gt;暂存区中的临时对象&lt;/h4&gt;
&lt;p&gt;添加到暂存区的文件发现不需要了，我们应该怎么办？
首先我们复制2个稍大的(10M)的文件到工作区，然后添加到暂存区：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;cp /Users/xxxxx/Desktop/test.zip bigfile
&lt;span class="nv"&gt;$ &lt;/span&gt;cp /Users/xxxxx/Desktop/test.zip bigfile.dup
&lt;span class="nv"&gt;$ &lt;/span&gt;git add bigfile bigfile.dup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查看工作区和版本库的大小：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh
31M .
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
10M .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为添加到库中的文件Git是以blob对象的形式存储，对于相同文件只存储一份，所以库的大小是10M。&lt;br/&gt;
查看添加后的对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;然后我们把添加的文件撤出暂存区： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reset HEAD
&lt;span class="nv"&gt;$ &lt;/span&gt;git status -s
?? bigfile
?? bigfile.dup
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时再查看大小： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh
31M .
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
10M .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;发现大小并没有变化，这说明版本库中还保存着那个对象，可以通过&lt;code&gt;fsck&lt;/code&gt;命令查看：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling blob 5d1150e0e75f30161bba7799170c887d8f1104a0
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;要将这个文件从版本库彻底删除那么需要执行&lt;code&gt;prune&lt;/code&gt;：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git prune
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
172K    .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时可以看出版本库已经不包含文件对象&lt;/p&gt;
&lt;h4&gt;重置操作引入的对象&lt;/h4&gt;
&lt;p&gt;对于已经添加到版本库中的文件，又该如何清除相应的文件对象呢？我们还是添加2个文件并commit： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
&lt;span class="err"&gt;$&lt;/span&gt; &lt;span class="n"&gt;git&lt;/span&gt; &lt;span class="n"&gt;commit&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="n"&gt;m&lt;/span&gt; &lt;span class="s"&gt;"add bigfiles"&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;master&lt;/span&gt; &lt;span class="n"&gt;a5feb75&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;add&lt;/span&gt; &lt;span class="n"&gt;bigfiles&lt;/span&gt;
&lt;span class="mi"&gt;2&lt;/span&gt; &lt;span class="n"&gt;files&lt;/span&gt; &lt;span class="n"&gt;changed&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;insertions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;+&lt;/span&gt;&lt;span class="p"&gt;),&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="n"&gt;deletions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="mi"&gt;100644&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;
&lt;span class="n"&gt;create&lt;/span&gt; &lt;span class="n"&gt;mode&lt;/span&gt; &lt;span class="mi"&gt;100644&lt;/span&gt; &lt;span class="n"&gt;bigfile&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;dup&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时查看文件对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
.git/objects//6b/ff29c5d2ae75913cb00de0887f6bc1e4dfbc31
.git/objects//a5/feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;使用 &lt;code&gt;git cat-file -t 5d11&lt;/code&gt;可以查看文件对象的类型，上述3个对象的类型分别为：树，提交，和blob。
接下来使用&lt;code&gt;reset&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reset --hard HEAD^
HEAD is now at 6652a0d Add Images &lt;span class="k"&gt;for&lt;/span&gt; git treeview.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;现在查看文件对象会发现还是存在上述的3个对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;find .git/objects/ -type f
.git/objects//5d/1150e0e75f30161bba7799170c887d8f1104a0
.git/objects//6b/ff29c5d2ae75913cb00de0887f6bc1e4dfbc31
.git/objects//a5/feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时执行&lt;code&gt;fsck&lt;/code&gt;会发现没有找到未关联的对象：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然，所有的对象都是关联的，因为我们还可以撤销该次提交。要找到该文件对象，需要使用：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck --no-reflogs
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling commit a5feb75fd7255b0085b92448a14d2fae62ea75be
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;由于所有的记录都存储在&lt;code&gt;reflog&lt;/code&gt;中，所以我们需要清除&lt;code&gt;reflog&lt;/code&gt;，在这里需要注意：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; reflog expire --all&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="x"&gt; git reflog&lt;/span&gt;
&lt;span class="x"&gt;6652a0d HEAD@&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;0}: reset: moving to HEAD^&lt;/span&gt;
&lt;span class="x"&gt;a5feb75 HEAD@&lt;/span&gt;&lt;span class="err"&gt;{&lt;/span&gt;&lt;span class="x"&gt;1}: commit: add bigfiles&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这只会清空90天前的数据，可以带&lt;code&gt;date&lt;/code&gt;参数来指定日期：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git reflog expire --expire&lt;span class="o"&gt;=&lt;/span&gt;now --all
&lt;span class="nv"&gt;$ &lt;/span&gt;git reflog
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;此时记录全部清除，可以使用&lt;code&gt;fsck&lt;/code&gt;和&lt;code&gt;prune&lt;/code&gt;了：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git fsck
Checking object directories: 100% &lt;span class="o"&gt;(&lt;/span&gt;256/256&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
Checking objects: 100% &lt;span class="o"&gt;(&lt;/span&gt;65/65&lt;span class="o"&gt;)&lt;/span&gt;, &lt;span class="k"&gt;done&lt;/span&gt;.
dangling commit a5feb75fd7255b0085b92448a14d2fae62ea75be
&lt;span class="nv"&gt;$ &lt;/span&gt;git prune
&lt;span class="nv"&gt;$ &lt;/span&gt;du -sh .git/
164K    .git/
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;git gc&lt;/h4&gt;
&lt;p&gt;实际使用中很少使用&lt;code&gt;prune&lt;/code&gt;，而是使用&lt;code&gt;git gc&lt;/code&gt;，该命令可以执行一系列的优化：主要是打包文件，丢弃过期的历史，清除未关联的对象等等。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; gc&lt;/span&gt;
&lt;span class="x"&gt;//将未关联的对象从打包文件中移出，成为松散文件&lt;/span&gt;
&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; gc --expire=now&lt;/span&gt;
&lt;span class="x"&gt;//直接清除未关联的文件，释放存储空间&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实际中，git的某些操作会自动执行&lt;code&gt;gc&lt;/code&gt;命令，因此不需要手动执行&lt;code&gt;gc&lt;/code&gt;进行版本库的清理了。&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>App Extension Study 3</title><link href="http://icocoa.tk/app-extension-study-3.html" rel="alternate"></link><updated>2014-11-14T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-14:app-extension-study-3.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;第一篇&lt;/a&gt;介绍了Extension的基本概念，Extension的运行周期，和containing app的数据共享等细节，&lt;a href="http://github.icocoa.tk/app-extension-study-2.html"&gt;第二篇&lt;/a&gt;介绍并实践了4种extension，而本篇就要介绍Sync和File Provider。 &lt;/p&gt;
&lt;h3&gt;2 Finder Sync (OS X)&lt;/h3&gt;
&lt;p&gt;因为extension要运行在10.10的OS X上，由于没升级，所以本节就侧重“理论”了。  &lt;/p&gt;
&lt;h4&gt;2.1 含义&lt;/h4&gt;
&lt;p&gt;顾名思义，就是保持本地的某些文件夹和远程的文件夹内容保持一致。它可以让用户在Finder实时察觉同步的状态并随时控制同步的进程。比如说可以在文件夹上加badge或是文字来告诉用户当前的状态，或是在Finder窗口添加工具栏方便打开监视的文件夹或强制退出同步(不知道网盘类的应用如何集成该extension呢)。因此，&lt;code&gt;Finder Sync&lt;/code&gt;的host app只能是&lt;code&gt;Finder&lt;/code&gt;。&lt;br/&gt;
&lt;code&gt;Finder Sync&lt;/code&gt;可以：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;注册一系列文件夹进行同步&lt;/li&gt;
&lt;li&gt;当用户打开/退出上述文件夹时会收到通知&lt;/li&gt;
&lt;li&gt;可以添加/移除/更新该文件夹上的badge&lt;/li&gt;
&lt;li&gt;在注册的文件夹内，通过control点击内容后会弹出文本彩蛋&lt;/li&gt;
&lt;li&gt;可以给Finder的工具栏添加按钮&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;2.2模版文件&lt;/h4&gt;
&lt;p&gt;plist文件和widget中的类似，默认的类是&lt;code&gt;FIFinderSync&lt;/code&gt;子类，实现文件中预先生成的方法很好的解释了FinderSync的工作流程。&lt;br/&gt;
首先是&lt;code&gt;init&lt;/code&gt;,  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;instancetype&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;init&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%s launched from %@ ; compiled at %s"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;__PRETTY_FUNCTION__&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSBundle&lt;/span&gt; &lt;span class="n"&gt;mainBundle&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;bundlePath&lt;/span&gt;&lt;span class="p"&gt;],&lt;/span&gt; &lt;span class="n"&gt;__TIME__&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// Set up the directory we are syncing.&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myFolderURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="nl"&gt;fileURLWithPath&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"/Users/Shared/MySyncExtension Documents"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;].&lt;/span&gt;&lt;span class="n"&gt;directoryURLs&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSSet&lt;/span&gt; &lt;span class="nl"&gt;setWithObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myFolderURL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;// Set up images for our badge identifiers. For demonstration purposes, this uses off-the-shelf images.&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeImage&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSImageNameColorPanel&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;label&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Status One"&lt;/span&gt; &lt;span class="nl"&gt;forBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"One"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeImage&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;NSImageNameCaution&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;label&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Status Two"&lt;/span&gt; &lt;span class="nl"&gt;forBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Two"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化函数中主要做的就是注册要同步的文件夹，可以是多个。通常指定的文件夹是在containing app中操作的，因此需要用到&lt;code&gt;share group&lt;/code&gt;来共享数据。所以，实际中会通过&lt;code&gt;NSUserDefaults&lt;/code&gt;来读取，然后再注册。除此之外，还可以进行badge等修饰。这里badge的图片里不能有padding(我的理解就是图片的内容都要顶边)，此外还有像素的限制：  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;retina屏： 12x12-320x320&lt;/li&gt;
&lt;li&gt;非retina屏： 8x8-160x160&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来就是实现一系列&lt;code&gt;FIFinderSync&lt;/code&gt;协议：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;beginObservingDirectoryAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// The user is now seeing the container's contents.&lt;/span&gt;
&lt;span class="c1"&gt;// If they see it in more than one view at a time, we're only told once.&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"beginObservingDirectoryAtURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户打开同步文件夹或其子文件夹时，调用此方法，查看的文件夹路径作为&lt;code&gt;url&lt;/code&gt;参数传入。&lt;br/&gt;
和打开香对应的，有关闭浏览同步文件夹的协议： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;endObservingDirectoryAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// The user is no longer seeing the container's contents.&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"endObservingDirectoryAtURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;还有一个协议，当同步文件夹里的内容要显示的时候，会调用：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;requestBadgeIdentifierForURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"requestBadgeIdentifierForURL:%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;

&lt;span class="c1"&gt;// For demonstration purposes, this picks one of our two badges, or no badge at all, based on the filename.&lt;/span&gt;
&lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;whichBadge&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;filePathURL&lt;/span&gt; &lt;span class="n"&gt;hash&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="o"&gt;%&lt;/span&gt; &lt;span class="mi"&gt;3&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;badgeIdentifier&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"One"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="s"&gt;@"Two"&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;whichBadge&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;FIFinderSyncController&lt;/span&gt; &lt;span class="n"&gt;defaultController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setBadgeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;badgeIdentifier&lt;/span&gt; &lt;span class="nl"&gt;forURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;如例子所做的那样，文件夹内的每个内容显示的时候会调用该协议，然后extension根据一些条件(比如文件的名字等)来决定是否加badge以及加哪种badge。&lt;/p&gt;
&lt;p&gt;接下来就是菜单和工具栏相关的协议：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;menuForMenuKind:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;FIMenuKind&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;whichMenu&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Produce a menu for the extension.&lt;/span&gt;
    &lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;NSMenu&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;menu&lt;/span&gt; &lt;span class="nl"&gt;addItemWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"Example Menu Item"&lt;/span&gt; &lt;span class="nl"&gt;action&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="k"&gt;@selector&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nl"&gt;sampleAction&lt;/span&gt;&lt;span class="p"&gt;:)&lt;/span&gt; &lt;span class="nl"&gt;keyEquivalent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@""&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;menu&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;实现自定义的菜单就要实现该协议，根据不同的&lt;code&gt;FIMenuKind&lt;/code&gt;,提供不同的菜单。  &lt;/p&gt;
&lt;p&gt;接下来是在Finder窗口添加自定义的工具按钮：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemName&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;@"FinderSynTest"&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemToolTip&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="s"&gt;@"FinderSynTest: Click the toolbar item for a menu."&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;toolbarItemImage&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;NSImage&lt;/span&gt; &lt;span class="nl"&gt;imageNamed&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSImageNameCaution&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当用户点击按钮后，系统就会调用之前的&lt;code&gt;menuForMenuKind:&lt;/code&gt;方法，并把&lt;code&gt;FIMenuKindToolbarItemMenu&lt;/code&gt;类参数传入。&lt;/p&gt;
&lt;h4&gt;2.3 Finder Sync典型用例&lt;/h4&gt;
&lt;p&gt;因为同步文件夹内可以会有很多很多的内容，这时候效率就显得特别重要了。适时更新就显得尤为重要，简单的说就是lazy-load，需要用到的时候再去加载，可见的时候才有必要去更新。&lt;code&gt;Finder Sync&lt;/code&gt;的典型运作流程：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当打开同步文件夹或子文件夹时，系统调用&lt;code&gt;beginObservingDirectoryAtURL:&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;对于要显示的每个子内容，系统调用&lt;code&gt;requestBadgeIdentifierForURL:&lt;/code&gt;，在这个方法里主要做：
    a. 检查每个子内容的状态，然后来调用&lt;code&gt;setBadgeIdentifier:forURL:&lt;/code&gt;，这里的状态由app自己来定义，比如：正在同步，同步出错，同步成功
    b. 对于设置badge的子内容，要记录下来。&lt;/li&gt;
&lt;li&gt;当关闭窗口时，调用&lt;code&gt;endObservingDirectoryAtURL:&lt;/code&gt;，删除所有在2.b中记录的内容，并停止检测文件夹的状态&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3 Document Provider&lt;/h3&gt;
&lt;h4&gt;3.1 Document Provider是什么&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;Document Provider&lt;/code&gt;充当containing app管理的文件和其他 app 之间的“中介”，该中介可以让其他app &lt;code&gt;导入&lt;/code&gt;或是&lt;code&gt;打开&lt;/code&gt;文件，可以从服务器上&lt;code&gt;上传&lt;/code&gt;/&lt;code&gt;下载&lt;/code&gt;文件，也可以&lt;code&gt;导出&lt;/code&gt;/&lt;code&gt;移动&lt;/code&gt;文件到扩展的共享数据区。因此，&lt;code&gt;Document Provider&lt;/code&gt;由2个独立的extension组成：一个是&lt;code&gt;Document Picker View Controller extension&lt;/code&gt;(简称&lt;code&gt;picker extension&lt;/code&gt;)，另一个则是&lt;code&gt;File Provider extension&lt;/code&gt;(简称&lt;code&gt;provider extension&lt;/code&gt;)。前者负责将可供使用的文件展示给用户，后者则根据用户选择的类型(指导入，打开，导出，移动等4种类型)提供相应的服务。在host app中，通过&lt;code&gt;UIDocumentPickerViewController&lt;/code&gt;或是&lt;code&gt;UIDocumentMenuViewController&lt;/code&gt;调用&lt;code&gt;picker extension&lt;/code&gt;，extesnion根据实际需要把相关的文件呈现给用户，供用户选择；用户选择完毕后，有需要的话，再去运行&lt;code&gt;provider extension&lt;/code&gt;。这里说“有需要”是因为理想情况下，&lt;code&gt;Document Provide&lt;/code&gt;r最好支持上述4种类型，但不是必须。同时，只有打开和移动操作是一定要提供&lt;code&gt;provider extension&lt;/code&gt;的，因为导入导出操作可只与共享数据区进行数据交换：比如说只是备份文件。&lt;br/&gt;
需要注意的是，iCloud也“集成”了该类型的扩展，就是说如果app启用了icloud，那么可以查看icloud的文件并选择操作。启用iCloud需要在plist文件中添加类似如下的属性：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainers&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;iCloud.com.example.MyApp&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerIsDocumentScopePublic&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;true/&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerSupportedFolderLevels&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;Any&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSUbiquitousContainerName&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MyApp&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;3.2 picker extension&lt;/h4&gt;
&lt;p&gt;新建一个&lt;code&gt;File Provider&lt;/code&gt;，在导航上就可以看到Xcode会提供是否要创建&lt;code&gt;provider extension&lt;/code&gt;的选项，一并勾上，然后来观察程序创建了2个target。先看&lt;code&gt;picker extension&lt;/code&gt;的plist文件： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;UIDocumentPickerModes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeImport&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeOpen&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeExportToService&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;UIDocumentPickerModeMoveToService&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;UIDocumentPickerSupportedFileTypes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;public.content&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.fileprovider-ui&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;键&lt;code&gt;UIDocumentPickerModes&lt;/code&gt;设置了支持的操作类型，而&lt;code&gt;UIDocumentPickerSupportedFileTypes&lt;/code&gt;则设置了支持的文件类型，&lt;code&gt;public.content&lt;/code&gt;说明支持所有的文件。
再来看模版文件，可以看到&lt;code&gt;picker extension&lt;/code&gt;的实现是继承&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt;的子类，下图是&lt;code&gt;picker extension&lt;/code&gt;的示例界面：&lt;br/&gt;
&lt;img alt="picker_ui" src="./imgs/20141117/picker_ui.png"/&gt;&lt;/p&gt;
&lt;p&gt;顶部的Bar是系统提供的，程序内无法自定义。左边的location是切换不同的文件来源，因为iPhone上可以安装多个提供了document provider的containing app。Bar下面的部分就是可以定制的picker extension的界面，完全在&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt;中自定义。&lt;br/&gt;
picker extension的生命周期：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;host app弹出&lt;code&gt;UIDocumentMenuViewController&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;用户选择了你的&lt;code&gt;picker extension&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;初始化&lt;code&gt;UIDocumentPickerViewExtensionViewController&lt;/code&gt;子类&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;方法，根据&lt;code&gt;UIDocumentPickerMode&lt;/code&gt;，展示不同的界面&lt;/li&gt;
&lt;li&gt;此时，extension的界面已经在host app中展示好&lt;/li&gt;
&lt;li&gt;当用户选择后，extension做相应的操作，然后&lt;em&gt;必须&lt;/em&gt;调用&lt;code&gt;dismissGrantingAccessToURL:&lt;/code&gt;方法推出界面，并把文件的URL作为参数传递给host app，以便host app执行代理：&lt;code&gt;-[UIDocumentPickerViewControllerDelegate documentPicker:didPickDocumentAtURL:]&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;UIDocumentPickerExtensionViewController&lt;/code&gt; 消失&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;由此可见，实现&lt;code&gt;picker extension&lt;/code&gt;的关键就是重载&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;以及调用&lt;code&gt;dismissGrantingAccessToURL:&lt;/code&gt;。前者是负责界面，后者是负责用户操作的响应。前者主要关心不同类型的界面展示，比如导出操作和打开不一样，肯定要有一个导出场所。其他的需求例如是只显示支持的文件类型还是显示所有类型但标记不支持的文件类型等，也是在&lt;code&gt;prepareForPresentationInMode:&lt;/code&gt;中实现。而相应的，以及调用&lt;code&gt;dismissGrantingAccessToURL&lt;/code&gt;就是退出extension的必须，这个只是调用而不用重载。传递的URL参数代表用户选中的文件类型。根据不同的操作类型，URL参数有不同的要求： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;导入：本地文件类型。如果选择的是远程服务器上的文件，那么需要先下载到本地方能调用dismiss&lt;/li&gt;
&lt;li&gt;打开：如果指定的文件不存在，&lt;code&gt;provider extension&lt;/code&gt;会去创建。该地址必须是位于&lt;code&gt;provider extension&lt;/code&gt;属性&lt;code&gt;documentStorageURL&lt;/code&gt;指定的文件夹路径下面&lt;/li&gt;
&lt;li&gt;导出：只有&lt;code&gt;picker extension&lt;/code&gt;可以访问的URL，系统会在该URL下复制一份文件并返回给host app，表明导出操作成功。但是，host app无法通过该URL访问文件&lt;/li&gt;
&lt;li&gt;移动：和打开类型一样，位于&lt;code&gt;documentStorageURL&lt;/code&gt;下面，系统会将文件移动到该URL，并把URL返回给host app，但此时host app可以访问。&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;此外，如果涉及到用户授权，可以在extension中实现，也可以使用通知的方式在containing app中实现。&lt;/p&gt;
&lt;h4&gt;3.3 provider extension&lt;/h4&gt;
&lt;p&gt;如果picker提供打开和导出功能，那么就一定要实现&lt;code&gt;provider extension&lt;/code&gt;。provider可以在host app之外打开/移动文件，可以让host app下载文件。&lt;br/&gt;
对于远程未下载的文件，&lt;code&gt;provider extension&lt;/code&gt;是用&lt;code&gt;placeholder&lt;/code&gt;代替，通过&lt;code&gt;fileCoordinator&lt;/code&gt;实现读写。文件的变化会以通知的方式传递给extension，以便作出相应的变化。&lt;br/&gt;
接下来还是先看plist文件：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionFileProviderDocumentGroup&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.devpubs&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.fileprovider-nonui&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPrincipalClass&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;FileProvider&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;code&gt;NSExtensionFileProviderDocumentGroup&lt;/code&gt;定义了可以访问的组，该值也同样在entitle文件中声明：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;com.apple.security.application-groups&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;array&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.devpubs&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/array&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;紧接着看代码，实现部分是&lt;code&gt;NSFileProviderExtension&lt;/code&gt;的子类，该类的头文件中着重注明了2个类只能调用不需要重载：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;BOOL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;writePlaceholderAtURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderURL&lt;/span&gt; &lt;span class="nt"&gt;withMetadata&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSDictionary&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;metadata&lt;/span&gt; &lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;**)&lt;/span&gt;&lt;span class="nt"&gt;error&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="o"&gt;+&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderURLForURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;主要作用是为未下载的文件创建&lt;code&gt;placeholder&lt;/code&gt;，&lt;code&gt;metadata&lt;/code&gt;通常包含文件大小，名字以及缩略图。
接下来是必须重载的方法，模版文件中主要有：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;providePlaceholderAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nf"&gt;completionHandler:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Should call + writePlaceholderAtURL:withMetadata:error: with the placeholder URL, then call the completion handler with the error if applicable.&lt;/span&gt;
    &lt;span class="bp"&gt;NSString&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileName&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="n"&gt;lastPathComponent&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSFileProviderExtension&lt;/span&gt; &lt;span class="nl"&gt;placeholderURLForURL&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;documentStorageURL&lt;/span&gt; &lt;span class="nl"&gt;URLByAppendingPathComponent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fileName&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;

    &lt;span class="n"&gt;NSUInteger&lt;/span&gt; &lt;span class="n"&gt;fileSize&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="c1"&gt;// TODO: get file size for file at &amp;lt;url&amp;gt; from model&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

        &lt;span class="bp"&gt;NSDictionary&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@{&lt;/span&gt; &lt;span class="nl"&gt;NSURLFileSizeKey&lt;/span&gt; &lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="l"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;fileSize&lt;/span&gt;&lt;span class="l"&gt;)}&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSFileProviderExtension&lt;/span&gt; &lt;span class="nl"&gt;writePlaceholderAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;placeholderURL&lt;/span&gt; &lt;span class="nl"&gt;withMetadata&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;metadata&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;startProvidingItemAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="nf"&gt;completionHandler:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="nv"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Should ensure that the actual file is in the position returned by URLForItemWithIdentifier:, then call the completion handler&lt;/span&gt;
    &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;__block&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt;&lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileError&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;

    &lt;span class="bp"&gt;NSData&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt; &lt;span class="n"&gt;fileData&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;NSData&lt;/span&gt; &lt;span class="n"&gt;data&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="c1"&gt;// TODO: get the contents of file at &amp;lt;url&amp;gt; from model&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;fileData&lt;/span&gt; &lt;span class="nl"&gt;writeToURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;&amp;amp;&lt;/span&gt;&lt;span class="n"&gt;fileError&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="o"&gt;!=&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt; &lt;span class="k"&gt;else&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;fileError&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;当文件开始读取的时候，上述2个方法都会被触发。触发的先后视情况而定。和iCloud一样，操作文件是使用&lt;code&gt;NSFileCoordinator&lt;/code&gt;。对于未下载的情形，第一个方法首先执行，在该方法中首先创建&lt;code&gt;placeholder&lt;/code&gt;，然后调用&lt;code&gt;coordinate&lt;/code&gt;方法写文件，最后务必调用&lt;code&gt;completionHandler&lt;/code&gt;。第二个方法执行的内容和第一个差不多，只是不需要创建&lt;code&gt;placeholder&lt;/code&gt;，所以这里要注意确认url指定的路径下，文件是否存在。
接下来就是文件有变化时，收到的通知：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;itemChangedAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Called at some point after the file has changed; the provider may then trigger an upload&lt;/span&gt;

    &lt;span class="c1"&gt;// TODO: mark file at &amp;lt;url&amp;gt; as needing an update in the model; kick off update process&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Item changed at URL %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="n"&gt;url&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在这里，需要自行设计，文件变化后尤其是产生冲突后的处理。&lt;/p&gt;
&lt;p&gt;最后一个就是：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;stopProvidingItemAtURL:&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nv"&gt;url&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="c1"&gt;// Called after the last claim to the file has been released. At this point, it is safe for the file provider to remove the content file.&lt;/span&gt;
    &lt;span class="c1"&gt;// Care should be taken that the corresponding placeholder file stays behind after the content file has been deleted.&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;fileCoordinator&lt;/span&gt; &lt;span class="nl"&gt;coordinateWritingItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;NSFileCoordinatorWritingForDeleting&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt; &lt;span class="nl"&gt;byAccessor&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSFileManager&lt;/span&gt; &lt;span class="n"&gt;defaultManager&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;removeItemAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;newURL&lt;/span&gt; &lt;span class="nl"&gt;error&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;providePlaceholderAtURL&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;url&lt;/span&gt; &lt;span class="nl"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NULL&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该方法是系统检测到没有进程调用该文件时触发的，这里可以把文件从共享区域中删除以节省空间。 
另外还有4个方法可以重载：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;An&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt; &lt;span class="nt"&gt;unique&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;provider&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;When&lt;/span&gt; &lt;span class="nt"&gt;modifying&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;files&lt;/span&gt; &lt;span class="nt"&gt;stored&lt;/span&gt; &lt;span class="nt"&gt;in&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;directory&lt;/span&gt; &lt;span class="nt"&gt;returned&lt;/span&gt; &lt;span class="nt"&gt;by&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;you&lt;/span&gt; &lt;span class="nt"&gt;should&lt;/span&gt; &lt;span class="nt"&gt;pass&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;your&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt; &lt;span class="nt"&gt;coordinator&lt;/span&gt;&lt;span class="s1"&gt;'s setPurposeIdentifier: method.&lt;/span&gt;
&lt;span class="s1"&gt;// By default, this returns the bundle identifier of the application containing your extension. You need to make sure to use the same identifier in your containing app.&lt;/span&gt;
&lt;span class="s1"&gt;- (NSString *)providerIdentifier;&lt;/span&gt;

&lt;span class="s1"&gt;// The root URL for provided documents. This URL must be writable from your app extension, and must only be used for the extension'&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt; &lt;span class="nt"&gt;files&lt;/span&gt; &lt;span class="nt"&gt;or&lt;/span&gt; &lt;span class="nt"&gt;their&lt;/span&gt; &lt;span class="nt"&gt;placeholders&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;Should&lt;/span&gt; &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;URL&lt;/span&gt; &lt;span class="nt"&gt;corresponding&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;specific&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt; &lt;span class="nt"&gt;Fail&lt;/span&gt; &lt;span class="nt"&gt;if&lt;/span&gt; &lt;span class="nt"&gt;it&lt;/span&gt;&lt;span class="err"&gt;'&lt;/span&gt;&lt;span class="nt"&gt;s&lt;/span&gt; &lt;span class="nt"&gt;not&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;subpath&lt;/span&gt; &lt;span class="nt"&gt;of&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;This&lt;/span&gt; &lt;span class="nt"&gt;is&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;static&lt;/span&gt; &lt;span class="nt"&gt;mapping&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt; &lt;span class="nt"&gt;each&lt;/span&gt; &lt;span class="nt"&gt;identifier&lt;/span&gt; &lt;span class="nt"&gt;must&lt;/span&gt; &lt;span class="nt"&gt;always&lt;/span&gt; &lt;span class="nt"&gt;return&lt;/span&gt; &lt;span class="nt"&gt;a&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;corresponding&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;same&lt;/span&gt; &lt;span class="nt"&gt;file&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="o"&gt;//&lt;/span&gt; &lt;span class="nt"&gt;By&lt;/span&gt; &lt;span class="nt"&gt;default&lt;/span&gt;&lt;span class="o"&gt;,&lt;/span&gt; &lt;span class="nt"&gt;this&lt;/span&gt; &lt;span class="nt"&gt;returns&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;relative&lt;/span&gt; &lt;span class="nt"&gt;to&lt;/span&gt; &lt;span class="nt"&gt;the&lt;/span&gt; &lt;span class="nt"&gt;path&lt;/span&gt; &lt;span class="nt"&gt;returned&lt;/span&gt; &lt;span class="nt"&gt;by&lt;/span&gt; &lt;span class="nt"&gt;documentStorageURL&lt;/span&gt;&lt;span class="o"&gt;.&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;URLForItemWithPersistentIdentifier&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;identifier&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;persistentIdentifierForItemAtURL&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;url&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;但是因为通常情况下，重载这些方法会影响到plist和entitlement中的设置，所以一般情况下也可以认为是不需要重载的。&lt;br/&gt;
需要说明的是，文档中指出如果在8.0上使用了&lt;code&gt;iCloud Drive&lt;/code&gt;，那么访问文件需要使用&lt;code&gt;UIDocument&lt;/code&gt;或是&lt;code&gt;NSFileProviderExtension&lt;/code&gt;，而不要使用&lt;code&gt;NSFileCoordinator&lt;/code&gt;。
最后WWDC2014中有一个&lt;a href="http://adcdownload.apple.com//wwdc_2014/wwdc_2014_sample_code/newboxanintroductiontoiclouddocumentenhancementsinios8.0.zip"&gt;示例&lt;/a&gt;，可以下载后研究下。&lt;/p&gt;
&lt;h3&gt;End&lt;/h3&gt;
&lt;p&gt;以上介绍了&lt;code&gt;Finder Sync&lt;/code&gt;和&lt;code&gt;File Provider&lt;/code&gt;的，还剩下&lt;code&gt;Custom Keyboard&lt;/code&gt;，下文完结。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>Pelican若干问题汇总</title><link href="http://icocoa.tk/pelicanruo-gan-wen-ti-hui-zong.html" rel="alternate"></link><updated>2014-11-09T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-09:pelicanruo-gan-wen-ti-hui-zong.html</id><summary type="html">&lt;p&gt;前几天感冒，鼻塞导致做任何事情都没有精力，只能花点时间整理pelican使用中遇到的一些问题。&lt;/p&gt;
&lt;h4&gt;WARNING: No valid files found in content.&lt;/h4&gt;
&lt;p&gt;使用&lt;code&gt;fab build&lt;/code&gt;后命令行中出现如下的警告:&lt;/p&gt;
&lt;blockquote&gt;
&lt;p&gt;[localhost] local: pelican -s pelicanconf.py
WARNING: No valid files found in content.
WARNING: Could not process content/output/archives.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/authors.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/categories.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/index.html
'NoneType' object has no attribute 'lower'
WARNING: Could not process content/output/tags.html
'NoneType' object has no attribute 'lower'
Done: Processed 18 articles and 0 pages in 2.23 seconds.&lt;/p&gt;
&lt;/blockquote&gt;
&lt;p&gt;虽然生成了文章，但总感觉怪怪的。也许是强迫症，不过修改这个警告也让我学会了一些东西。&lt;br/&gt;
首先确认了&lt;code&gt;md&lt;/code&gt;文件中语法格式没有问题，接下来重新安装了&lt;code&gt;markdown&lt;/code&gt;，&lt;code&gt;pelican&lt;/code&gt;和&lt;code&gt;Fabric&lt;/code&gt;，确保不是软件引起的问题。更新后，警告依然存在，于是google，第一页出现了很多强相关性的链接，专注github上的issue。先找的是&lt;a href="https://github.com/getpelican/pelican/issues/1097"&gt;issue 1097&lt;/a&gt;，尝试运行&lt;code&gt;pelican --debug&lt;/code&gt;，发现没有有效的提示信息。再看&lt;a href="https://github.com/getpelican/pelican/issues/1116"&gt;issue 1116&lt;/a&gt;，这个帖子的方法是修改&lt;code&gt;fabfile.py&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;build&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="kd"&gt;local&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'pelican content/ -s pelicanconf.py'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="nx"&gt;def&lt;/span&gt; &lt;span class="nx"&gt;regenerate&lt;/span&gt;&lt;span class="p"&gt;():&lt;/span&gt;
    &lt;span class="kd"&gt;local&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s1"&gt;'pelican content/ -r -s pelicanconf.py'&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;照做然后&lt;code&gt;build&lt;/code&gt;后，警告消失了，此外还把page不生成的问题解决了&lt;/p&gt;
&lt;h4&gt;Pages不生成&lt;/h4&gt;
&lt;p&gt;在content文件夹下添加了&lt;code&gt;pages&lt;/code&gt;文件夹，写入了一些md文件，但发现总是生成不了。一度怀疑是pages中的md文件需要独特的语法：比如有特定的metadata需要写入，或是选用的主题不支持pages。当折腾大半天的时候，却发现上述的警告产生的原因也是该问题产生的凶手！顺便说一下，该问题也导致&lt;code&gt;disqus&lt;/code&gt;评论系统加载不上去。&lt;br/&gt;
所以，千万不要忽视警告，尤其是让人觉得不影响最终运行的情况。&lt;/p&gt;</summary><category term="python"></category><category term="pelican"></category></entry><entry><title>文件权限</title><link href="http://icocoa.tk/wen-jian-quan-xian.html" rel="alternate"></link><updated>2014-11-09T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-09:wen-jian-quan-xian.html</id><summary type="html">&lt;h4&gt;权限&lt;/h4&gt;
&lt;p&gt;Linux系统中对文件/目录的权限设置是很重要的部分，通常通过&lt;code&gt;ls&lt;/code&gt;来查看：
    ls -l README
    -rw-r--r--   1 xxxx  staff    234 Nov  9 11:27 README
说明：&lt;br/&gt;
第一列就是权限，有10位，从左至右第一位表示文件的类型，&lt;strong&gt;-__表示是文件，__d__表示是目录。接下来的9位分成3组，分别对应文件拥有者，共享文件所在组以及其他用户拥有的权限。__r__表示可读，__w__表示可写，__x__表示可执行，&lt;/strong&gt;-__表示没有该项权限。&lt;br/&gt;
第二列数字1表示索引节点的目录连接。
第三列就是文件拥有者的名字，第四列则是共享文件所在组。
第五列是文件的字节数，第六、七、八列是时间，最后一列是名字。
其中文件权限可以用二进制表达，该例对应的则是： &lt;code&gt;110100100&lt;/code&gt;，用十进制表达则是： &lt;code&gt;644&lt;/code&gt;。因此，有时候修改权限 &lt;code&gt;777&lt;/code&gt;的时候，就一定要小心了，要么是小白行为，要么就是带有恶意。  &lt;/p&gt;
&lt;h4&gt;SUID/SGID&lt;/h4&gt;
&lt;p&gt;通常情况下，执行一个程序时，相应的进程具有&lt;strong&gt;执行这一程序的用户&lt;/strong&gt;的权限，但有时这并没有赋予进程正确完成任务所必要的权限。这个时候，可以直接修改文件权限以满足程序的运行，但是这样可能会对系统安全造成伤害。Linux系统的解决办法是设置SUID/SGID使得用户分别以&lt;em&gt;程序拥有者&lt;/em&gt;或&lt;em&gt;用户组&lt;/em&gt;的权限，而不是它自己的权限去运行程序。&lt;br/&gt;
这里SUID代表 "set user ID"，SGID则代表 "set group ID"，同时设置SUID和SGID的话，SUID的优先级高。&lt;br/&gt;
设置的方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;chmod u+s filename //设置SUID位
chmod u-s filename //去掉SUID设置
chmod g+s filename //设置SGID位
chmod g-s filename //去掉SGID设置
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;举个例子：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;ls -l
total 8
-rw-r--r--  &lt;span class="m"&gt;1&lt;/span&gt; xxxxxx  staff  &lt;span class="m"&gt;3&lt;/span&gt; Nov  &lt;span class="m"&gt;9&lt;/span&gt; 16:51 hello
&lt;span class="nv"&gt;$ &lt;/span&gt;chmod u+s hello 
&lt;span class="nv"&gt;$ &lt;/span&gt;ls -l
total 8
-rwSr--r--  &lt;span class="m"&gt;1&lt;/span&gt; xxxxxx  staff  &lt;span class="m"&gt;3&lt;/span&gt; Nov  &lt;span class="m"&gt;9&lt;/span&gt; 16:51 hello
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为原本的拥有者不具备&lt;code&gt;x&lt;/code&gt;权限，所以设置后显示&lt;code&gt;S&lt;/code&gt;；如果有对应的 &lt;code&gt;x&lt;/code&gt;权限，设置后则会显示 &lt;code&gt;s&lt;/code&gt;。&lt;/p&gt;</summary><category term="security"></category></entry><entry><title>iOS8下控件的旋转</title><link href="http://icocoa.tk/ios8xia-kong-jian-de-xuan-zhuan.html" rel="alternate"></link><updated>2014-11-07T16:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-07:ios8xia-kong-jian-de-xuan-zhuan.html</id><summary type="html">&lt;h4&gt;由起&lt;/h4&gt;
&lt;p&gt;使用iOS8 SDK编译后的项目在ipad上运行发现某些控件如HUD弹出后它的位置有了旋转，但是该现象在iOS8的iphone设备上却没有出现。果断认为是iOS8SDK引起的，需要做紧急修复。&lt;/p&gt;
&lt;h4&gt;修复&lt;/h4&gt;
&lt;p&gt;代码中迅速找到&lt;code&gt;rotation&lt;/code&gt;的相关部分，发现已经是使用&lt;code&gt;[[UIApplication sharedApplication] statusBarOrientation]&lt;/code&gt;，那应该不会是方向获取错误导致的。那姑且以为是iPad上特有的现象，于是加了设备的判断，测试通过！可惜在iOS7的iPad上还是有问题，正当烦恼之际，突然想起之前的某个&lt;a href="https://github.com/wimagguc/ios-custom-alertview/issues/50"&gt;issue&lt;/a&gt;，果然是同样的问题，最终的解决方案是: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;if (floor(NSFoundationVersionNumber) &amp;lt;= NSFoundationVersionNumber_iOS_7_1)
    {
        switch (interfaceOrientation) {
            case UIInterfaceOrientationLandscapeLeft:
                self.transform = CGAffineTransformMakeRotation(M_PI * 270.0 / 180.0);
                break;

            case UIInterfaceOrientationLandscapeRight:
                self.transform = CGAffineTransformMakeRotation(M_PI * 90.0 / 180.0);
                break;

            case UIInterfaceOrientationPortraitUpsideDown:
                self.transform = CGAffineTransformMakeRotation(M_PI * 180.0 / 180.0);
                break;

            default:
                break;
        }
    }
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;问题最终解决，不过这个bug倒是满奇怪的，希望给遇到同样问题的人一个帮助。&lt;/p&gt;</summary><category term="ios8"></category></entry><entry><title>iOS8之UIAlertController</title><link href="http://icocoa.tk/ios8zhi-uialertcontroller.html" rel="alternate"></link><updated>2014-11-05T11:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-05:ios8zhi-uialertcontroller.html</id><summary type="html">&lt;h4&gt;由起&lt;/h4&gt;
&lt;p&gt;&lt;code&gt;UIAlertController&lt;/code&gt;是iOS8中引入的，用于整合&lt;code&gt;UIAlertView&lt;/code&gt;和&lt;code&gt;UIActionSheet&lt;/code&gt;的新类，在实现中抛弃了之前的delegate用法，而采用了block的方式，从而使得使用和可读性都简化了不少。&lt;br/&gt;
使用iOS8SDK编译的项目，大多数情况使用之前的&lt;code&gt;UIAlertView&lt;/code&gt;或&lt;code&gt;UIActionSheet&lt;/code&gt;都不会产生问题，如果有问题了，那就需要使用新类了。比如，一个项目中iPad上调用&lt;code&gt;[actionSheet showFromToolbar:]&lt;/code&gt;产生错误：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;2014-11-05 10:50:26.614 XXXXXX[467:78104] Presenting view controllers on detached view controllers is discouraged &amp;lt;UIViewController: 0x17ea3470&amp;gt;.
2014-11-05 10:50:26.762 XXXXXX[467:78104] *** Terminating app due to uncaught exception 'NSGenericException', reason: 'Your application has presented a UIAlertController (&amp;lt;UIAlertController: 0x17e73620&amp;gt;) of style UIAlertControllerStyleActionSheet. The modalPresentationStyle of a UIAlertController with this style is UIModalPresentationPopover. You must provide location information for this popover through the alert controller's popoverPresentationController. You must provide either a sourceView and sourceRect or a barButtonItem.  If this information is not known when you present the alert controller, you may provide it in the UIPopoverPresentationControllerDelegate method -prepareForPopoverPresentation.'
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;从奔溃日志中可以看出，虽然代码中使用的是&lt;code&gt;UIActionSheet&lt;/code&gt;，实际运行时却已经是&lt;code&gt;UIAlertController&lt;/code&gt;了。&lt;/p&gt;
&lt;h4&gt;使用&lt;/h4&gt;
&lt;p&gt;使用非常简单，基本用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//初始化alert controller&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertController&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertController&lt;/span&gt; &lt;span class="nl"&gt;alertControllerWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"xxxx"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;message&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;preferredStyle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertControllerStyleActionSheet&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//创建一个操作&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;fileAction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="nl"&gt;actionWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"action1"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;style&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertActionStyleDefault&lt;/span&gt; &lt;span class="nl"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="n"&gt;doAction1&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="c1"&gt;//添加操作&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;addAction&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;fileAction&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;//&lt;/span&gt;
&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;cancelAction&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="nl"&gt;actionWithTitle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;ZJLocalizedString&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"Cancel"&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="nl"&gt;style&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIAlertActionStyleCancel&lt;/span&gt; &lt;span class="nl"&gt;handler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIAlertAction&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;action&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;addAction&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;cancelAction&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="c1"&gt;//展示alert controller   &lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt; &lt;span class="nl"&gt;presentViewController&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;alertController&lt;/span&gt; &lt;span class="nl"&gt;animated&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;YES&lt;/span&gt; &lt;span class="nl"&gt;completion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;

    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;初始化controller的时候，通过&lt;code&gt;UIAlertActionStyle&lt;/code&gt;来选择哪种式样，然后就创建一系列action，并添加到controller，最后把controller用present的方式展示出来。对于以前alert上带文字的式样，新API也贴心的提供了&lt;code&gt;addTextFieldWithConfigurationHandler:(void (^)(UITextField *textField))configurationHandler&lt;/code&gt;方法来简化操作。  &lt;/p&gt;
&lt;p&gt;可见，新API最大的特点无疑就是吸取了开源社区中已有的block的实现，这样最大限度的简化了代码，并且带来了无与伦比的可读性。由于新API中action的初始化是类方法，如果action不作为类成员的话，也不需要考虑block的循环引用问题。&lt;/p&gt;
&lt;h4&gt;结束&lt;/h4&gt;
&lt;p&gt;iOS8对API的更新还是挺大的，比如&lt;code&gt;UIPopoverViewController&lt;/code&gt;兼容iPad和iPhone，所以可以慢慢的开始更新了。&lt;/p&gt;
&lt;h4&gt;紧急修正&lt;/h4&gt;
&lt;p&gt;经过测试，在ipad上的使用还需要注意一个&lt;strong&gt;问题&lt;/strong&gt;，那就是在present之前要设置&lt;code&gt;UIAlertController&lt;/code&gt;的属性&lt;code&gt;popoverPresentationController&lt;/code&gt;。该属性是&lt;code&gt;UIPopoverPresentationController&lt;/code&gt;类，主要用途就是管理popover中的内容。如果不设置，在iPad竖屏测试的时候没有问题，但是在横屏的时候就会有问题。原因在于，横屏的时候，popover没有指定位置。这时，可以&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;UIPopoverPresentationController *popoverPresentationController = alertController.popoverPresentationController;        
popoverPresentationController.barButtonItem = (UIBarButtonItem *)sender;
//或
popoverPresentationController.sourceView = (UIButton *)sender;
popoverPresentationController.sourceRect = [(UIButton *)sender bounds];
&lt;/pre&gt;&lt;/div&gt;</summary><category term="ios8"></category></entry><entry><title>git revert &amp;&amp; svn revert的不同</title><link href="http://icocoa.tk/git-revert-svn-revertde-bu-tong.html" rel="alternate"></link><updated>2014-11-03T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-11-03:git-revert-svn-revertde-bu-tong.html</id><summary type="html">&lt;p&gt;最近在看git，注意到revert命令，不禁想起svn的revert。于是把两者的功能进行了对比，以加深命令的理解。&lt;/p&gt;
&lt;h4&gt;git revert&lt;/h4&gt;
&lt;p&gt;对应的中文术语叫反转提交，基本的用法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git revert commit-ish
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;该命令运行后会新加一个提交，该提交的内容即commit-ish所指向提交的父提交，此时版本库的内容“回退”到之前的某个版本。注意在运行本命令前，当前工作区不能有未提交的改动。&lt;/p&gt;
&lt;h4&gt;svn revert&lt;/h4&gt;
&lt;p&gt;svn中revert即回滚，基本用法&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;svn revert PATH
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中PATH可以是单个文件，也可以是文件夹。如果是文件夹的话，就需要用-R参数，表示递归执行。执行完命令后，本地文件的所有修改都被放弃，所以此时执行时不需要联网。&lt;/p&gt;
&lt;h4&gt;svn实现git revert的功能&lt;/h4&gt;
&lt;p&gt;如果要向用svn实现git revert的功能那么就需要：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;svn update
//确保版本库最新
svn log
//找到想要“回复”的版本号
svn merge -r currentID:revertID PATH
//回滚到revertID所代表的版本
svn commit -m "message"
//确认后提交
&lt;/pre&gt;&lt;/div&gt;</summary><category term="revert"></category><category term="git"></category><category term="svn"></category></entry><entry><title>App Extension Study 2</title><link href="http://icocoa.tk/app-extension-study-2.html" rel="alternate"></link><updated>2014-10-31T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-31:app-extension-study-2.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h3&gt;1 开始&lt;/h3&gt;
&lt;p&gt;&lt;a href="http://github.icocoa.tk/app-extension-study-1.html"&gt;上一篇&lt;/a&gt;介绍了Extension的基本概念，Extension的运行周期，和containing app的数据共享等细节，这节开始实践。需要说明的本文不会覆盖所有类型，比如&lt;strong&gt;Finder Sync&lt;/strong&gt;类型是OS X独有的，这里会一带而过。&lt;/p&gt;
&lt;h3&gt;2 Widget&lt;/h3&gt;
&lt;p&gt;Widget就是Today extension，这个大家比较熟悉：下拉通知中显示的股票信息就是一个widget。从这里我们也可以看出widget的特点：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;可以自定义UI&lt;/li&gt;
&lt;li&gt;必定和containing app有着数据共享&lt;/li&gt;
&lt;/ol&gt;
&lt;h4&gt;2.1 widget 工程模版&lt;/h4&gt;
&lt;p&gt;在已有工程中新建一个target，选择&lt;code&gt;Application Extension&lt;/code&gt;中的&lt;code&gt;Today Extension&lt;/code&gt;，这时工程中增加了如下文件：&lt;br/&gt;
&lt;img alt="widgetImg" src="./imgs/20141031/widget_template.png"/&gt;&lt;br/&gt;
先来看&lt;code&gt;Info.plist&lt;/code&gt;，主要增加了NSExtenstion的key，内容如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.widget-extension&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;和app一样，如果不需要使用默认提供的sb文件，那么可以删除&lt;code&gt;NSExtensionMainStoryboard&lt;/code&gt;属性，然后添加&lt;code&gt;NSExtensionPrincipalClass&lt;/code&gt;。&lt;br/&gt;
上面说过widget必定会和containing app进行数据交互，那么我们必须同时开启containing app和widget的&lt;code&gt;App Groups&lt;/code&gt;功能。打开的方式：选中target-&amp;gt;Capabilities-&amp;gt;App Groups。 当你开启后，Xcode6会联网帮你进行一些操作，然后你需要做的就是给App Groups取一个名字，这个名字必须以group开头，建议后面的部分还是用反域名的结构。注意containing和widget的group名字得是一样的，不然就不能进行数据的共享。&lt;br/&gt;
接下来，我们看&lt;code&gt;TodayViewController&lt;/code&gt;，这是&lt;code&gt;UIViewController&lt;/code&gt;的子类，同时实现了&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议。它的实现文件模版中有3个方法：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;viewDidLoad&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;viewDidLoad&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// Do any additional setup after loading the view from its nib.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;didReceiveMemoryWarning&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;super&lt;/span&gt; &lt;span class="n"&gt;didReceiveMemoryWarning&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="c1"&gt;// Dispose of any resources that can be recreated.&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="o"&gt;-&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nl"&gt;widgetPerformUpdateWithCompletionHandler&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;)(&lt;/span&gt;&lt;span class="n"&gt;NCUpdateResult&lt;/span&gt;&lt;span class="p"&gt;))&lt;/span&gt;&lt;span class="n"&gt;completionHandler&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Perform any setup necessary in order to update the view.&lt;/span&gt;
  &lt;span class="c1"&gt;// If an error is encountered, use NCUpdateResultFailed&lt;/span&gt;
  &lt;span class="c1"&gt;// If there's no update required, use NCUpdateResultNoData&lt;/span&gt;
  &lt;span class="c1"&gt;// If there's an update, use NCUpdateResultNewData&lt;/span&gt;
  &lt;span class="n"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;NCUpdateResultNewData&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中最后一个就是&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议，该协议的作用：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在通知中心可见或者在后台的情况下，系统会在合适的时候更新widget&lt;/li&gt;
&lt;li&gt;&lt;code&gt;completionHandler&lt;/code&gt;必须要执行，同时根据运行情况选择合适的&lt;code&gt;NCUpdateResult&lt;/code&gt;作为参数&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;此外，文档中还说系统会不时的对widget进行截屏，这样当widget可见的时候，widget会将最近的截屏先显示出来，然后再用最新的实时的view替换。从这个意义上说，对于股票类的widget适时的刷新页面就很有必要。&lt;/p&gt;
&lt;p&gt;另外，&lt;code&gt;NCWidgetProviding&lt;/code&gt;协议还包括： &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;UIEdgeInsets&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;widgetMarginInsetsForProposedMarginInsets&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;UIEdgeInsets&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;defaultMarginInsets&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可以让你自由选择widget四周对齐处的间距。&lt;/p&gt;
&lt;h4&gt;2.2 widget的设计&lt;/h4&gt;
&lt;p&gt;可以在sb文件中设计你的widget页面，作为一个简单的演示，我们设计一个直接显示文字的widget。你可以在containing app中设计一个&lt;code&gt;UITextField&lt;/code&gt;，把输入保存到share group中。然后在widget中读取，并显示在&lt;code&gt;UILabel&lt;/code&gt;中。核心的读写操作一并演示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
                                    &lt;span class="nl"&gt;initWithSuiteName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"group.xxxxxx"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;setObject&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;detailItem&lt;/span&gt; &lt;span class="n"&gt;description&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"nameKey"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;objectForKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"nameKey"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;label&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;text&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;text&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;苹果建议widget的UI不要使用scrollview，因为所有的widget都是在一个scrollview中，嵌套使用scrollview有多大的不爽想必可想而知，所以尺寸大小需要变化的就直接通过view的大小来实现。当然，如果是横向的scrollview会好一点，不过也建议不要放置太多的内容。因为widget本身就包含着信息一目了然，如果需要用户进行操作，就会拖累widget的体验&lt;/p&gt;
&lt;h4&gt;2.3 widget的显示&lt;/h4&gt;
&lt;p&gt;有时候，当没有可用数据的时候，我们可以控制widget是否显示：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NCWidgetController&lt;/span&gt; &lt;span class="n"&gt;widgetController&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setHasContent&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;NO&lt;/span&gt; &lt;span class="nl"&gt;forWidgetWithBundleIdentifier&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"com.XXXXXX"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样就能隐藏widget而不显示。&lt;/p&gt;
&lt;h4&gt;2.4 打开contaning app&lt;/h4&gt;
&lt;p&gt;使用URL scheme，首先需要在containing中定义一个scheme，例如: extest，然后在widget中使用&lt;code&gt;extensionContext&lt;/code&gt;属性打开&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="k"&gt;[self.extensionContext openURL:[NSURL URLWithString:@"extest://"]&lt;/span&gt;
             &lt;span class="err"&gt;completionHandler:^(BOOL&lt;/span&gt; &lt;span class="err"&gt;success)&lt;/span&gt; &lt;span class="err"&gt;{&lt;/span&gt;

&lt;span class="err"&gt;}]&lt;/span&gt;&lt;span class="c1"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;2.5 编辑&lt;/h4&gt;
&lt;p&gt;OS X上支持widget的编辑，iOS上不支持&lt;/p&gt;
&lt;h3&gt;3 Share&lt;/h3&gt;
&lt;p&gt;Share侧重内容的分享，那么可以猜测有两点需要关注：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;分享类型/内容如何确定&lt;/li&gt;
&lt;li&gt;分享任务的实现&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;3.1 Share 模版文件&lt;/h3&gt;
&lt;p&gt;Share extension的添加和widget类似，添加后还是先打开info.plist文件，如何添加如下的属性：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这样的话，Share就可以支持图片/视频/URL，后面的数字代表可以支持的数目。&lt;/p&gt;
&lt;h4&gt;3.2 发送内容&lt;/h4&gt;
&lt;p&gt;完成了上述步骤后，我们安装这个action，并用Photos应用打开该action:
&lt;img alt="share_extension" src="./imgs/20141031/share_extension.png"/&gt; &lt;/p&gt;
&lt;p&gt;如图所示，Share extension会弹出一个对话框视图，视图上有文字输入的地方和Post/Cancel的按钮。回到工程可以发现Share的视图父类是&lt;code&gt;SLComposeServiceViewController&lt;/code&gt;，它定义了一系列方法让子类去重载。重要的而且通常需要实现的一些方法已经定义在模版里，我们逐个来看一下。
首先第一个就是&lt;code&gt;isContentValid&lt;/code&gt;，该方法是用于检查用户输入的有效性(主要指输入字符长度检查)，典型的实现：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;BOOL&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;isContentValid&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

&lt;span class="c1"&gt;// Do validation of contentText and/or NSExtensionContext attachments here&lt;/span&gt;
&lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;messageLength&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt;
                                &lt;span class="nl"&gt;stringByTrimmingCharactersInSet&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSCharacterSet&lt;/span&gt; &lt;span class="n"&gt;whitespaceCharacterSet&lt;/span&gt;&lt;span class="p"&gt;]]&lt;/span&gt; &lt;span class="n"&gt;length&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="n"&gt;NSInteger&lt;/span&gt; &lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="mi"&gt;100&lt;/span&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="n"&gt;messageLength&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@(&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt;&lt;span class="l"&gt;)&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;charactersRemaining&lt;/span&gt; &lt;span class="o"&gt;&amp;gt;=&lt;/span&gt; &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="k"&gt;else&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;

&lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;NO&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来就是&lt;code&gt;didSelectPost&lt;/code&gt;，这是点击Post调用的方法，典型实现：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;didSelectPost&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Perform the post operation.&lt;/span&gt;
&lt;span class="c1"&gt;// When the operation is complete (probably asynchronously), the Share  extension should notify the success or failure, as well as the items that   were actually shared.&lt;/span&gt;
  &lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inputItems&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
  &lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedContentText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSAttributedString&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt;
&lt;span class="nl"&gt;initWithString&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;contentText&lt;/span&gt; &lt;span class="nl"&gt;attributes&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Complete this implementation by setting the appropriate value on the output item.&lt;/span&gt;
    &lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt; &lt;span class="nl"&gt;completeRequestReturningItems&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt;
 &lt;span class="nl"&gt;expirationHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;completion&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Or call [super didSelectPost] to use the superclass's default completion     behavior. &lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这个方法里要做几件事：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;上传任务：使用&lt;code&gt;NSURLSession&lt;/code&gt;把图片(或其他媒体)和文字存储到服务器&lt;/li&gt;
&lt;li&gt;调用&lt;code&gt;completeRequestReturningItems:myOutputItems expirationHandler:nil completion:nil&lt;/code&gt;通知host app完成了上传请求&lt;/li&gt;
&lt;li&gt;准备好随时被系统终止&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;接下来是&lt;code&gt;configurationItems&lt;/code&gt;，该方法是返回一个&lt;code&gt;SLComposeSheetConfigurationItem&lt;/code&gt;对象的数组。如果实现了该方法，那么弹出的UI的最下方会出现该方法定义的item。 &lt;code&gt;SLComposeSheetConfigurationItem&lt;/code&gt;的属性&lt;code&gt;title&lt;/code&gt;出现在左侧，属性&lt;code&gt;value&lt;/code&gt;出现在右侧，点击后弹出配置窗口。  &lt;/p&gt;
&lt;p&gt;最后是&lt;code&gt;presentationAnimationDidFinish&lt;/code&gt;，该方法是Share页面弹出动画结束后执行，苹果建议一些耗费重的工作在这里进行。我建议可以在这里准备好要上传的一些数据，比如获取图片数据，例如：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;void&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;presentationAnimationDidFinish&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;inputItems&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;firstObject&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;inputItem&lt;/span&gt; &lt;span class="k"&gt;copy&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

&lt;span class="k"&gt;for&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSItemProvider&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="k"&gt;in&lt;/span&gt; &lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attachments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"%@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="n"&gt;registeredTypeIdentifiers&lt;/span&gt;&lt;span class="p"&gt;]);&lt;/span&gt;
    &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="nl"&gt;hasItemConformingToTypeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;kUTTypeImage&lt;/span&gt;&lt;span class="p"&gt;])&lt;/span&gt;
    &lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;provider&lt;/span&gt; &lt;span class="nl"&gt;loadItemForTypeIdentifier&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;NSString&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;kUTTypeImage&lt;/span&gt; &lt;span class="nl"&gt;options&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt; &lt;span class="nl"&gt;completionHandler&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt;&lt;span class="o"&gt;&amp;lt;&lt;/span&gt;&lt;span class="bp"&gt;NSSecureCoding&lt;/span&gt;&lt;span class="o"&gt;&amp;gt;&lt;/span&gt; &lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="bp"&gt;NSError&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
            &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;error&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;
            &lt;span class="k"&gt;else&lt;/span&gt;
            &lt;span class="p"&gt;{&lt;/span&gt;
                &lt;span class="k"&gt;if&lt;/span&gt; &lt;span class="p"&gt;([(&lt;/span&gt;&lt;span class="bp"&gt;NSObject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt; &lt;span class="nl"&gt;isKindOfClass&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="k"&gt;class&lt;/span&gt;&lt;span class="p"&gt;]])&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="n"&gt;NSLog&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="s"&gt;@"NSURL: %@"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
                    &lt;span class="n"&gt;dispatch_async&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;dispatch_get_main_queue&lt;/span&gt;&lt;span class="p"&gt;(),&lt;/span&gt; &lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
                        &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;imgURL&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;NSURL&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;item&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
                    &lt;span class="p"&gt;});&lt;/span&gt;


                &lt;span class="p"&gt;}&lt;/span&gt;
                &lt;span class="k"&gt;else&lt;/span&gt;
                &lt;span class="p"&gt;{&lt;/span&gt;
                    &lt;span class="c1"&gt;//other handling&lt;/span&gt;
                &lt;span class="p"&gt;}&lt;/span&gt;

            &lt;span class="p"&gt;}&lt;/span&gt;

        &lt;span class="p"&gt;}];&lt;/span&gt;
    &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Share的内容基本全部覆盖了，觉得不能满足定制需求的可以去头文件查看还有哪些方法没有实现。如果没有找到，那么很大程度就是你的Share extension设计有问题了。&lt;br/&gt;
如果Share extension的运作和实现理解了，下面的Action，PhotoEditing会更容易理解，因为后两者的实现流程和Share非常类似。&lt;/p&gt;
&lt;h3&gt;4 Action&lt;/h3&gt;
&lt;p&gt;Action可以获得host app提供的可视数据，如何直接或者经过修改后使用，并把最终修改的数据交还给containing app。 
在iOS中，Action Extension：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;帮助用户以另一种方式查看当前的文档&lt;/li&gt;
&lt;li&gt;extension总是在action sheet或全屏的模态视图中出现&lt;/li&gt;
&lt;li&gt;当且仅当host app允许，Action extension才会收到选中的内容&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;和Share一样，Action也只能位于系统的UI中，如果某个host app可用某个extension并且host app实现了&lt;code&gt;UIActivityController&lt;/code&gt;，否则将不能调用extension。&lt;/p&gt;
&lt;h4&gt;4.1 Action模版文件&lt;/h4&gt;
&lt;p&gt;新建一个Action对象后，我们还是先看plist文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt; &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;TRUEPREDICATE&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.ui-services&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
 &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;默认的plist文件还是不够完备的，需要自己添加，比如:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtension&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActionWantsFullScreenPresentation&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;false/&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
     &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionServiceRoleType&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;NSExtensionServiceRoleTypeViewer&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionMainStoryboard&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MainInterface&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionPointIdentifier&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;com.apple.ui-services&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;其中，&lt;code&gt;NSExtensionActionWantsFullScreenPresentation&lt;/code&gt;指定Action是否需要全屏显示，而&lt;code&gt;NSExtensionServiceRoleType&lt;/code&gt;则有2种取值：
&lt;em&gt; &lt;code&gt;NSExtensionServiceRoleTypeEditor&lt;/code&gt;: 可以编辑或转换文档，并将修改过的文档回传给host app
&lt;/em&gt; &lt;code&gt;NSExtensionServiceRoleTypeViewer&lt;/code&gt;: 将选中的文档以另一种形式打开浏览&lt;/p&gt;
&lt;p&gt;需要说明的是，文档中说明了&lt;code&gt;NSExtensionServiceRoleType&lt;/code&gt;是OS X上才有的。&lt;/p&gt;
&lt;h4&gt;4.2 Action UI设计&lt;/h4&gt;
&lt;p&gt;UI的设计和具体的应用有关，限制较少，唯一需要注意的是Action需要提供一个类似app icon的图片，以便在&lt;code&gt;UIactivityController&lt;/code&gt;中显示。图片的要求：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;带有适度透明的黑或白底&lt;/li&gt;
&lt;li&gt;不要有阴影&lt;/li&gt;
&lt;li&gt;图片要抗锯齿&lt;/li&gt;
&lt;li&gt;尺寸：60x60 iphone；76x76 ipad&lt;/li&gt;
&lt;/ul&gt;
&lt;h4&gt;4.3 内容回传&lt;/h4&gt;
&lt;p&gt;主要实现&lt;code&gt;done&lt;/code&gt;，如：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;-(&lt;/span&gt;&lt;span class="kt"&gt;IBAction&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nf"&gt;done&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// Return any edited content to the host app.&lt;/span&gt;
&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSExtensionItem&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="n"&gt;init&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedContentText&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;myTextView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;attributedString&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="bp"&gt;NSArray&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="l"&gt;@[&lt;/span&gt;&lt;span class="n"&gt;outputItem&lt;/span&gt;&lt;span class="l"&gt;]&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;extensionContext&lt;/span&gt; &lt;span class="nl"&gt;completeRequestReturningItems&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;outputItems&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h3&gt;5 Photo Editing&lt;/h3&gt;
&lt;p&gt;Photo Editing和Action很类似，唯一的区别就是Photo Editing的host只能是Photos app。它的启动方式是：Photos-&amp;gt;单个图片浏览-&amp;gt;编辑-&amp;gt;左上角按钮。经过Photo Editing处理的图片会返回给Photos，用户可以选择接受或取消该改变。&lt;/p&gt;
&lt;h4&gt;5.1 Photo Editing如何运行&lt;/h4&gt;
&lt;p&gt;Photos会保存多个版本的asset数据：原始的数据，历次做过修改的数据(比如添加的滤镜参数)，以及现有含修改的数据。当启用Photo Editing，Photos会问extension能否读懂修改数据，如果可以读懂Photos会把原始数据作为输入传递给extension，再把修改数据传递给extension。这样，extension可以使用修改数据(比如修改滤镜参数)或者直接添加新的编辑。&lt;br/&gt;
如果extension不支持修改的数据，那么Photos就会把当前的数据作为输入传递给extension，这样extension只能添加新的便捷了。&lt;/p&gt;
&lt;h4&gt;5.2 模版文件&lt;/h4&gt;
&lt;p&gt;plist文件新加&lt;code&gt;PHSupportedMediaTypes&lt;/code&gt;的key，它的值是 &lt;code&gt;Image&lt;/code&gt;或&lt;code&gt;Video&lt;/code&gt;。&lt;br/&gt;
而查看实现文件可以发现视图控制器实现了&lt;code&gt;PHContentEditingController&lt;/code&gt;协议，该协议的代理方法都是&lt;code&gt;required&lt;/code&gt;，方法的说明见下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;extension&lt;/span&gt;&lt;span class="err"&gt;能否处理编辑的数据&lt;/span&gt;
 &lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;BOOL&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;canHandleAdjustmentData&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;PHAdjustmentData&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;adjustmentData&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="nt"&gt;contentEditingInput&lt;/span&gt;&lt;span class="err"&gt;是原始输入数据，&lt;/span&gt;&lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="err"&gt;则是现在版本的数据&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;startContentEditingWithInput&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;PHContentEditingInput&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;contentEditingInput&lt;/span&gt; &lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*)&lt;/span&gt;&lt;span class="nt"&gt;placeholderImage&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;

&lt;span class="o"&gt;//&lt;/span&gt;&lt;span class="err"&gt;编辑完成后调用，注意要调用&lt;/span&gt;&lt;span class="nt"&gt;completionHandler&lt;/span&gt;&lt;span class="err"&gt;来通知&lt;/span&gt;&lt;span class="nt"&gt;host&lt;/span&gt; &lt;span class="nt"&gt;app&lt;/span&gt;&lt;span class="err"&gt;编辑完成&lt;/span&gt;
&lt;span class="nt"&gt;-&lt;/span&gt; &lt;span class="o"&gt;(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;&lt;span class="nt"&gt;finishContentEditingWithCompletionHandler&lt;/span&gt;&lt;span class="o"&gt;:(&lt;/span&gt;&lt;span class="nt"&gt;void&lt;/span&gt; &lt;span class="o"&gt;(^)(&lt;/span&gt;&lt;span class="nt"&gt;PHContentEditingOutput&lt;/span&gt; &lt;span class="o"&gt;*))&lt;/span&gt;&lt;span class="nt"&gt;completionHandler&lt;/span&gt;&lt;span class="o"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;5.3 sample&lt;/h4&gt;
&lt;p&gt;官方有一个例子:&lt;a href="https://developer.apple.com/devcenter/download.action?path=/wwdc_2014/wwdc_2014_sample_code/samplephotoeditingextension.zip"&gt;samplephotoeditingextension&lt;/a&gt;，可以去看看。&lt;/p&gt;
&lt;h3&gt;Bingo&lt;/h3&gt;
&lt;p&gt;以上介绍了widget， Share，Action和Photo Editing，剩下后文继续。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>App Extension Study 1</title><link href="http://icocoa.tk/app-extension-study-1.html" rel="alternate"></link><updated>2014-10-16T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-16:app-extension-study-1.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: ios8 app extension&lt;/p&gt;
&lt;h2&gt;Intro&lt;/h2&gt;
&lt;p&gt;app extension是iOS8引入的功能，使得iOS8也有了“插件”系统。虽然一时还不知道可以做些什么应用，但我相信会有杀手级的extension出现而且某种程度会影响到app的生态系统发展。所以，我们需要了解并熟悉如何制作app extension。本系列会以&lt;a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/ExtensibilityPG/index.html"&gt;官方文档&lt;/a&gt;为指引，按图索骥，拨开app extension的面纱(主要侧重iOS)。&lt;/p&gt;
&lt;h2&gt;App Extension&lt;/h2&gt;
&lt;p&gt;有很多关于App Extension的介绍，所以就不详细介绍，这里侧重介绍Extension的生命周期以及和其他app的通信。&lt;/p&gt;
&lt;h3&gt;术语&lt;/h3&gt;
&lt;ul&gt;
&lt;li&gt;host app: 用户在某个app中启用了extension，该app就叫host app&lt;/li&gt;
&lt;li&gt;containing app: extension不能单独作为target存在，必须依附在某个具有普通app的工程内，该app就是containing app。一个containing app可以有多个extension。&lt;/li&gt;
&lt;li&gt;app extension: &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当下载了含有extension的containing app，那么如果某个app可以使用该extension，那么就可以在app(此即host app)中调用extension&lt;/p&gt;
&lt;h3&gt;生命周期&lt;/h3&gt;
&lt;p&gt;&lt;img alt="extension_life_cycle" src="./imgs/20141016/extension_cycle.png"/&gt;&lt;br/&gt;
extension是由用户选择启动，然后作为一个单独的“程序”运行，直到运行结束，系统kill该extension，至此结束extension的使命。需要说明的是，无法在containing app中启用extension。&lt;br/&gt;
尽管extension通常是在host app中启动，但是extension的运行过程却不受 host/containing app 的“干预”——不能在host或containing app 中影响extention的运行。但是系统提供了某种机制使得三者之间可以共享部分数据。&lt;/p&gt;
&lt;h3&gt;通信&lt;/h3&gt;
&lt;h4&gt;与host app 通信&lt;/h4&gt;
&lt;p&gt;&lt;img alt="with_host" src="./imgs/20141016/communicat_only_with_host.png"/&gt;&lt;br/&gt;
两者关系干净利落：一个请求，一个响应，没有其他藕断丝连。iOS8中&lt;code&gt;UIViewController&lt;/code&gt;包含了&lt;code&gt;extensionContext&lt;/code&gt;的新属性。请求的所有信息都包含在该context属性中。&lt;br/&gt;
该图的虚线表明extension和containing没有直接的通信。 &lt;/p&gt;
&lt;h4&gt;与containing app 通信&lt;/h4&gt;
&lt;p&gt;从某种意义上，extension是“依附”着containing app的，既然不能直接通信，那么必然有迂回的方式。&lt;br/&gt;
&lt;img alt="with_containing" src="./imgs/20141016/communicat_indirectly_with_containing.png"/&gt;&lt;br/&gt;
上图中显示extension可以通过 OpenURL的方式打开自己的contaning app。更为重要的是，两者直接有一个shared resources区域来交换数据信息。&lt;/p&gt;
&lt;h4&gt;其他注意事项&lt;/h4&gt;
&lt;p&gt;由extension的工程必须包含arm64或x86_64框架，另外extension :  &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;不能访问相机和麦克风&lt;/li&gt;
&lt;li&gt;不能执行长时间的后台任务，如果要上传／下载的话，需要使用 &lt;code&gt;NSURLSession&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;不能访问 &lt;code&gt;UIApplication&lt;/code&gt; 对象&lt;/li&gt;
&lt;li&gt;不能接受通过 &lt;em&gt;AirDrop&lt;/em&gt; 传送的数据&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;创建App Extesnion&lt;/h2&gt;
&lt;p&gt;使用Xcode6创建一个application，然后在new一个target，这时模板选项里会出现 "Application Extension"，选择任一添加。这样运行安装app后，连带之前的扩展也一并安装了。  &lt;/p&gt;
&lt;h3&gt;extension的工程文件&lt;/h3&gt;
&lt;p&gt;&lt;img alt="extension_template" src="./imgs/20141016/extension_template.png"/&gt;&lt;br/&gt;
extension的组成很简单：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;ViewController: extension的主要实现部分&lt;/li&gt;
&lt;li&gt;storyboard: extension的UI界面入口&lt;/li&gt;
&lt;li&gt;Info.plist: 老朋友了，主要关注&lt;code&gt;NSExtension&lt;/code&gt;键值。以后对一些限制，比如文件类型都在这里添加&lt;/li&gt;
&lt;li&gt;entitlements: optional，如果要启用share resource，就需要开启app group，那么会自动生产该文件。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;extension的常见处理流程&lt;/h3&gt;
&lt;p&gt;如前所说，请求的extenison的所有信息可以通过&lt;code&gt;UIViewController&lt;/code&gt;的&lt;code&gt;extensionContext&lt;/code&gt;获取。至于相关信息怎么获取，下面分门别类细说。  &lt;/p&gt;
&lt;h3&gt;debug&lt;/h3&gt;
&lt;p&gt;选中extesnion的scheme，然后debug，Xcode6会让你选择某个host app，然后进入该host app。在host app启用extension后，就可以debug了。&lt;/p&gt;
&lt;h3&gt;distribution&lt;/h3&gt;
&lt;p&gt;提交containing app即可——没有实践过，itunes connect是否要设置，暂时不详  &lt;/p&gt;
&lt;h2&gt;处理常见场景&lt;/h2&gt;
&lt;p&gt;在开始实践extension之前，有必要直到一些常见问题如何处理。&lt;/p&gt;
&lt;h3&gt;使用嵌入式框架共享代码&lt;/h3&gt;
&lt;p&gt;constaining和extension可以通过该方式共享代码，需要注意的是extension中不是所有API都可以使用，并且要包含64位的架构。这两点是文档中Apple反复提及的，一旦有违反这样的情况而进行提交的会直接被打回。&lt;br/&gt;
添加完库后，要将target的"Require Only App-Extension-Safe API"设置为"YES"。  &lt;/p&gt;
&lt;h3&gt;shared resources&lt;/h3&gt;
&lt;p&gt;前面说过extension和containing可以共享数据。这时分别对containing 和extension target启用"App Group"。Xcode6会自动获取group名，当然也可以自行添加。共享数据的读写是通过老朋友&lt;code&gt;NSUserDefault&lt;/code&gt;:&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;// Create and share access to an NSUserDefaults object.&lt;/span&gt;
&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;NSUserDefaults&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithSuiteName&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"com.example.domain.MyShareExtension"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="c1"&gt;// Use the shared user defaults object to update the user's account.&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;mySharedDefaults&lt;/span&gt; &lt;span class="nl"&gt;setObject&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;theAccountName&lt;/span&gt; &lt;span class="nl"&gt;forKey&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"lastAccountName"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;对共享区域的数据，extesnion和containing都有读写权限，所以某一方进行读写后要及时同步数据。  &lt;/p&gt;
&lt;h3&gt;访问网页&lt;/h3&gt;
&lt;p&gt;Share和Action类型的extension可以通过safari访问某个页面，执行你设定的js脚本，然后把执行的结果返回给extension。注意可以在extension执行前就执行脚本访问web页面，也可以在extension执行完毕后访问或修改web页面(该情形只在iOS有效)。&lt;br/&gt;
步骤：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;创建js文件，文件中要有一个名为&lt;code&gt;ExtensionPreprocessingJS&lt;/code&gt;的全局对象&lt;/li&gt;
&lt;li&gt;修改plist：将&lt;code&gt;NSExtensionActivationRule&lt;/code&gt;的属性&lt;code&gt;NSExtensionActivationSupportsWebPageWithMaxCount&lt;/code&gt;设置为非零的值&lt;/li&gt;
&lt;li&gt;当extension开始后，使用 &lt;code&gt;NSItemProvider&lt;/code&gt;获取js运行的结果&lt;/li&gt;
&lt;li&gt;iOS中如果要传递给js文件参数， 也通过 &lt;code&gt;NSItemProvider&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;为了让safari响应extension的js文件，需要添加：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionJavaScriptPreprocessingFile&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;string&amp;gt;&lt;/span&gt;MyJavaScriptFile&lt;span class="nt"&gt;&amp;lt;/string&amp;gt;&lt;/span&gt; &lt;span class="c"&gt;&amp;lt;!-- Do not include the ".js" filename extension --&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;h4&gt;js文件的写法&lt;/h4&gt;
&lt;p&gt;sample: &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;()&lt;/span&gt; &lt;span class="p"&gt;{};&lt;/span&gt;
&lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;prototype&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="nl"&gt;run&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
  &lt;span class="c1"&gt;// Pass the baseURI of the webpage to the extension.&lt;/span&gt;
      &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;completionFunction&lt;/span&gt;&lt;span class="p"&gt;({&lt;/span&gt;&lt;span class="s"&gt;"baseURI"&lt;/span&gt;&lt;span class="o"&gt;:&lt;/span&gt; &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;baseURI&lt;/span&gt;&lt;span class="p"&gt;});&lt;/span&gt;
  &lt;span class="p"&gt;},&lt;/span&gt;
  &lt;span class="c1"&gt;// Note that the finalize function is only available in iOS.&lt;/span&gt;
  &lt;span class="nl"&gt;finalize&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt; &lt;span class="n"&gt;function&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="c1"&gt;// arguments contains the value the extension provides in [NSExtensionContext completeRequestReturningItems:completion:].&lt;/span&gt;
  &lt;span class="c1"&gt;// In this example, the extension provides a color as a returning item.&lt;/span&gt;
  &lt;span class="n"&gt;document&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;body&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;style&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;backgroundColor&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;arguments&lt;/span&gt;&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="s"&gt;"bgColor"&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
  &lt;span class="p"&gt;}&lt;/span&gt;
&lt;span class="p"&gt;};&lt;/span&gt;
&lt;span class="c1"&gt;// The JavaScript file must contain a global object named "ExtensionPreprocessingJS". &lt;/span&gt;
&lt;span class="n"&gt;var&lt;/span&gt; &lt;span class="n"&gt;ExtensionPreprocessingJS&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;new&lt;/span&gt; &lt;span class="n"&gt;MyExtensionJavaScriptClass&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;解释和说明：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;当safari加载了js后，立即执行&lt;code&gt;run&lt;/code&gt;函数，执行的结果通过&lt;code&gt;completionFunction&lt;/code&gt;返回给extension&lt;/li&gt;
&lt;li&gt;&lt;code&gt;finalize&lt;/code&gt;函数是extension执行&lt;code&gt;completeRequestReturningItems:completion:&lt;/code&gt;后执行，extesnion传递的参数在arguments中&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;对应的extension中： &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;获取run执行的结果：&lt;/p&gt;
&lt;p&gt;[imageProvider loadItemForTypeIdentifier:kUTTypePropertyList options:nil
completionHandler:^(NSDictionary &lt;em&gt;item, NSError &lt;/em&gt;error) {
NSDictionary &lt;em&gt;results = (NSDictionary &lt;/em&gt;)item;
NSString *baseURI = [[results objectForKey:NSExtensionJavaScriptPreprocessingResultsKey] objectForKey:@"baseURI"];
}];&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;传递给finalize：&lt;/p&gt;
&lt;p&gt;NSExtensionItem &lt;em&gt;extensionItem = [[NSExtensionItem alloc] init];
extensionItem.attachments = @[[[NSItemProvider alloc] initWithItem:@{NSExtensionJavaScriptFinalizeArgumentKey: @{@"bgColor":@"red"}} typeIdentifier:(NSString &lt;/em&gt;)kUTTypePropertyList]];
[[self extensionContext] completeRequestReturningItems:@[extensionItem]
  completion:nil];&lt;/p&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;上传和下载&lt;/h3&gt;
&lt;p&gt;使用&lt;code&gt;NSURLSession&lt;/code&gt;，经过测试，&lt;code&gt;upload task session&lt;/code&gt; 不能在extension中使用。&lt;/p&gt;
&lt;h3&gt;声明Share/Action extension支持的数据类型&lt;/h3&gt;
&lt;p&gt;sample：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionAttributes&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationRule&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;dict&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsImageWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;10&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsMovieWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;key&amp;gt;&lt;/span&gt;NSExtensionActivationSupportsWebURLWithMaxCount&lt;span class="nt"&gt;&amp;lt;/key&amp;gt;&lt;/span&gt;
        &lt;span class="nt"&gt;&amp;lt;integer&amp;gt;&lt;/span&gt;1&lt;span class="nt"&gt;&amp;lt;/integer&amp;gt;&lt;/span&gt;
    &lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;span class="nt"&gt;&amp;lt;/dict&amp;gt;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;不支持的数据类型设置值为0或者移除该键。 &lt;/p&gt;
&lt;h3&gt;适配iOS8前的containing app&lt;/h3&gt;
&lt;p&gt;使用了嵌入式框架后，也能继续兼容iOS8之前的系统。这就要使用&lt;code&gt;dlopen&lt;/code&gt;，该命令可以在编译时条件链接和加载库。注意要在objc使用&lt;code&gt;dlopen&lt;/code&gt;。在containing执行的时候，检测系统只有是iOS8及以后的系统，才加载库。 &lt;/p&gt;
&lt;p&gt;下面会依次实现各种类型的extension，并将其中遇到的问题说明(待续)。&lt;/p&gt;</summary><category term="ios8"></category><category term="AppExtension"></category></entry><entry><title>git bisect查找xcode6工程在iOS7下不全屏的问题</title><link href="http://icocoa.tk/git-bisectcha-zhao-xcode6gong-cheng-zai-ios7xia-bu-quan-ping-de-wen-ti.html" rel="alternate"></link><updated>2014-10-16T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-10-16:git-bisectcha-zhao-xcode6gong-cheng-zai-ios7xia-bu-quan-ping-de-wen-ti.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: launch screen,xcode6,git&lt;/p&gt;
&lt;h2&gt;xcode6工程在iOS7下未全屏&lt;/h2&gt;
&lt;p&gt;使用xcode6创建的工程在iOS7下运行，居然出现了未全屏的现象，仿佛一下子回到了iPhone5发布的时代。因为提交了多次，不清楚是哪次引入的问题。所幸使用了git管理版本，想找到出错的提交，就靠git了。&lt;/p&gt;
&lt;h2&gt;git bisect&lt;/h2&gt;
&lt;p&gt;在不知道bisect之前，我能想到的办法是通过 &lt;code&gt;reset hard&lt;/code&gt; 或者&lt;code&gt;archive&lt;/code&gt; “恢复”到逐个提交，然后运行看结果。可是强大的git提供了bisect，于是一切都好办了。&lt;br/&gt;
bisect的使用就是标记两个版本，一个正确一个错误，然后git会自动找中间某个提交，由用户来确认是正确还是错误。如此反复，就能定位到引入错误的提交，具体执行过程演示如下：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;git log --oneline //列出提交记录
git bisect start //开始查找
git bisect bad //标记当前（master）为错误版本
git bisect good A-commit //提供一个运行正确的版本，下面开始查找

git bisect reset //当确认错误的提交后，需要清理战场，回到HEAD
&lt;/pre&gt;&lt;/div&gt;
&lt;h2&gt;LaunchScreen.xib&lt;/h2&gt;
&lt;p&gt;经过bisect的检查，发现是将工程的 Deployment target设置为iOS7引起的。因为Xcode6中模板工程默认使用LaunchScreen.xib，而且size class是对iOS8才有效，所以猜想应该是LaunchScreen引起的。重新运行了下工程，发现在iOS7下的确启动画面没有显示。而目前iOS7的用户还是占了大多数，很显然不可能只适配iOS8，所以工程还是得使用LaunchImage。&lt;/p&gt;
&lt;h2&gt;启用LaunchImage&lt;/h2&gt;
&lt;p&gt;启用很简单，在target的general设置中找到 &lt;code&gt;App Icons and Launch Images&lt;/code&gt;， 然后点击 &lt;code&gt;Use Asset Catalog&lt;/code&gt;，接下来按提示操作就可以了。  &lt;/p&gt;
&lt;p&gt;就目前的测试和google搜索情况来看，这种iOS7的不全屏显示问题只能通过这种方式解决。从app的launch过程（下图）可以看出，启动图片的加载是在&lt;code&gt;Load the main UI file&lt;/code&gt;进行的，此时还无法通过代码和程序进行“交互”。&lt;br/&gt;
&lt;img alt="app launch process" src="./imgs/20141016/app_launch_process.png"/&gt;&lt;br/&gt;
(图片来自 &lt;a href="https://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/StrategiesforHandlingAppStateTransitions/StrategiesforHandlingAppStateTransitions.html#//apple_ref/doc/uid/TP40007072-CH8-SW1"&gt;App Programming Guide&lt;/a&gt;)&lt;/p&gt;</summary><category term="ios8"></category><category term="git"></category><category term="launch screen"></category></entry><entry><title>git commit -a 的误区</title><link href="http://icocoa.tk/git-commit-a-de-wu-qu.html" rel="alternate"></link><updated>2014-09-22T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-09-22:git-commit-a-de-wu-qu.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: git 错误理解&lt;/p&gt;
&lt;h2&gt;SVN下的项目管理&lt;/h2&gt;
&lt;p&gt;在使用SVN进行版本管理的时候，我喜欢完成一个功能后进行提交。因为SVN设计的项目大多是在Linux系统，由于缺少较好的IDE，通常会先使用&lt;code&gt;svn status&lt;/code&gt; 查看修改的文件，然后逐一确认，最后使用 &lt;code&gt;svn ci -a -m \"commit content\"&lt;/code&gt; 进行提交。&lt;/p&gt;
&lt;h2&gt;git下的误区&lt;/h2&gt;
&lt;p&gt;大多数情况下，我一直按照SVN的方式处理git项目。我也一直感觉使用&lt;code&gt;git commit -a&lt;/code&gt;很爽，直到有一天发现git的log显示...&lt;br/&gt;
接下来我们来做一些操作：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git init
&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"this is a init text"&lt;/span&gt; &amp;gt;&amp;gt; hello.txt
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master

Initial commit

Untracked files:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to include in what will be committed&lt;span class="o"&gt;)&lt;/span&gt;

    hello.txt

nothing added to commit but untracked files present &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add"&lt;/span&gt; to track&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;很显然，我们需要先“添加” 文件到版本库（注意这个add在git中不是添加到版本库），然后进行提交：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add .
&lt;span class="nv"&gt;$ &lt;/span&gt;git commit -m &lt;span class="s2"&gt;"init commit"&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;接下来修改文件：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"add a line"&lt;/span&gt; &amp;gt;&amp;gt; hello.txt 
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes not staged &lt;span class="k"&gt;for&lt;/span&gt; commit:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to update what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git checkout -- &amp;lt;file&amp;gt;..."&lt;/span&gt; to discard changes in working directory&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt

no changes added to commit &lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add"&lt;/span&gt; and/or &lt;span class="s2"&gt;"git commit -a"&lt;/span&gt;&lt;span class="o"&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;仔细看log，它提示我们先进行add操作再进行commit（如果确定要提交的情形下），但是等一下，add操作不是已经做了吗？难道add的含义不是添加文件到版本库以便进行追踪？&lt;/p&gt;
&lt;h2&gt;git add到底是什么意思&lt;/h2&gt;
&lt;p&gt;我们先接着上面继续操作：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;git add hello.txt 
&lt;span class="nv"&gt;$ &lt;/span&gt;git status
On branch master
Changes to be committed:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git reset HEAD &amp;lt;file&amp;gt;..."&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这时的log和之前相比，没有了add的建议操作，为了更明显显示这种区别：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nv"&gt;$ &lt;/span&gt;&lt;span class="nb"&gt;echo&lt;/span&gt; &lt;span class="s2"&gt;"difference"&lt;/span&gt; &amp;gt;&amp;gt;hello.txt
&lt;span class="nv"&gt;$git&lt;/span&gt; status 
On branch master
Changes to be committed:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git reset HEAD &amp;lt;file&amp;gt;..."&lt;/span&gt; to unstage&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt

Changes not staged &lt;span class="k"&gt;for&lt;/span&gt; commit:
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git add &amp;lt;file&amp;gt;..."&lt;/span&gt; to update what will be committed&lt;span class="o"&gt;)&lt;/span&gt;
&lt;span class="o"&gt;(&lt;/span&gt;use &lt;span class="s2"&gt;"git checkout -- &amp;lt;file&amp;gt;..."&lt;/span&gt; to discard changes in working directory&lt;span class="o"&gt;)&lt;/span&gt;

    modified:   hello.txt
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;或者用－s参数：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="p"&gt;$&lt;/span&gt;&lt;span class="nv"&gt;git&lt;/span&gt;&lt;span class="x"&gt; status -s&lt;/span&gt;
&lt;span class="x"&gt;MM hello.txt //在shell中2个M的颜色显示不一样&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这里可以明白，git中的add操作和svn中的add操作是完全不一样的意思。&lt;br/&gt;
在git中， 执行add操作后是把文件加入版本库的暂存区，而commit针对的内容就只是暂存区。&lt;br/&gt;
而 &lt;code&gt;git commit -a&lt;/code&gt; 其实会先执行add操作再提交暂存区的内容，所以这样做是一个非常不好的实践，因为add到暂存区的操作实际是需要我们严格控制的。至于git上为什么要有这样的设计，那么需要知道 &lt;code&gt;reset&lt;/code&gt; 命令。这个下次再讲。&lt;/p&gt;
&lt;h2&gt;反思&lt;/h2&gt;
&lt;p&gt;很早就知道“暂存区”的概念，可是一直没有深入。git 的 &lt;code&gt;add&lt;/code&gt; 和 &lt;code&gt;commit&lt;/code&gt; 一直使用，可是却没有想到背后的涵义。所谓 “知其然不知其所以然”，实是大忌！&lt;/p&gt;</summary><category term="git"></category></entry><entry><title>QuartzComposer基本概念</title><link href="http://icocoa.tk/quartzcomposerji-ben-gai-nian.html" rel="alternate"></link><updated>2014-08-25T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-08-25:quartzcomposerji-ben-gai-nian.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: a guide to QuartzComposer&lt;/p&gt;
&lt;p&gt;Processors are green, providers are blue, and consumers are pink
最近才发现QuartzComposer也是一款用来设计交互的工具，原来Xcode自带，现在从Xcode中分离成为单独的app。之所以会关注是发现facebook的设计师也比较推崇该工具。在官网上搜索相关文档，内容都比较陈旧，或许说明这个工具比较成熟吧。&lt;/p&gt;
&lt;h3&gt;基本概念&lt;/h3&gt;
&lt;h4&gt;1. composition&lt;/h4&gt;
&lt;p&gt;Composer中创建的文件叫Quartz composition ， 其中最基本的单元（module）叫patch。&lt;/p&gt;
&lt;h4&gt;2. patch&lt;/h4&gt;
&lt;p&gt;patch是最基本的单元，苹果准备了丰富的库来完成一系列操作。patch库可以通过cmd＋enter的方式调用，然后找到需要的patch直接拖即可。patch相当于是一个程序，函数原型相当于：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="nx"&gt;Result&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="kd"&gt;function&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nx"&gt;time&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;&lt;span class="mi"&gt;0&lt;/span&gt; &lt;span class="nx"&gt;or&lt;/span&gt; &lt;span class="nx"&gt;more&lt;/span&gt; &lt;span class="nx"&gt;input&lt;/span&gt; &lt;span class="nx"&gt;parameters&lt;/span&gt;&lt;span class="p"&gt;})&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;在Composer中patch作为了可视化的组件出现了，如下图的billboard。
&lt;img alt="billboard" src="./imgs/20140827/billboard.png"/&gt;&lt;br/&gt;
图中的圆点叫port，左边的port代表输入参数，如果右边也有port的话，就代表输出参数。右上角的数字表示当前所在的层，这个有点类似Quartz2D中的树的概念：数字越小代表着越先执行；从视觉上说，数字越大的会最终显示在view窗口。&lt;/p&gt;
&lt;h5&gt;2.1 patch的种类&lt;/h5&gt;
&lt;ol&gt;
&lt;li&gt;consumer
用蓝色显示，最终会显示在view窗口&lt;/li&gt;
&lt;li&gt;provider
用粉红色表示，将外部源的数据传递进来。这里的外部源指的是鼠标等事件。&lt;/li&gt;
&lt;li&gt;processor
用黑色显示，主要用于将处理过的数据传递给consumer。&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;入门&lt;/h3&gt;
&lt;p&gt;没有使用官方的教程因为没有找到，在库里搜索patch的时候发现有些会带有例子。我是按照&lt;a href="http://qc.prabros.com/primer1.html"&gt;该文&lt;/a&gt;进行入门练习的。&lt;br/&gt;
该示例是模拟点击按钮切换按钮状态的例子，非常详细，跟着练习一边，基本的操作就能上手。最后的作业也很好，主要思路就是在建立一个toogle来过滤状态。&lt;/p&gt;
&lt;h3&gt;感想&lt;/h3&gt;
&lt;p&gt;有了sketch和QuartzComposer，自己设计漂亮的产品将不再遥远啦～&lt;/p&gt;</summary><category term="QuartzComposer"></category></entry><entry><title>MVVM初实践</title><link href="http://icocoa.tk/mvvmchu-shi-jian.html" rel="alternate"></link><updated>2014-08-25T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-08-25:mvvmchu-shi-jian.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: a sample project practising MVVM&lt;/p&gt;
&lt;p&gt;之前已经初步了解了一些MVVM的概念，需要在实践中体会这种设计模式，并理解“响应式”带来的优越性。&lt;br/&gt;
考虑到最近一直在做网盘类产品，于是决定：获取网盘的内容，并可以浏览内容。如果是文件夹的话，则可以点击查看内容。这样，就相当于实现了一个小型的文件查看器。&lt;br/&gt;
另外需要说明的，这里的网盘其实是一个带有系统的SD卡，自身带有AP，可以无线连接访问。同时，提供了API接口获取相关的数据。&lt;/p&gt;
&lt;h3&gt;MVVM 的角色分配&lt;/h3&gt;
&lt;p&gt;视图无疑是用&lt;code&gt;UITableView&lt;/code&gt;, 控制器自然选择&lt;code&gt;UITableViewController&lt;/code&gt;,自然这里需要建立一个&lt;code&gt;ViewModel&lt;/code&gt;来监视一切变化并把这种变化传递给控制器。&lt;/p&gt;
&lt;h3&gt;已知的VM任务&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;获取文件夹列表
 VM需要知道当前所在的路径。另外获取到的数据需要重组：比如去掉隐藏文件，进行排序等。这个操作可以封装在某个数据访问层。&lt;/li&gt;
&lt;li&gt;cell的点击操作
对于文件，需要把文件内容显示出来(为了方便，这里只对图片文件显示)。  &lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;控制器的任务&lt;/h3&gt;
&lt;p&gt;显示页面，以及点击cell时的页面切换。&lt;/p&gt;
&lt;h3&gt;VM的内容&lt;/h3&gt;
&lt;ol&gt;
&lt;li&gt;&lt;code&gt;UITableView&lt;/code&gt;的 &lt;code&gt;dataSource&lt;/code&gt;
dataSource相应的接口需要由VM来实现。在实现cell的时候，cell上的文件名也要通过VM来获取&lt;/li&gt;
&lt;li&gt;数据获取的时机
一般是在VM的信号didBecomeActiveSignal中去注册相应的事件。当事件完成后（获取列表任务），发送更新signal去通知控制器更新页面，因此在控制器中也要注册更新signal收到时相应的事件。整个伪代码逻辑：  &lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//ViewController&lt;/span&gt;
    &lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;weakify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;viewModel&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="nl"&gt;subscribeNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;strongify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;tableView&lt;/span&gt; &lt;span class="n"&gt;reloadData&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;

&lt;span class="c1"&gt;//ViewModel&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt; &lt;span class="n"&gt;RACSubject&lt;/span&gt; &lt;span class="n"&gt;subject&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;setNameWithFormat&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="s"&gt;@"%@_MasterVC"&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;directory&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flashCommand&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="n"&gt;RACCommand&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithSignalBlock&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;input&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="nl"&gt;defer&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="n"&gt;RACSignal&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;{&lt;/span&gt;
        &lt;span class="c1"&gt;//get content list&lt;/span&gt;

        &lt;span class="c1"&gt;//finish data fetching and send signal&lt;/span&gt;

        &lt;span class="p"&gt;[(&lt;/span&gt;&lt;span class="n"&gt;RACSubject&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;updatedContentSignal&lt;/span&gt; &lt;span class="nl"&gt;sendNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
        &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="nb"&gt;nil&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
    &lt;span class="p"&gt;}];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;

&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;weakify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;didBecomeActiveSignal&lt;/span&gt; &lt;span class="nl"&gt;subscribeNext&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="o"&gt;^&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="kt"&gt;id&lt;/span&gt; &lt;span class="n"&gt;x&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt; &lt;span class="p"&gt;{&lt;/span&gt;
&lt;span class="p"&gt;@&lt;/span&gt;&lt;span class="n"&gt;strongify&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
&lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="nb"&gt;self&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;flashCommand&lt;/span&gt; &lt;span class="nl"&gt;execute&lt;/span&gt;&lt;span class="p"&gt;:[&lt;/span&gt;&lt;span class="bp"&gt;NSNull&lt;/span&gt; &lt;span class="n"&gt;null&lt;/span&gt;&lt;span class="p"&gt;]];&lt;/span&gt;
&lt;span class="p"&gt;}];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;/li&gt;
&lt;/ol&gt;
&lt;h3&gt;Cell的点击&lt;/h3&gt;
&lt;p&gt;由于有文件和文件夹的区别，cell无法在storyboard中创建2个push的segue，所以先利用对于文件夹的点击在&lt;code&gt;UITableView&lt;/code&gt;的点击delegate事件中进行操作，而文件的点击则通过&lt;code&gt;performSegueWithIdentifier&lt;/code&gt;来实现。&lt;/p&gt;
&lt;h3&gt;总结&lt;/h3&gt;
&lt;p&gt;总体来说，实践基本按循MVVM的原则来进行，控制器中的内容变得很清爽，基本上只包含对view的控制，和VM的通信则是通过响应式的方式实现的。同时VM中包含了很多数据处理的内容，基本上逻辑的部分都转移到了VM中进行。在这种情况下，一个controller就要配一个VM，不知道会不会又造成VM的臃肿？&lt;/p&gt;</summary><category term="MVVM"></category></entry><entry><title>CentOS6.5 安装eclipse</title><link href="http://icocoa.tk/centos65-an-zhuang-eclipse.html" rel="alternate"></link><updated>2014-07-23T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-23:centos65-an-zhuang-eclipse.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: install eclipse on centos6.5&lt;/p&gt;
&lt;p&gt;最近要开始折腾centos了，需要用eclipse，下面记录下安装中遇到的问题。&lt;/p&gt;
&lt;h3&gt;eclipse 下载&lt;/h3&gt;
&lt;p&gt;直接在&lt;a href="https://www.eclipse.org/downloads/"&gt;官网&lt;/a&gt;下载，选择合适的版本：网站会识别操作系统，主要注意是32位还是64位&lt;br/&gt;
下载后，解压打开，双击eclipse的可执行程序，发现不能启动。弹出的提示说系统的jvm是1.6，而最新luna版需要1.7或以上。&lt;/p&gt;
&lt;h3&gt;jdk安装&lt;/h3&gt;
&lt;p&gt;主要参考了&lt;a href="http://www.cnblogs.com/zhoulf/archive/2013/02/04/2891608.html"&gt;这篇文章&lt;/a&gt;，具体过程就不多说了，注意操作要在su账号下。&lt;/p&gt;
&lt;h4&gt;source /etc/profile 不生效&lt;/h4&gt;
&lt;p&gt;虽然具体步骤不需多讲，不过我遇到了一个以前偶尔也碰到过的问题，就是执行完source后环境变量没有生效的问题。具体的状况是：  &lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;在su下，执行完source /etc/profile，查看$PATH，添加的变量已经生效&lt;/li&gt;
&lt;li&gt;退出su，查看$PATH，发现添加的没有生效&lt;/li&gt;
&lt;li&gt;再次进入su，查看$PATH，发现添加的没有生效&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;目测应该是和linux系统启动的知识有关，果然在&lt;a href="http://www.cnblogs.com/BigIdiot/archive/2012/03/26/2417547.html"&gt;这里&lt;/a&gt;找到了答案，简单的说：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;/etc/profile:在登录时,操作系统定制用户环境时使用的第一个文件,此 文件为系统的每个用户设置环境信息,当用户第一次登录时,该文件被执行。&lt;/li&gt;
&lt;li&gt;/etc/environment:在登录时操作系统使用的第二个文件,系统在 读取你自己的profile前,设置环境文件的环境变量。&lt;/li&gt;
&lt;li&gt;~/.bash_profile:在登录时用到的第三个文件是.profile文 件,每个用户都可使用该文件输入专用于自己使用的shell信息,当用 户登录时,该 文件仅仅执行一次!默认情况下,他设置一些环境变游戏量,执 行用户的.bashrc文件。/etc/bashrc:为每一个运行bash shell的用户执行此文件.当bash shell被打开时,该 文件被读取.&lt;/li&gt;
&lt;li&gt;~/.bashrc:该文件包含专用于你的bash shell的bash信 息,当登录时以及每次打开新的shell时,该该文件被读取。&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;所以，如果修改/etc/profile的话，需要重启系统。&lt;/p&gt;
&lt;p&gt;这样，最终整个过程完成了。&lt;/p&gt;</summary><category term="linux"></category><category term="eclipse"></category><category term="jdk"></category></entry><entry><title>design+code tutorial1 笔记</title><link href="http://icocoa.tk/designcode-tutorial1-bi-ji.html" rel="alternate"></link><updated>2014-07-17T17:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-17:designcode-tutorial1-bi-ji.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: design笔记&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;
&lt;p&gt;背景&lt;br/&gt;
添加2个overlay层渲染，分别斜对角线性和圆渐变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;iOS7模板文件
normal #FAC3FF 10%&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;base shape
normal #FAC3FF 10%
添加圆形，斜对角渐变&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;/li&gt;
&lt;/ol&gt;</summary><category term="iOS"></category><category term="design"></category><category term="sketch"></category></entry><entry><title>MVVM模式初探</title><link href="http://icocoa.tk/mvvmmo-shi-chu-tan.html" rel="alternate"></link><updated>2014-07-17T13:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-17:mvvmmo-shi-chu-tan.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 设计模式&lt;/p&gt;
&lt;h2&gt;MVC的无奈&lt;/h2&gt;
&lt;p&gt;&lt;a href="https://developer.apple.com/library/ios/documentation/General/Conceptual/CocoaEncyclopedia/Model-View-Controller/Model-View-Controller.html"&gt;MVC&lt;/a&gt;结构是学习iOS开发的人最先学习的一种开发模式，apple提倡以MVC为中心的开发模式。因为它很好的解构了应用场景中相关而又各自独立的部分：视图，视图控制器和数据模型。在MVC的世界里，控制器负责将模型中的数据以内容的形式展现到视图中，同时也把视图上产生的数据变化传递给模型从而将这种变化持久化。于是，在稍微复杂的app中，控制器中的内容会很庞大：网络操作，数据存储，手势响应等等。几乎可以确定，如果app需要添加新功能，超过一半的新增代码是添加在控制器中，这样不可避免的造成控制器的冗余以及大段无法重用的重复代码。&lt;br/&gt;
在开始MVVM时，我们可以稍稍考虑下现有MVC的问题。&lt;/p&gt;
&lt;h3&gt;视图&lt;/h3&gt;
&lt;p&gt;毋庸置疑，视图的作用很重要，但在设计中，视图是否需要和控制器，数据模型同等的地位呢？要知道绝大多数情况下，视图是不会重用的，往往“耦合”在视图控制器中，所以往往代码中有几个view controller，就能知道程序会有几个页面。此外，视图中的UI元素也是直接作为变量存在在控制器代码中，因为只有这样才方便刷新。很显然，视图控制器就可以代表视图本身。  &lt;/p&gt;
&lt;h3&gt;控制器&lt;/h3&gt;
&lt;p&gt;控制器需要把模型代表的数据以合适的形式显示在视图上，这样免不了需要处理（当然也有不需要处理的简单情况，这种不考虑）。这部分我们可以通过创建个工具类生成个类方法来实现。可是，当处理大型工程的适合，你会发现这个工具类里的方法或者需要的参数会越来越多或复杂。到最后，工具类会包含所有数据模型类的转换处理方法。这样就显得臃肿，而且在需要转换某个模型类数据的适合，代码提示会给出很多种选择，需要你去甄别。&lt;br/&gt;
从上所知，控制器包含了“太多”处理数据的流程——也叫展现逻辑(presentation logic)， 下面我们可以看到MVVM如何解决这一部分的问题。&lt;/p&gt;
&lt;h2&gt;MVVM&lt;/h2&gt;
&lt;p&gt;在知道MVVM后，我google了一下，发现这个概念是微软提出的。好吧，设计思想是跨平台，放之四海而皆行的真理。首先来看看MVVM的架构：&lt;br/&gt;
&lt;img alt="MVVM scheme" src="./imgs/20140717/mvvm.png"/&gt;&lt;br/&gt;
上图中，视图和视图控制器作为整体连结在一起，通过视图模型(viewmodel)和数据模型发生关系：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;如果数据有了变化，那么通过viewmodel将“变化”通知给视图控制器&lt;/li&gt;
&lt;li&gt;用户操作需要更新持久化数据时，也是通过viewmodel来起作用&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;很显然，viewmodel的出现把与数据模型息息相关的处理部分从视图控制器中移除，这样控制器就得到了“解脱”。虽然多了viewmodel，可是不会增加太多任务，而且重要的是viewmodel很容易进行测试——稍有经验的人都知道视图控制器的测试问题可以成为一个永恒的话题。此外，使用MVC的过程迁移到MVVM并不会太难，——迁移的过程恰好也是梳理的过程，并且整理的更直观。&lt;/p&gt;
&lt;h2&gt;动态响应&lt;/h2&gt;
&lt;p&gt;假设有个app只要简单的直接显示人的姓和名，不需要展现逻辑，是否也不需要viewmodel了呢？继续看上图，你会发现model到viewmodel方向是notify。在app中，一切的变化都可以归结为状态的变化：比如输入字符，用户每输入一个字符，程序都会收到一次相应。又比如，刷新数据，数据接受完毕后，才会去显示。所以，当数据模型变化后，我们会通过一系列机制来“刷新”视图：代理，通知，KVO等等。而viewmodel也需要有这种特性：当数据有个变化后，能够感知，从而可以告诉视图控制器刷新界面。这种响应，通过KVO或者通知都能实现，而在业界现在首推 &lt;a href="https://github.com/ReactiveCocoa/ReactiveViewModel"&gt;ReactiveViewModel&lt;/a&gt;(提到ReactiveCocoa，可以从函数式响应变成开始聊个不停，但这里对ReactiveCocoa本身不做探讨，因为实践中尚未使用)，需要深入的可以去github上看看。使用过cocoa上controller object的，应该对这部分很感兴趣。&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;p&gt;使用MVVM的好处：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;简化了控制器内容&lt;/li&gt;
&lt;li&gt;归并了工具类&lt;/li&gt;
&lt;li&gt;便于测试&lt;/li&gt;
&lt;li&gt;易于动态映射&lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;本文是阅读了&lt;a href="http://www.objc.io/issue-13/mvvm.html"&gt;Model-View-ViewModel for iOS&lt;/a&gt;有感而发, 文中的图片也来源于此。&lt;br/&gt;
其中文末给出的参考文章和示例代码，值得一看。&lt;/p&gt;</summary><category term="iOS"></category><category term="mvvm"></category><category term="mvc"></category><category term="pattern"></category></entry><entry><title>umeng 友盟错误报告处理</title><link href="http://icocoa.tk/umeng-you-meng-cuo-wu-bao-gao-chu-li.html" rel="alternate"></link><updated>2014-07-14T10:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-14:umeng-you-meng-cuo-wu-bao-gao-chu-li.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: 错误报告处理&lt;/p&gt;
&lt;p&gt;今天发现友盟的后台中出现了app crash，打开一看：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;Application received signal SIGSEGV
(null)
(
    0   CoreFoundation                      0x2e44bf23  + 154
    1   libobjc.A.dylib                     0x38bdece7 objc_exception_throw + 38
    2   CoreFoundation                      0x2e44be4d  + 0
    3   ?????????                           0x00107a51 ????????? + 735825
    4   libsystem_platform.dylib            0x391f671b _sigtramp + 34
    5   UIKit                               0x30f20765  + 64
    6   UIKit                               0x30c9a7bd  + 604
    7   UIKit                               0x30f216db  + 1398
    8   UIKit                               0x30d4d3f7  + 418
    9   UIKit                               0x30d4d24f  + 30
    10  UIKit                               0x30d4d207  + 30
    11  UIKit                               0x30c7b977  + 378
    12  UIKit                               0x3116a977  + 110
    13  libobjc.A.dylib                     0x38bee0d3  + 358
    14  CoreFoundation                      0x2e37f4c1 _CFAutoreleasePoolPop + 16
    15  UIKit                               0x30c73bc1  + 36
    16  CoreFoundation                      0x2e417039  + 20
    17  CoreFoundation                      0x2e4149c7  + 286
    18  CoreFoundation                      0x2e414d13  + 738
    19  CoreFoundation                      0x2e37f769 CFRunLoopRunSpecific + 524
    20  CoreFoundation                      0x2e37f54b CFRunLoopRunInMode + 106
    21  GraphicsServices                    0x332dc6d3 GSEventRunModal + 138
    22  UIKit                               0x30cde891 UIApplicationMain + 1136
    23  ?????????                           0x0007bfd3 ????????? + 163795
    24  libdyld.dylib                       0x390dcab7  + 2
)
dSYM UUID: xx-XXX-38B1-B7A0-2XXXXX
CPU Type: armv7s
Slide Address: 0x00004000
Binary Image: ???
Base Address: 0x00054000
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;因为没有相应的dsym信息，所以出错后没有办法symbolicate，也就看不到具体是那个方法引起的。这时我们就要通过上传的archive包，来查找相应地址对应的函数。这里需要说明的是，因为程序的bundle设置为了中文，所以会有上述的_?????_出现。因此，我们也可以得到，程序中引起crash的方法对应的函数地址是&lt;strong&gt;0x0007bfd3&lt;/strong&gt;。&lt;br/&gt;
接下来，我们在xcode找到上传成功的archive包，通过_show in finder_定位。xarchive后缀的文件和app后缀的文件一样，也是个bundle，可以通过右键&lt;em&gt;show content&lt;/em&gt; 打开。我们需要使用的可执行程序包，通常在:  &lt;/p&gt;
&lt;p&gt;&lt;code&gt;/Products/Applications/YourAppName.app/YourAppName&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;然后使用命令：&lt;br/&gt;
&lt;code&gt;atos -arch armv7s -o /Products/Applications/YourAppName.app/YourAppName 0x0007bfd3&lt;/code&gt;&lt;br/&gt;
这样就会显示出是哪一个方法引起crash了。&lt;/p&gt;</summary><category term="iOS"></category><category term="sigsegv"></category></entry><entry><title>Sketch Tutorials Study 1</title><link href="http://icocoa.tk/sketch-tutorials-study-1.html" rel="alternate"></link><updated>2014-07-08T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-08:sketch-tutorials-study-1.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: some tutorials of sketch&lt;/p&gt;
&lt;p&gt;sketch是Mac上优秀的设计软件，堪称一把利剑。可好剑还得配好剑法，才能发挥威力。最近做的app，在界面上欠缺不少，正好借助sketch进行优化。下面是根据几个tutorial学习了sketch和设计的相关步骤。&lt;/p&gt;
&lt;h3&gt;Flat Styled Icon&lt;/h3&gt;
&lt;p&gt;原文在此：&lt;a href="https://medium.com/@sokratus/how-to-create-a-flat-styled-icon-in-sketch-3-27c4bd09989"&gt;flat styled icon &lt;/a&gt; &lt;br/&gt;
该示例主要展示了&lt;strong&gt;相交&lt;/strong&gt;运算的作用，以及锚点的使用。很多图形，仔细观察，都可以通过各种图形进行布尔运算而实现。通过形状的运算实现，还方便给各个部分填色。不过这一部分对我还是有点难，需要多练习。&lt;br/&gt;
另外，sketch中可以通过双击来激活编辑状态，然后编辑锚点。但是我发现有时候对组合过的图像，这个方法有点不太灵。这时，可以先在左边选中图形，然后点击上方状态栏的"Edit"，然后就可以自由添加锚点了。&lt;/p&gt;
&lt;h3&gt;Shadow Effect&lt;/h3&gt;
&lt;p&gt;原文在此：&lt;a href="http://brilliantsketch.com/make-long-shadow-effect-sketch/"&gt;shadow effect&lt;/a&gt; &lt;br/&gt;
该示例主要讲解了模糊、mask和锚点的使用。对于想做阴影效果，非常有帮助。我还依葫芦画瓢实现了文中文字的shadow效果。理解了这个方法，基本上阴影的实现就掌握了。&lt;/p&gt;
&lt;p&gt;最后，我的练习地址：&lt;a href="https://github.com/scorpiozj/blogproject/tree/master/sketch"&gt;github&lt;/a&gt;&lt;/p&gt;</summary><category term="sketch"></category></entry><entry><title>WWDC2014-223 Notes Protyping</title><link href="http://icocoa.tk/wwdc2014-223-notes-protyping.html" rel="alternate"></link><updated>2014-07-03T22:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-07-03:wwdc2014-223-notes-protyping.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu
Summary: notes for 223&lt;/p&gt;
&lt;p&gt;原型设计的作用好比开发阶段设计的作用一样，不可缺少。它可以节约时间、成本，把有限的资源放到需要的地方。&lt;br/&gt;
这一讲的内容分为下面几个部分：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;原型的重要性&lt;/li&gt;
&lt;li&gt;如何利用原型改进产品&lt;/li&gt;
&lt;li&gt;原型设计的工具&lt;/li&gt;
&lt;li&gt;制作fake app&lt;/li&gt;
&lt;/ol&gt;
&lt;h2&gt;重要性&lt;/h2&gt;
&lt;p&gt;它的重要性在于是点子到产品过程中的必经之路，做得越充分越有利用产品的形成。这个毋需多言。&lt;/p&gt;
&lt;h2&gt;步骤&lt;/h2&gt;
&lt;p&gt;How是进行原型的关键，通常就是结构任务，并带着问题去回答每一步。演讲者将过程分为3步：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Make fake apps&lt;/li&gt;
&lt;li&gt;Show people&lt;/li&gt;
&lt;li&gt;Learn from their feedback
三者的关系如下图：&lt;br/&gt;
&lt;img alt="relations icon" src="./imgs/20140703/how-relations.png"/&gt;&lt;br/&gt;
这个闭环首先表明原型设计的无止境，同时也表明这是一个带有反馈的系统表达。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Make&lt;/h3&gt;
&lt;p&gt;演讲者给了3个问题来帮助剖析：&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What needs to be more real&lt;/li&gt;
&lt;li&gt;What can we fake&lt;/li&gt;
&lt;li&gt;Where will they use it&lt;br/&gt;
make的目的是为了给人看，那么就需要判断fake app中看上去更真实（和最终产品的样貌一致的部分），以及哪些部分进行fake（指的是不是仅仅用几张屏幕截图来组成fake app，而是分割成不同的组成部分），比如文字，图标，图片等。当然，我们要确保用户会在iphone/ipad的设备上使用。&lt;/li&gt;
&lt;/ul&gt;
&lt;h3&gt;Show&lt;/h3&gt;
&lt;p&gt;还是3个问题:   &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Do you know how to ____?&lt;/li&gt;
&lt;li&gt;is it easy to ____?&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;How can we make this better?
这里的空格就是表示fake app所承载的功能，就是问用户：  &lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;我这个是用来做某某事的，你知道怎么做吗&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;这样做操作简单吗&lt;/li&gt;
&lt;li&gt;怎么能做更好？  &lt;/li&gt;
&lt;/ul&gt;
&lt;p&gt;当然，如果设计考虑到了"Ituitive"的话，用户对fake app的功能应该一目了然。&lt;/p&gt;
&lt;h3&gt;Learn&lt;/h3&gt;
&lt;p&gt;这一部分就是闭环反馈系统的关键了，正反馈吸收，负反馈反思。同时看看有没有碰撞起火花，产生新的灵感&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;What's working&lt;/li&gt;
&lt;li&gt;what's not working&lt;/li&gt;
&lt;li&gt;what other ideas does this give us?&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;工具&lt;/h2&gt;
&lt;p&gt;主要演示了用keynote进行protype的方法。keynote（或ppt）的动画功能还是一流的，每个人或多或少知道些。在这个过程中，演讲者使用了一个寻找好吃的toast的app为例，演示了如何进行上述环节的过程。这一部分，需要亲自看，体会才能更深&lt;/p&gt;
&lt;h2&gt;制作演示程序&lt;/h2&gt;
&lt;p&gt;使用xcode和core animation制作成可以在device上运行的app。示例的例子在官网上可以下载：&lt;a href="https://developer.apple.com/library/prerelease/ios/samplecode/ToastModern/"&gt;ToastModern&lt;/a&gt;&lt;/p&gt;
&lt;h2&gt;总结&lt;/h2&gt;
&lt;ul&gt;
&lt;li&gt;如何protype是最大的收获，但是这一过程需要多练。  &lt;/li&gt;
&lt;li&gt;各种工具的灵活使用：谁知道keynote也可以protype呢？&lt;/li&gt;
&lt;li&gt;制作fake app的技巧： 不局限于coding实现&lt;/li&gt;
&lt;/ul&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category></entry><entry><title>WWDC2014-211 Notes designing_intuitive_user_experiences</title><link href="http://icocoa.tk/wwdc2014-211-notes-designing_intuitive_user_experiences.html" rel="alternate"></link><updated>2014-06-30T14:20:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-06-30:wwdc2014-211-notes-designing_intuitive_user_experiences.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: Notes for 211&lt;/p&gt;
&lt;h1&gt;intuitive&lt;/h1&gt;
&lt;p&gt;字面意思是“直觉”，意思就是看见页面后就知道该如何操作。这种“知道”可以来源于经验，惯例以及提示  &lt;/p&gt;
&lt;p&gt;开篇就举了设计 &lt;em&gt;“笔”&lt;/em&gt; 的例子：长度，宽度等元素&lt;/p&gt;
&lt;p&gt;Being ituitive is not intuitive&lt;br/&gt;
记住设计不是为自己(已知者)设计，是为其他人设计&lt;/p&gt;
&lt;p&gt;以下按5部分，进行阐述  &lt;/p&gt;
&lt;h2&gt;platform savvy&lt;/h2&gt;
&lt;p&gt;设计“intuitive”的交互，首先要熟悉所在系统的特性。以滑动cell出现操作选项为例，说明用户会进行“滑动”的操作——这种操作在iOS上是“周知”的。而你提供类似的功能时就要遵循一定的“规范”：背景色，长宽，文字说明，文字字体／大小，滑动触发的距离等等。&lt;br/&gt;
这里强调的是设计要和系统保持一致性。类似的包括手势操作：tap, pan, swipe, pinch, long press, rotate，控件：button／switch等。比如，tab的选中和非选中状态设置。&lt;br/&gt;
同时也说明为什么要保持这种一致性：因为是我们对真实世界体验的表现——显然有点是自夸自家的设计了&lt;br/&gt;
当然，演讲者也说明打破惯例（break convention）也不是不可以，这时就需要告诉用户如何使用了——有点像引导操作，但不一样。&lt;/p&gt;
&lt;h2&gt;easy to navigate&lt;/h2&gt;
&lt;p&gt;经典的导航式结构，主要还是围绕以下3个方面来解释：
&lt;em&gt; Tells you where you are
&lt;/em&gt; Shows you where else you can go
&lt;em&gt; Explain what's there
印象深的是“maximize continuty”：以photo中点击小图查看大图的导航为例，可以明确大图是来自哪一张小图。&lt;br/&gt;
这里居然还“批判”了抽屉式导航（视频里叫 hamburger）:
&lt;/em&gt; 页面的内容在app中不可见，需要通过左上方（一般都是放置在左上方）的按钮点开后显示
&lt;em&gt; 通过该页面进行app内容切换的场景很少
&lt;/em&gt; 页面切换耗费比较多：要比nav＋tab式多点一次，以及2倍的等待切换动画完成
当然hamburger也不是不能用（毕竟辩证法说明了万事没有绝对），但是在使用之前还是需要围绕最初的3个方面进行甄别&lt;/p&gt;
&lt;h2&gt;clear&lt;/h2&gt;
&lt;p&gt;清晰-&amp;gt;达意。 比如，tab选中后tintcolor显示出来就很明确告诉用户当前是在哪里。演讲者还侧重谈了如何撰写文字/设计icon&lt;/p&gt;
&lt;h2&gt;simple&lt;/h2&gt;
&lt;p&gt;80/20法则，80%的用户只会使用app提供的20%功能&lt;/p&gt;
&lt;h2&gt;focused&lt;/h2&gt;
&lt;p&gt;简单的说，就是app的目的是什么，那么所有的操作都为然着这个目的而来。&lt;/p&gt;
&lt;p&gt;设计真是门艺术——大家都能判断出体验的好坏，但却不能据此进行改良。这部分内容不仅对designer，对开发／产品人员，也大有裨益——虽然我的体会不是很深。&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category><category term="ux"></category></entry><entry><title>WWDC2014-221 Notes creating_custom_ios_user_interfaces</title><link href="http://icocoa.tk/wwdc2014-221-notes-creating_custom_ios_user_interfaces.html" rel="alternate"></link><updated>2014-06-29T14:00:00+08:00</updated><author><name>Charles Zhu</name></author><id>tag:icocoa.tk,2014-06-29:wwdc2014-221-notes-creating_custom_ios_user_interfaces.html</id><summary type="html">&lt;p&gt;Author: Charles Zhu&lt;br/&gt;
Summary: notes for 221&lt;/p&gt;
&lt;p&gt;本场主要分4个议题： &lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;Spring animations&lt;/li&gt;
&lt;li&gt;Vibrancy and blur&lt;/li&gt;
&lt;li&gt;Shape layers&lt;/li&gt;
&lt;li&gt;Dynamic Core Animation behaviors&lt;/li&gt;
&lt;/ul&gt;
&lt;h2&gt;Spring animations&lt;/h2&gt;
&lt;p&gt;顾名思义指的是弹簧动画，很容易让人联想到UIKit Dynamic中的spring效果。但是，UIKit中就提供了API:  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;+ (void)animateWithDuration:(NSTimeInterval)duration delay:(NSTimeInterval)delay usingSpringWithDamping:(CGFloat)dampingRatio initialSpringVelocity:(CGFloat)velocity options:(UIViewAnimationOptions)options animations:(void (^)(void))animations completion:(void (^)(BOOL finished))completion
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;这是iOS7中就有的API，它和UIKit提供的普通animation API很类似，增加的两个参数：&lt;code&gt;dampingRatio&lt;/code&gt;就是弹性系数，范围在0-1之间，通常取接近1的值；&lt;code&gt;velocity&lt;/code&gt;就是动画的初始速度，这个参数可以用下图来理解：&lt;br/&gt;
&lt;img alt="spring icon" src="./imgs/20140629/spring.png"/&gt;&lt;br/&gt;
横坐标是动画的事件，纵坐标是动画中变化的属性值。那么可以看到，普通的UIView animation的动画过程是比较平滑的；而spring的话，刚开始的“速率”就快多了。&lt;br/&gt;
Spring动画在iOS7中就已经是很多控件的标配，比如在屏幕上拉出设置页面，就带有spring效果。而且从这个API的设计接口来看，估计以后UIView 的普通animation API是会被spring所取代了。所以，在自定义控件的动画中，要注意使用spring动画，以符合iOS的风格&lt;/p&gt;
&lt;h2&gt;Vibrancy and blur&lt;/h2&gt;
&lt;p&gt;iOS7中有用于创建blur view的API：  &lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;-drawViewHierarchyInRect:afterScreenUpdates:, 
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;通过该API可以将当前view的状态以UIImage绘制出来：&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="c1"&gt;//https://developer.apple.com/library/ios/qa/qa1817/_index.html&lt;/span&gt;
  &lt;span class="o"&gt;-&lt;/span&gt; &lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="bp"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="nl"&gt;snapshot&lt;/span&gt;&lt;span class="p"&gt;:(&lt;/span&gt;&lt;span class="bp"&gt;UIView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="p"&gt;)&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;
 &lt;span class="p"&gt;{&lt;/span&gt;
     &lt;span class="n"&gt;UIGraphicsBeginImageContextWithOptions&lt;/span&gt;&lt;span class="p"&gt;(&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;size&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt; &lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;,&lt;/span&gt;  &lt;span class="mi"&gt;0&lt;/span&gt;&lt;span class="p"&gt;);&lt;/span&gt;
    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt; &lt;span class="nl"&gt;drawViewHierarchyInRect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;view&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt; &lt;span class="nl"&gt;afterScreenUpdates&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="nb"&gt;YES&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
    &lt;span class="bp"&gt;UIImage&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;image&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;UIGraphicsGetImageFromCurrentImageContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="n"&gt;UIGraphicsEndImageContext&lt;/span&gt;&lt;span class="p"&gt;();&lt;/span&gt;
    &lt;span class="k"&gt;return&lt;/span&gt; &lt;span class="n"&gt;image&lt;/span&gt;&lt;span class="p"&gt;;&lt;/span&gt;
&lt;span class="p"&gt;}&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;而去年的wwdc中有对UIImage进行blur的例子，两者结合就可以对UIView进行blur化。这种方式用官方语言描述就是：fast&amp;amp;&amp;amp;static. 而如今Apple提供了直接的API——&lt;code&gt;UIVisualEffectView&lt;/code&gt;，使用方式很简单，就是先创建一个effect，然后再提供给view进行初始化,然后把它添加到要blur的view上。&lt;/p&gt;
&lt;div class="highlight"&gt;&lt;pre&gt;&lt;span class="bp"&gt;UIVisualEffect&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;blurEffect&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="bp"&gt;UIBlurEffect&lt;/span&gt; &lt;span class="nl"&gt;effectWithStyle&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;UIBlurEffectStyleLight&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="bp"&gt;UIVisualEffectView&lt;/span&gt; &lt;span class="o"&gt;*&lt;/span&gt;&lt;span class="n"&gt;visualEffectView&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="p"&gt;[[&lt;/span&gt;&lt;span class="bp"&gt;UIVisualEffectView&lt;/span&gt; &lt;span class="n"&gt;alloc&lt;/span&gt;&lt;span class="p"&gt;]&lt;/span&gt; &lt;span class="nl"&gt;initWithEffect&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;blurEffect&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;

    &lt;span class="n"&gt;visualEffectView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;frame&lt;/span&gt; &lt;span class="o"&gt;=&lt;/span&gt; &lt;span class="n"&gt;imageView&lt;/span&gt;&lt;span class="p"&gt;.&lt;/span&gt;&lt;span class="n"&gt;bounds&lt;/span&gt;

    &lt;span class="p"&gt;[&lt;/span&gt;&lt;span class="n"&gt;imageView&lt;/span&gt; &lt;span class="nl"&gt;addSubview&lt;/span&gt;&lt;span class="p"&gt;:&lt;/span&gt;&lt;span class="n"&gt;visualEffectView&lt;/span&gt;&lt;span class="p"&gt;];&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;可见，这里&lt;code&gt;UIVisualEffectView&lt;/code&gt;变成了类似mask的东西。此外，该view提供blur和vibrancy两种效果。&lt;/p&gt;
&lt;h2&gt;Shape layers&lt;/h2&gt;
&lt;p&gt;这是个很古老的东西，它有一个path的属性，可以构建各种路径，从而方便定制UI。它的使用也很简单，和&lt;code&gt;CALayer&lt;/code&gt;的用法类似。&lt;/p&gt;
&lt;h2&gt;Dynamic Core Animation behaviors&lt;/h2&gt;
&lt;p&gt;主要通过实现&lt;code&gt;CAAction&lt;/code&gt;协议来实现动画。UIView animation的机制：&lt;br/&gt;
&lt;img alt="UIView Animation" src="./imgs/20140629/dynamic_core_animation.png"/&gt; &lt;br/&gt;
UIView会去查找是否实现&lt;code&gt;CAAction&lt;/code&gt;协议，没有实现的话就会调用：&lt;br/&gt;
&lt;code&gt;[super actionForLayer:layer key:event]&lt;/code&gt;。因此，如果实现了&lt;code&gt;CAAction&lt;/code&gt;协议就可以定制动画。&lt;/p&gt;
&lt;p&gt;&lt;a href="https://github.com/scorpiozj/blogproject/tree/master/WWDC2014_221"&gt;项目地址&lt;/a&gt;&lt;/p&gt;</summary><category term="wwdc 2014"></category><category term="ui"></category><category term="ios"></category></entry></feed>